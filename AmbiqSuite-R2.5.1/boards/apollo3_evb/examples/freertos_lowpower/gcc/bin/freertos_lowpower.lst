
bin/freertos_lowpower.axf:     file format elf32-littlearm


Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 23 00 10 35 f7 00 00 29 f7 00 00 ad e5 00 00     .#..5...).......
    c010:	2d f7 00 00 2d f7 00 00 2d f7 00 00 00 00 00 00     -...-...-.......
	...
    c02c:	c1 c6 00 00 31 f7 00 00 00 00 00 00 31 c7 00 00     ....1.......1...
    c03c:	95 c7 00 00 31 f7 00 00 31 f7 00 00 31 f7 00 00     ....1...1...1...
    c04c:	31 f7 00 00 31 f7 00 00 31 f7 00 00 31 f7 00 00     1...1...1...1...
    c05c:	31 f7 00 00 31 f7 00 00 31 f7 00 00 31 f7 00 00     1...1...1...1...
    c06c:	31 f7 00 00 31 f7 00 00 1d c4 00 00 c9 c5 00 00     1...1...........
    c07c:	31 f7 00 00 31 f7 00 00 31 f7 00 00 31 f7 00 00     1...1...1...1...
    c08c:	31 f7 00 00 31 f7 00 00 31 f7 00 00 31 f7 00 00     1...1...1...1...
    c09c:	3d c9 00 00 5d c9 00 00 31 f7 00 00 31 f7 00 00     =...]...1...1...
    c0ac:	31 f7 00 00 31 f7 00 00 31 f7 00 00 31 f7 00 00     1...1...1...1...
    c0bc:	31 f7 00 00                                         1...

0000c0c0 <__Patchable>:
	...

0000c100 <memcpy>:
    c100:	4684      	mov	ip, r0
    c102:	ea41 0300 	orr.w	r3, r1, r0
    c106:	f013 0303 	ands.w	r3, r3, #3
    c10a:	d16d      	bne.n	c1e8 <memcpy+0xe8>
    c10c:	3a40      	subs	r2, #64	; 0x40
    c10e:	d341      	bcc.n	c194 <memcpy+0x94>
    c110:	f851 3b04 	ldr.w	r3, [r1], #4
    c114:	f840 3b04 	str.w	r3, [r0], #4
    c118:	f851 3b04 	ldr.w	r3, [r1], #4
    c11c:	f840 3b04 	str.w	r3, [r0], #4
    c120:	f851 3b04 	ldr.w	r3, [r1], #4
    c124:	f840 3b04 	str.w	r3, [r0], #4
    c128:	f851 3b04 	ldr.w	r3, [r1], #4
    c12c:	f840 3b04 	str.w	r3, [r0], #4
    c130:	f851 3b04 	ldr.w	r3, [r1], #4
    c134:	f840 3b04 	str.w	r3, [r0], #4
    c138:	f851 3b04 	ldr.w	r3, [r1], #4
    c13c:	f840 3b04 	str.w	r3, [r0], #4
    c140:	f851 3b04 	ldr.w	r3, [r1], #4
    c144:	f840 3b04 	str.w	r3, [r0], #4
    c148:	f851 3b04 	ldr.w	r3, [r1], #4
    c14c:	f840 3b04 	str.w	r3, [r0], #4
    c150:	f851 3b04 	ldr.w	r3, [r1], #4
    c154:	f840 3b04 	str.w	r3, [r0], #4
    c158:	f851 3b04 	ldr.w	r3, [r1], #4
    c15c:	f840 3b04 	str.w	r3, [r0], #4
    c160:	f851 3b04 	ldr.w	r3, [r1], #4
    c164:	f840 3b04 	str.w	r3, [r0], #4
    c168:	f851 3b04 	ldr.w	r3, [r1], #4
    c16c:	f840 3b04 	str.w	r3, [r0], #4
    c170:	f851 3b04 	ldr.w	r3, [r1], #4
    c174:	f840 3b04 	str.w	r3, [r0], #4
    c178:	f851 3b04 	ldr.w	r3, [r1], #4
    c17c:	f840 3b04 	str.w	r3, [r0], #4
    c180:	f851 3b04 	ldr.w	r3, [r1], #4
    c184:	f840 3b04 	str.w	r3, [r0], #4
    c188:	f851 3b04 	ldr.w	r3, [r1], #4
    c18c:	f840 3b04 	str.w	r3, [r0], #4
    c190:	3a40      	subs	r2, #64	; 0x40
    c192:	d2bd      	bcs.n	c110 <memcpy+0x10>
    c194:	3230      	adds	r2, #48	; 0x30
    c196:	d311      	bcc.n	c1bc <memcpy+0xbc>
    c198:	f851 3b04 	ldr.w	r3, [r1], #4
    c19c:	f840 3b04 	str.w	r3, [r0], #4
    c1a0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1a4:	f840 3b04 	str.w	r3, [r0], #4
    c1a8:	f851 3b04 	ldr.w	r3, [r1], #4
    c1ac:	f840 3b04 	str.w	r3, [r0], #4
    c1b0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1b4:	f840 3b04 	str.w	r3, [r0], #4
    c1b8:	3a10      	subs	r2, #16
    c1ba:	d2ed      	bcs.n	c198 <memcpy+0x98>
    c1bc:	320c      	adds	r2, #12
    c1be:	d305      	bcc.n	c1cc <memcpy+0xcc>
    c1c0:	f851 3b04 	ldr.w	r3, [r1], #4
    c1c4:	f840 3b04 	str.w	r3, [r0], #4
    c1c8:	3a04      	subs	r2, #4
    c1ca:	d2f9      	bcs.n	c1c0 <memcpy+0xc0>
    c1cc:	3204      	adds	r2, #4
    c1ce:	d008      	beq.n	c1e2 <memcpy+0xe2>
    c1d0:	07d2      	lsls	r2, r2, #31
    c1d2:	bf1c      	itt	ne
    c1d4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c1d8:	f800 3b01 	strbne.w	r3, [r0], #1
    c1dc:	d301      	bcc.n	c1e2 <memcpy+0xe2>
    c1de:	880b      	ldrh	r3, [r1, #0]
    c1e0:	8003      	strh	r3, [r0, #0]
    c1e2:	4660      	mov	r0, ip
    c1e4:	4770      	bx	lr
    c1e6:	bf00      	nop
    c1e8:	2a08      	cmp	r2, #8
    c1ea:	d313      	bcc.n	c214 <memcpy+0x114>
    c1ec:	078b      	lsls	r3, r1, #30
    c1ee:	d08d      	beq.n	c10c <memcpy+0xc>
    c1f0:	f010 0303 	ands.w	r3, r0, #3
    c1f4:	d08a      	beq.n	c10c <memcpy+0xc>
    c1f6:	f1c3 0304 	rsb	r3, r3, #4
    c1fa:	1ad2      	subs	r2, r2, r3
    c1fc:	07db      	lsls	r3, r3, #31
    c1fe:	bf1c      	itt	ne
    c200:	f811 3b01 	ldrbne.w	r3, [r1], #1
    c204:	f800 3b01 	strbne.w	r3, [r0], #1
    c208:	d380      	bcc.n	c10c <memcpy+0xc>
    c20a:	f831 3b02 	ldrh.w	r3, [r1], #2
    c20e:	f820 3b02 	strh.w	r3, [r0], #2
    c212:	e77b      	b.n	c10c <memcpy+0xc>
    c214:	3a04      	subs	r2, #4
    c216:	d3d9      	bcc.n	c1cc <memcpy+0xcc>
    c218:	3a01      	subs	r2, #1
    c21a:	f811 3b01 	ldrb.w	r3, [r1], #1
    c21e:	f800 3b01 	strb.w	r3, [r0], #1
    c222:	d2f9      	bcs.n	c218 <memcpy+0x118>
    c224:	780b      	ldrb	r3, [r1, #0]
    c226:	7003      	strb	r3, [r0, #0]
    c228:	784b      	ldrb	r3, [r1, #1]
    c22a:	7043      	strb	r3, [r0, #1]
    c22c:	788b      	ldrb	r3, [r1, #2]
    c22e:	7083      	strb	r3, [r0, #2]
    c230:	4660      	mov	r0, ip
    c232:	4770      	bx	lr

0000c234 <__aeabi_d2f>:
    c234:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c238:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c23c:	bf24      	itt	cs
    c23e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c242:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c246:	d90d      	bls.n	c264 <__aeabi_d2f+0x30>
    c248:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c24c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    c250:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    c254:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    c258:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    c25c:	bf08      	it	eq
    c25e:	f020 0001 	biceq.w	r0, r0, #1
    c262:	4770      	bx	lr
    c264:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    c268:	d121      	bne.n	c2ae <__aeabi_d2f+0x7a>
    c26a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    c26e:	bfbc      	itt	lt
    c270:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    c274:	4770      	bxlt	lr
    c276:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c27a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    c27e:	f1c2 0218 	rsb	r2, r2, #24
    c282:	f1c2 0c20 	rsb	ip, r2, #32
    c286:	fa10 f30c 	lsls.w	r3, r0, ip
    c28a:	fa20 f002 	lsr.w	r0, r0, r2
    c28e:	bf18      	it	ne
    c290:	f040 0001 	orrne.w	r0, r0, #1
    c294:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c298:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    c29c:	fa03 fc0c 	lsl.w	ip, r3, ip
    c2a0:	ea40 000c 	orr.w	r0, r0, ip
    c2a4:	fa23 f302 	lsr.w	r3, r3, r2
    c2a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c2ac:	e7cc      	b.n	c248 <__aeabi_d2f+0x14>
    c2ae:	ea7f 5362 	mvns.w	r3, r2, asr #21
    c2b2:	d107      	bne.n	c2c4 <__aeabi_d2f+0x90>
    c2b4:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    c2b8:	bf1e      	ittt	ne
    c2ba:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    c2be:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    c2c2:	4770      	bxne	lr
    c2c4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    c2c8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    c2cc:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    c2d0:	4770      	bx	lr
    c2d2:	bf00      	nop

0000c2d4 <disable_print_interface>:
disable_print_interface(void)
{
    //
    // Deinitialize a debug printing interface.
    //
    am_bsp_itm_printf_disable();
    c2d4:	f003 baf4 	b.w	f8c0 <am_bsp_itm_printf_disable>

0000c2d8 <main>:
main(void)
{
    //
    // Set the clock frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c2d8:	2100      	movs	r1, #0
{
    c2da:	b508      	push	{r3, lr}
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    c2dc:	4608      	mov	r0, r1
    c2de:	f003 fca7 	bl	fc30 <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    c2e2:	480d      	ldr	r0, [pc, #52]	; (c318 <main+0x40>)
    c2e4:	f003 fafc 	bl	f8e0 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    c2e8:	f003 fb1e 	bl	f928 <am_hal_cachectrl_enable>
#ifndef NOFPU
    //
    // Enable the floating point module, and configure the core for lazy
    // stacking.
    //
    am_hal_sysctrl_fpu_enable();
    c2ec:	f004 fbb4 	bl	10a58 <am_hal_sysctrl_fpu_enable>
    am_hal_sysctrl_fpu_stacking_enable(true);
    c2f0:	2001      	movs	r0, #1
    c2f2:	f004 fbb9 	bl	10a68 <am_hal_sysctrl_fpu_stacking_enable>
#endif

    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    c2f6:	f003 faa3 	bl	f840 <am_bsp_low_power_init>

    //
    // Turn off unneeded Flash & SRAM
    //
#if defined(AM_PART_APOLLO3)
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_SRAM_96K);
    c2fa:	2004      	movs	r0, #4
    c2fc:	f004 f9ae 	bl	1065c <am_hal_pwrctrl_memory_enable>
#endif
#if defined(AM_PART_APOLLO3P)
    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_SRAM_32K_DTCM);
#endif

    am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_FLASH_MIN);
    c300:	200e      	movs	r0, #14
    c302:	f004 f9ab 	bl	1065c <am_hal_pwrctrl_memory_enable>
    am_bsp_itm_printf_enable();
    c306:	f003 fabb 	bl	f880 <am_bsp_itm_printf_enable>
#endif

    //
    // Initialize plotting interface.
    //
    am_util_debug_printf("FreeRTOS Low Power Example\n");
    c30a:	4804      	ldr	r0, [pc, #16]	; (c31c <main+0x44>)
    c30c:	f003 f900 	bl	f510 <am_util_stdio_printf>

    //
    // Run the application.
    //
    run_tasks();
    c310:	f000 f972 	bl	c5f8 <run_tasks>

    //
    // We shouldn't ever get here.
    //
    while (1)
    c314:	e7fe      	b.n	c314 <main+0x3c>
    c316:	bf00      	nop
    c318:	00010eb8 	.word	0x00010eb8
    c31c:	00010b3c 	.word	0x00010b3c

0000c320 <button2_handler>:
    button_handler(1);
}

void
button2_handler(void)
{
    c320:	b510      	push	{r4, lr}
    c322:	240a      	movs	r4, #10
    c324:	b082      	sub	sp, #8
    // Debounce for 20 ms.
    // We're triggered for rising edge - so we expect a consistent HIGH here
    //
    for (count = 0; count < 10; count++)
    {
        am_hal_gpio_state_read(AM_BSP_GPIO_BUTTON2,  AM_HAL_GPIO_INPUT_READ, &val);
    c326:	466a      	mov	r2, sp
    c328:	2100      	movs	r1, #0
    c32a:	2013      	movs	r0, #19
    c32c:	f003 ff16 	bl	1015c <am_hal_gpio_state_read>
        if (!val)
    c330:	9b00      	ldr	r3, [sp, #0]
        {
            return; // State not high...must be result of debounce
        }
        am_util_delay_ms(2);
    c332:	2002      	movs	r0, #2
        if (!val)
    c334:	b1c3      	cbz	r3, c368 <button2_handler+0x48>
        am_util_delay_ms(2);
    c336:	f002 f925 	bl	e584 <am_util_delay_ms>
    for (count = 0; count < 10; count++)
    c33a:	3c01      	subs	r4, #1
    c33c:	d1f3      	bne.n	c326 <button2_handler+0x6>
    xResult = xEventGroupSetBitsFromISR(xLedEventHandle, (1 << buttonId),
    c33e:	4b0b      	ldr	r3, [pc, #44]	; (c36c <button2_handler+0x4c>)
    c340:	480b      	ldr	r0, [pc, #44]	; (c370 <button2_handler+0x50>)
    c342:	6819      	ldr	r1, [r3, #0]
    xHigherPriorityTaskWoken = pdFALSE;
    c344:	9401      	str	r4, [sp, #4]
    xResult = xEventGroupSetBitsFromISR(xLedEventHandle, (1 << buttonId),
    c346:	ab01      	add	r3, sp, #4
    c348:	2204      	movs	r2, #4
    c34a:	f002 f907 	bl	e55c <xTimerPendFunctionCallFromISR>
    if (xResult != pdFAIL)
    c34e:	b158      	cbz	r0, c368 <button2_handler+0x48>
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    c350:	9b01      	ldr	r3, [sp, #4]
    c352:	b14b      	cbz	r3, c368 <button2_handler+0x48>
    c354:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c358:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c35c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    c360:	f3bf 8f4f 	dsb	sy
    c364:	f3bf 8f6f 	isb	sy
    }

    button_handler(2);
}
    c368:	b002      	add	sp, #8
    c36a:	bd10      	pop	{r4, pc}
    c36c:	10002340 	.word	0x10002340
    c370:	0000cbe5 	.word	0x0000cbe5

0000c374 <button0_handler>:
{
    c374:	b510      	push	{r4, lr}
    c376:	240a      	movs	r4, #10
    c378:	b082      	sub	sp, #8
        am_hal_gpio_state_read(AM_BSP_GPIO_BUTTON0,  AM_HAL_GPIO_INPUT_READ, &val);
    c37a:	466a      	mov	r2, sp
    c37c:	2100      	movs	r1, #0
    c37e:	2010      	movs	r0, #16
    c380:	f003 feec 	bl	1015c <am_hal_gpio_state_read>
        if (!val)
    c384:	9b00      	ldr	r3, [sp, #0]
        am_util_delay_ms(2);
    c386:	2002      	movs	r0, #2
        if (!val)
    c388:	b1c3      	cbz	r3, c3bc <button0_handler+0x48>
        am_util_delay_ms(2);
    c38a:	f002 f8fb 	bl	e584 <am_util_delay_ms>
    for (count = 0; count < 10; count++)
    c38e:	3c01      	subs	r4, #1
    c390:	d1f3      	bne.n	c37a <button0_handler+0x6>
    xResult = xEventGroupSetBitsFromISR(xLedEventHandle, (1 << buttonId),
    c392:	4b0b      	ldr	r3, [pc, #44]	; (c3c0 <button0_handler+0x4c>)
    c394:	480b      	ldr	r0, [pc, #44]	; (c3c4 <button0_handler+0x50>)
    c396:	6819      	ldr	r1, [r3, #0]
    xHigherPriorityTaskWoken = pdFALSE;
    c398:	9401      	str	r4, [sp, #4]
    xResult = xEventGroupSetBitsFromISR(xLedEventHandle, (1 << buttonId),
    c39a:	ab01      	add	r3, sp, #4
    c39c:	2201      	movs	r2, #1
    c39e:	f002 f8dd 	bl	e55c <xTimerPendFunctionCallFromISR>
    if (xResult != pdFAIL)
    c3a2:	b158      	cbz	r0, c3bc <button0_handler+0x48>
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    c3a4:	9b01      	ldr	r3, [sp, #4]
    c3a6:	b14b      	cbz	r3, c3bc <button0_handler+0x48>
    c3a8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c3ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c3b0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    c3b4:	f3bf 8f4f 	dsb	sy
    c3b8:	f3bf 8f6f 	isb	sy
}
    c3bc:	b002      	add	sp, #8
    c3be:	bd10      	pop	{r4, pc}
    c3c0:	10002340 	.word	0x10002340
    c3c4:	0000cbe5 	.word	0x0000cbe5

0000c3c8 <button1_handler>:
{
    c3c8:	b510      	push	{r4, lr}
    c3ca:	240a      	movs	r4, #10
    c3cc:	b082      	sub	sp, #8
        am_hal_gpio_state_read(AM_BSP_GPIO_BUTTON1,  AM_HAL_GPIO_INPUT_READ, &val);
    c3ce:	466a      	mov	r2, sp
    c3d0:	2100      	movs	r1, #0
    c3d2:	2012      	movs	r0, #18
    c3d4:	f003 fec2 	bl	1015c <am_hal_gpio_state_read>
        if (!val)
    c3d8:	9b00      	ldr	r3, [sp, #0]
        am_util_delay_ms(2);
    c3da:	2002      	movs	r0, #2
        if (!val)
    c3dc:	b1c3      	cbz	r3, c410 <button1_handler+0x48>
        am_util_delay_ms(2);
    c3de:	f002 f8d1 	bl	e584 <am_util_delay_ms>
    for (count = 0; count < 10; count++)
    c3e2:	3c01      	subs	r4, #1
    c3e4:	d1f3      	bne.n	c3ce <button1_handler+0x6>
    xResult = xEventGroupSetBitsFromISR(xLedEventHandle, (1 << buttonId),
    c3e6:	4b0b      	ldr	r3, [pc, #44]	; (c414 <button1_handler+0x4c>)
    c3e8:	480b      	ldr	r0, [pc, #44]	; (c418 <button1_handler+0x50>)
    c3ea:	6819      	ldr	r1, [r3, #0]
    xHigherPriorityTaskWoken = pdFALSE;
    c3ec:	9401      	str	r4, [sp, #4]
    xResult = xEventGroupSetBitsFromISR(xLedEventHandle, (1 << buttonId),
    c3ee:	ab01      	add	r3, sp, #4
    c3f0:	2202      	movs	r2, #2
    c3f2:	f002 f8b3 	bl	e55c <xTimerPendFunctionCallFromISR>
    if (xResult != pdFAIL)
    c3f6:	b158      	cbz	r0, c410 <button1_handler+0x48>
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    c3f8:	9b01      	ldr	r3, [sp, #4]
    c3fa:	b14b      	cbz	r3, c410 <button1_handler+0x48>
    c3fc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c400:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c404:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    c408:	f3bf 8f4f 	dsb	sy
    c40c:	f3bf 8f6f 	isb	sy
}
    c410:	b002      	add	sp, #8
    c412:	bd10      	pop	{r4, pc}
    c414:	10002340 	.word	0x10002340
    c418:	0000cbe5 	.word	0x0000cbe5

0000c41c <am_gpio_isr>:
{
    c41c:	b500      	push	{lr}
    c41e:	b083      	sub	sp, #12
    am_hal_gpio_interrupt_status_get(false, &ui64Status);
    c420:	4669      	mov	r1, sp
    c422:	2000      	movs	r0, #0
    c424:	f003 ff4e 	bl	102c4 <am_hal_gpio_interrupt_status_get>
    am_hal_gpio_interrupt_clear(ui64Status);
    c428:	e9dd 0100 	ldrd	r0, r1, [sp]
    c42c:	f003 ff30 	bl	10290 <am_hal_gpio_interrupt_clear>
    am_hal_gpio_interrupt_service(ui64Status);
    c430:	e9dd 0100 	ldrd	r0, r1, [sp]
    c434:	f003 ff76 	bl	10324 <am_hal_gpio_interrupt_service>
}
    c438:	b003      	add	sp, #12
    c43a:	f85d fb04 	ldr.w	pc, [sp], #4
    c43e:	bf00      	nop

0000c440 <LedTaskSetup>:
// Perform initial setup for the LED task.
//
//*****************************************************************************
void
LedTaskSetup(void)
{
    c440:	b510      	push	{r4, lr}
    am_util_debug_printf("LEDTask: setup\r\n");
    c442:	4832      	ldr	r0, [pc, #200]	; (c50c <LedTaskSetup+0xcc>)
    c444:	f003 f864 	bl	f510 <am_util_stdio_printf>

    //
    // Create an event handle for our wake-up events.
    //
    xLedEventHandle = xEventGroupCreate();
    c448:	f000 fb58 	bl	cafc <xEventGroupCreate>
    c44c:	4b30      	ldr	r3, [pc, #192]	; (c510 <LedTaskSetup+0xd0>)
    c44e:	6018      	str	r0, [r3, #0]

    //
    // Make sure we actually allocated space for the events we need.
    //
    while (xLedEventHandle == NULL);
    c450:	b900      	cbnz	r0, c454 <LedTaskSetup+0x14>
    c452:	e7fe      	b.n	c452 <LedTaskSetup+0x12>

    // Initialize the LEDs
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    c454:	482f      	ldr	r0, [pc, #188]	; (c514 <LedTaskSetup+0xd4>)
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    c456:	4c30      	ldr	r4, [pc, #192]	; (c518 <LedTaskSetup+0xd8>)
    c458:	2105      	movs	r1, #5
    c45a:	f003 f8f1 	bl	f640 <am_devices_led_array_init>
    am_devices_led_off(am_bsp_psLEDs, 0);
    c45e:	482d      	ldr	r0, [pc, #180]	; (c514 <LedTaskSetup+0xd4>)
    c460:	2100      	movs	r1, #0
    c462:	f003 f91f 	bl	f6a4 <am_devices_led_off>
    am_devices_led_off(am_bsp_psLEDs, 1);
    c466:	482b      	ldr	r0, [pc, #172]	; (c514 <LedTaskSetup+0xd4>)
    c468:	2101      	movs	r1, #1
    c46a:	f003 f91b 	bl	f6a4 <am_devices_led_off>
    am_devices_led_off(am_bsp_psLEDs, 2);
    c46e:	4829      	ldr	r0, [pc, #164]	; (c514 <LedTaskSetup+0xd4>)
    c470:	2102      	movs	r1, #2
    c472:	f003 f917 	bl	f6a4 <am_devices_led_off>
    am_devices_led_off(am_bsp_psLEDs, 3);
    c476:	4827      	ldr	r0, [pc, #156]	; (c514 <LedTaskSetup+0xd4>)
    c478:	2103      	movs	r1, #3
    c47a:	f003 f913 	bl	f6a4 <am_devices_led_off>
    am_devices_led_off(am_bsp_psLEDs, 4);
    c47e:	4825      	ldr	r0, [pc, #148]	; (c514 <LedTaskSetup+0xd4>)
    c480:	2104      	movs	r1, #4
    c482:	f003 f90f 	bl	f6a4 <am_devices_led_off>
    c486:	2380      	movs	r3, #128	; 0x80
    c488:	f884 330d 	strb.w	r3, [r4, #781]	; 0x30d
    NVIC_SetPriority(GPIO_IRQn, NVIC_configMAX_SYSCALL_INTERRUPT_PRIORITY);
    //
    // Register interrupt handler for button presses
    //
    am_hal_gpio_interrupt_register(AM_BSP_GPIO_BUTTON0, button0_handler);
    c48c:	4923      	ldr	r1, [pc, #140]	; (c51c <LedTaskSetup+0xdc>)
    c48e:	2010      	movs	r0, #16
    c490:	f003 ff38 	bl	10304 <am_hal_gpio_interrupt_register>
    am_hal_gpio_interrupt_register(AM_BSP_GPIO_BUTTON1, button1_handler);
    c494:	4922      	ldr	r1, [pc, #136]	; (c520 <LedTaskSetup+0xe0>)
    c496:	2012      	movs	r0, #18
    c498:	f003 ff34 	bl	10304 <am_hal_gpio_interrupt_register>
    am_hal_gpio_interrupt_register(AM_BSP_GPIO_BUTTON2, button2_handler);
    c49c:	4921      	ldr	r1, [pc, #132]	; (c524 <LedTaskSetup+0xe4>)
    c49e:	2013      	movs	r0, #19
    c4a0:	f003 ff30 	bl	10304 <am_hal_gpio_interrupt_register>

    am_hal_gpio_pinconfig(AM_BSP_GPIO_BUTTON0, g_AM_BSP_GPIO_BUTTON0);
    c4a4:	4b20      	ldr	r3, [pc, #128]	; (c528 <LedTaskSetup+0xe8>)
    c4a6:	2010      	movs	r0, #16
    c4a8:	6819      	ldr	r1, [r3, #0]
    c4aa:	f003 fd21 	bl	fef0 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_BUTTON1, g_AM_BSP_GPIO_BUTTON1);
    c4ae:	4b1f      	ldr	r3, [pc, #124]	; (c52c <LedTaskSetup+0xec>)
    c4b0:	2012      	movs	r0, #18
    c4b2:	6819      	ldr	r1, [r3, #0]
    c4b4:	f003 fd1c 	bl	fef0 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_BSP_GPIO_BUTTON2, g_AM_BSP_GPIO_BUTTON2);
    c4b8:	4b1d      	ldr	r3, [pc, #116]	; (c530 <LedTaskSetup+0xf0>)
    c4ba:	2013      	movs	r0, #19
    c4bc:	6819      	ldr	r1, [r3, #0]
    c4be:	f003 fd17 	bl	fef0 <am_hal_gpio_pinconfig>
    // Clear the GPIO Interrupt (write to clear).
    //
    AM_HAL_GPIO_MASKCREATE(GpioIntMask0);
    AM_HAL_GPIO_MASKCREATE(GpioIntMask1);
    AM_HAL_GPIO_MASKCREATE(GpioIntMask2);
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_MASKBIT(pGpioIntMask0, AM_BSP_GPIO_BUTTON0));
    c4c2:	2100      	movs	r1, #0
    c4c4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    c4c8:	f003 fee2 	bl	10290 <am_hal_gpio_interrupt_clear>
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_MASKBIT(pGpioIntMask1, AM_BSP_GPIO_BUTTON1));
    c4cc:	2100      	movs	r1, #0
    c4ce:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    c4d2:	f003 fedd 	bl	10290 <am_hal_gpio_interrupt_clear>
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_MASKBIT(pGpioIntMask2, AM_BSP_GPIO_BUTTON2));
    c4d6:	2100      	movs	r1, #0
    c4d8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    c4dc:	f003 fed8 	bl	10290 <am_hal_gpio_interrupt_clear>

    //
    // Enable the GPIO/button interrupt.
    //
    am_hal_gpio_interrupt_enable(AM_HAL_GPIO_MASKBIT(pGpioIntMask0, AM_BSP_GPIO_BUTTON0));
    c4e0:	2100      	movs	r1, #0
    c4e2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    c4e6:	f003 feb3 	bl	10250 <am_hal_gpio_interrupt_enable>
    am_hal_gpio_interrupt_enable(AM_HAL_GPIO_MASKBIT(pGpioIntMask1, AM_BSP_GPIO_BUTTON1));
    c4ea:	2100      	movs	r1, #0
    c4ec:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    c4f0:	f003 feae 	bl	10250 <am_hal_gpio_interrupt_enable>
    am_hal_gpio_interrupt_enable(AM_HAL_GPIO_MASKBIT(pGpioIntMask2, AM_BSP_GPIO_BUTTON2));
    c4f4:	2100      	movs	r1, #0
    c4f6:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    c4fa:	f003 fea9 	bl	10250 <am_hal_gpio_interrupt_enable>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c4fe:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c502:	6023      	str	r3, [r4, #0]

    //
    // Enable interrupts to the core.
    //
    am_hal_interrupt_master_enable();
}
    c504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_hal_interrupt_master_enable();
    c508:	f003 bf6a 	b.w	103e0 <am_hal_interrupt_master_enable>
    c50c:	00010b58 	.word	0x00010b58
    c510:	10002340 	.word	0x10002340
    c514:	10002308 	.word	0x10002308
    c518:	e000e100 	.word	0xe000e100
    c51c:	0000c375 	.word	0x0000c375
    c520:	0000c3c9 	.word	0x0000c3c9
    c524:	0000c321 	.word	0x0000c321
    c528:	00010ea8 	.word	0x00010ea8
    c52c:	00010eac 	.word	0x00010eac
    c530:	00010eb0 	.word	0x00010eb0

0000c534 <LedTask>:
// Short Description.
//
//*****************************************************************************
void
LedTask(void *pvParameters)
{
    c534:	b5f0      	push	{r4, r5, r6, r7, lr}
    c536:	4e12      	ldr	r6, [pc, #72]	; (c580 <LedTask+0x4c>)
        {
            // Button Press Event received
            // Toggle respective LED(s)
            if (bitSet & (1 << 0))
            {
                am_devices_led_toggle(am_bsp_psLEDs, 0);
    c538:	4f12      	ldr	r7, [pc, #72]	; (c584 <LedTask+0x50>)
{
    c53a:	b083      	sub	sp, #12
        bitSet = xEventGroupWaitBits(xLedEventHandle, 0x7, pdTRUE,
    c53c:	f04f 35ff 	mov.w	r5, #4294967295
    c540:	6830      	ldr	r0, [r6, #0]
    c542:	9500      	str	r5, [sp, #0]
    c544:	2300      	movs	r3, #0
    c546:	2201      	movs	r2, #1
    c548:	2107      	movs	r1, #7
    c54a:	f000 fae5 	bl	cb18 <xEventGroupWaitBits>
        if (bitSet != 0)
    c54e:	4604      	mov	r4, r0
    c550:	2800      	cmp	r0, #0
    c552:	d0f5      	beq.n	c540 <LedTask+0xc>
            if (bitSet & (1 << 0))
    c554:	07c1      	lsls	r1, r0, #31
    c556:	d40d      	bmi.n	c574 <LedTask+0x40>
            }
            if (bitSet & (1 << 1))
    c558:	07a2      	lsls	r2, r4, #30
    c55a:	d406      	bmi.n	c56a <LedTask+0x36>
            {
                am_devices_led_toggle(am_bsp_psLEDs, 1);
            }
            if (bitSet & (1 << 2))
    c55c:	0763      	lsls	r3, r4, #29
    c55e:	d5ef      	bpl.n	c540 <LedTask+0xc>
            {
                am_devices_led_toggle(am_bsp_psLEDs, 2);
    c560:	2102      	movs	r1, #2
    c562:	4638      	mov	r0, r7
    c564:	f003 f8b6 	bl	f6d4 <am_devices_led_toggle>
    c568:	e7ea      	b.n	c540 <LedTask+0xc>
                am_devices_led_toggle(am_bsp_psLEDs, 1);
    c56a:	4638      	mov	r0, r7
    c56c:	2101      	movs	r1, #1
    c56e:	f003 f8b1 	bl	f6d4 <am_devices_led_toggle>
    c572:	e7f3      	b.n	c55c <LedTask+0x28>
                am_devices_led_toggle(am_bsp_psLEDs, 0);
    c574:	4638      	mov	r0, r7
    c576:	2100      	movs	r1, #0
    c578:	f003 f8ac 	bl	f6d4 <am_devices_led_toggle>
    c57c:	e7ec      	b.n	c558 <LedTask+0x24>
    c57e:	bf00      	nop
    c580:	10002340 	.word	0x10002340
    c584:	10002308 	.word	0x10002308

0000c588 <setup_task>:
// features.
//
//*****************************************************************************
void
setup_task(void *pvParameters)
{
    c588:	b500      	push	{lr}
    //
    // Print a debug message.
    //
    am_util_debug_printf("Running setup tasks...\r\n");
    c58a:	480b      	ldr	r0, [pc, #44]	; (c5b8 <setup_task+0x30>)
{
    c58c:	b083      	sub	sp, #12
    am_util_debug_printf("Running setup tasks...\r\n");
    c58e:	f002 ffbf 	bl	f510 <am_util_stdio_printf>

    //
    // Run setup functions.
    //
    LedTaskSetup();
    c592:	f7ff ff55 	bl	c440 <LedTaskSetup>
    disable_print_interface();
    c596:	f7ff fe9d 	bl	c2d4 <disable_print_interface>
    //
    // Create the functional tasks
    //
    xTaskCreate(LedTask, "LEDTask", 512, 0, 3, &led_task_handle);
    c59a:	4a08      	ldr	r2, [pc, #32]	; (c5bc <setup_task+0x34>)
    c59c:	4908      	ldr	r1, [pc, #32]	; (c5c0 <setup_task+0x38>)
    c59e:	4809      	ldr	r0, [pc, #36]	; (c5c4 <setup_task+0x3c>)
    c5a0:	2303      	movs	r3, #3
    c5a2:	e9cd 3200 	strd	r3, r2, [sp]
    c5a6:	2300      	movs	r3, #0
    c5a8:	f44f 7200 	mov.w	r2, #512	; 0x200
    c5ac:	f001 f828 	bl	d600 <xTaskCreate>
    //
    // The setup operations are complete, so suspend the setup task now.
    //
    vTaskSuspend(NULL);
    c5b0:	2000      	movs	r0, #0
    c5b2:	f001 f955 	bl	d860 <vTaskSuspend>

    while (1);
    c5b6:	e7fe      	b.n	c5b6 <setup_task+0x2e>
    c5b8:	00010b6c 	.word	0x00010b6c
    c5bc:	1000233c 	.word	0x1000233c
    c5c0:	00010b88 	.word	0x00010b88
    c5c4:	0000c535 	.word	0x0000c535

0000c5c8 <am_ctimer_isr>:
{
    c5c8:	b510      	push	{r4, lr}
    ui32Status = am_hal_ctimer_int_status_get(false);
    c5ca:	2000      	movs	r0, #0
    c5cc:	f003 fc14 	bl	fdf8 <am_hal_ctimer_int_status_get>
    c5d0:	4604      	mov	r4, r0
    am_hal_ctimer_int_clear(ui32Status);
    c5d2:	f003 fbff 	bl	fdd4 <am_hal_ctimer_int_clear>
    am_hal_ctimer_int_service(ui32Status);
    c5d6:	4620      	mov	r0, r4
}
    c5d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    am_hal_ctimer_int_service(ui32Status);
    c5dc:	f003 bbe2 	b.w	fda4 <am_hal_ctimer_int_service>

0000c5e0 <am_freertos_sleep>:
{
    c5e0:	b508      	push	{r3, lr}
    am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
    c5e2:	2001      	movs	r0, #1
    c5e4:	f004 fa00 	bl	109e8 <am_hal_sysctrl_sleep>
}
    c5e8:	2000      	movs	r0, #0
    c5ea:	bd08      	pop	{r3, pc}

0000c5ec <am_freertos_wakeup>:
}
    c5ec:	4770      	bx	lr
    c5ee:	bf00      	nop

0000c5f0 <vApplicationMallocFailedHook>:
    while (1);
    c5f0:	e7fe      	b.n	c5f0 <vApplicationMallocFailedHook>
    c5f2:	bf00      	nop

0000c5f4 <vApplicationStackOverflowHook>:
        __asm("BKPT #0\n") ; // Break into the debugger
    c5f4:	be00      	bkpt	0x0000
    while (1)
    c5f6:	e7fd      	b.n	c5f4 <vApplicationStackOverflowHook>

0000c5f8 <run_tasks>:
// Initializes all tasks
//
//*****************************************************************************
void
run_tasks(void)
{
    c5f8:	b500      	push	{lr}
    //

    //
    // Create essential tasks.
    //
    xTaskCreate(setup_task, "Setup", 128, 0, 3, &xSetupTask);
    c5fa:	4a08      	ldr	r2, [pc, #32]	; (c61c <run_tasks+0x24>)
    c5fc:	4908      	ldr	r1, [pc, #32]	; (c620 <run_tasks+0x28>)
    c5fe:	4809      	ldr	r0, [pc, #36]	; (c624 <run_tasks+0x2c>)
{
    c600:	b083      	sub	sp, #12
    xTaskCreate(setup_task, "Setup", 128, 0, 3, &xSetupTask);
    c602:	2303      	movs	r3, #3
    c604:	e9cd 3200 	strd	r3, r2, [sp]
    c608:	2300      	movs	r3, #0
    c60a:	2280      	movs	r2, #128	; 0x80
    c60c:	f000 fff8 	bl	d600 <xTaskCreate>

    //
    // Start the scheduler.
    //
    vTaskStartScheduler();
}
    c610:	b003      	add	sp, #12
    c612:	f85d eb04 	ldr.w	lr, [sp], #4
    vTaskStartScheduler();
    c616:	f001 b993 	b.w	d940 <vTaskStartScheduler>
    c61a:	bf00      	nop
    c61c:	10002344 	.word	0x10002344
    c620:	00010b90 	.word	0x00010b90
    c624:	0000c589 	.word	0x0000c589

0000c628 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
    c628:	4b0a      	ldr	r3, [pc, #40]	; (c654 <prvTaskExitError+0x2c>)
    c62a:	681b      	ldr	r3, [r3, #0]
{
    c62c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
    c62e:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
    c630:	3301      	adds	r3, #1
volatile uint32_t ulDummy = 0;
    c632:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
    c634:	d000      	beq.n	c638 <prvTaskExitError+0x10>
    c636:	e7fe      	b.n	c636 <prvTaskExitError+0xe>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
    c638:	f04f 0380 	mov.w	r3, #128	; 0x80
    c63c:	f383 8811 	msr	BASEPRI, r3
    c640:	f3bf 8f6f 	isb	sy
    c644:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
    c648:	9b01      	ldr	r3, [sp, #4]
    c64a:	2b00      	cmp	r3, #0
    c64c:	d0fc      	beq.n	c648 <prvTaskExitError+0x20>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
    c64e:	b002      	add	sp, #8
    c650:	4770      	bx	lr
    c652:	bf00      	nop
    c654:	10002300 	.word	0x10002300

0000c658 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
    c658:	4808      	ldr	r0, [pc, #32]	; (c67c <prvPortStartFirstTask+0x24>)
    c65a:	6800      	ldr	r0, [r0, #0]
    c65c:	6800      	ldr	r0, [r0, #0]
    c65e:	f380 8808 	msr	MSP, r0
    c662:	f04f 0000 	mov.w	r0, #0
    c666:	f380 8814 	msr	CONTROL, r0
    c66a:	b662      	cpsie	i
    c66c:	b661      	cpsie	f
    c66e:	f3bf 8f4f 	dsb	sy
    c672:	f3bf 8f6f 	isb	sy
    c676:	df00      	svc	0
    c678:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
    c67a:	0000      	.short	0x0000
    c67c:	e000ed08 	.word	0xe000ed08

0000c680 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
    c680:	f8df 000c 	ldr.w	r0, [pc, #12]	; c690 <vPortEnableVFP+0x10>
    c684:	6801      	ldr	r1, [r0, #0]
    c686:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c68a:	6001      	str	r1, [r0, #0]
    c68c:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
    c68e:	0000      	.short	0x0000
    c690:	e000ed88 	.word	0xe000ed88

0000c694 <pxPortInitialiseStack>:
{
    c694:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    c696:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    c69a:	4c07      	ldr	r4, [pc, #28]	; (c6b8 <pxPortInitialiseStack+0x24>)
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    c69c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
    c6a0:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    c6a4:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    c6a8:	e940 4103 	strd	r4, r1, [r0, #-12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    c6ac:	e940 3209 	strd	r3, r2, [r0, #-36]	; 0x24
}
    c6b0:	f85d 4b04 	ldr.w	r4, [sp], #4
    c6b4:	3844      	subs	r0, #68	; 0x44
    c6b6:	4770      	bx	lr
    c6b8:	0000c629 	.word	0x0000c629
    c6bc:	00000000 	.word	0x00000000

0000c6c0 <SVC_Handler>:
	__asm volatile (
    c6c0:	4b07      	ldr	r3, [pc, #28]	; (c6e0 <pxCurrentTCBConst2>)
    c6c2:	6819      	ldr	r1, [r3, #0]
    c6c4:	6808      	ldr	r0, [r1, #0]
    c6c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c6ca:	f380 8809 	msr	PSP, r0
    c6ce:	f3bf 8f6f 	isb	sy
    c6d2:	f04f 0000 	mov.w	r0, #0
    c6d6:	f380 8811 	msr	BASEPRI, r0
    c6da:	4770      	bx	lr
    c6dc:	f3af 8000 	nop.w

0000c6e0 <pxCurrentTCBConst2>:
    c6e0:	10002360 	.word	0x10002360

0000c6e4 <vPortEnterCritical>:
    c6e4:	f04f 0380 	mov.w	r3, #128	; 0x80
    c6e8:	f383 8811 	msr	BASEPRI, r3
    c6ec:	f3bf 8f6f 	isb	sy
    c6f0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    c6f4:	4a07      	ldr	r2, [pc, #28]	; (c714 <vPortEnterCritical+0x30>)
    c6f6:	6813      	ldr	r3, [r2, #0]
    c6f8:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
    c6fa:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    c6fc:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
    c6fe:	d000      	beq.n	c702 <vPortEnterCritical+0x1e>
}
    c700:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
    c702:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c706:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
    c70a:	b2db      	uxtb	r3, r3
    c70c:	2b00      	cmp	r3, #0
    c70e:	d0f7      	beq.n	c700 <vPortEnterCritical+0x1c>
    c710:	e7fe      	b.n	c710 <vPortEnterCritical+0x2c>
    c712:	bf00      	nop
    c714:	10002300 	.word	0x10002300

0000c718 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
    c718:	4a04      	ldr	r2, [pc, #16]	; (c72c <vPortExitCritical+0x14>)
    c71a:	6813      	ldr	r3, [r2, #0]
    c71c:	b12b      	cbz	r3, c72a <vPortExitCritical+0x12>
	uxCriticalNesting--;
    c71e:	3b01      	subs	r3, #1
    c720:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
    c722:	b90b      	cbnz	r3, c728 <vPortExitCritical+0x10>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
    c724:	f383 8811 	msr	BASEPRI, r3
}
    c728:	4770      	bx	lr
	configASSERT( uxCriticalNesting );
    c72a:	e7fe      	b.n	c72a <vPortExitCritical+0x12>
    c72c:	10002300 	.word	0x10002300

0000c730 <PendSV_Handler>:
	__asm volatile
    c730:	f3ef 8009 	mrs	r0, PSP
    c734:	f3bf 8f6f 	isb	sy
    c738:	4b15      	ldr	r3, [pc, #84]	; (c790 <pxCurrentTCBConst>)
    c73a:	681a      	ldr	r2, [r3, #0]
    c73c:	f01e 0f10 	tst.w	lr, #16
    c740:	bf08      	it	eq
    c742:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    c746:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c74a:	6010      	str	r0, [r2, #0]
    c74c:	e92d 0009 	stmdb	sp!, {r0, r3}
    c750:	f04f 0080 	mov.w	r0, #128	; 0x80
    c754:	f380 8811 	msr	BASEPRI, r0
    c758:	f3bf 8f4f 	dsb	sy
    c75c:	f3bf 8f6f 	isb	sy
    c760:	f001 fb8a 	bl	de78 <vTaskSwitchContext>
    c764:	f04f 0000 	mov.w	r0, #0
    c768:	f380 8811 	msr	BASEPRI, r0
    c76c:	bc09      	pop	{r0, r3}
    c76e:	6819      	ldr	r1, [r3, #0]
    c770:	6808      	ldr	r0, [r1, #0]
    c772:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c776:	f01e 0f10 	tst.w	lr, #16
    c77a:	bf08      	it	eq
    c77c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    c780:	f380 8809 	msr	PSP, r0
    c784:	f3bf 8f6f 	isb	sy
    c788:	4770      	bx	lr
    c78a:	bf00      	nop
    c78c:	f3af 8000 	nop.w

0000c790 <pxCurrentTCBConst>:
    c790:	10002360 	.word	0x10002360

0000c794 <SysTick_Handler>:
{
    c794:	b508      	push	{r3, lr}
	__asm volatile
    c796:	f04f 0380 	mov.w	r3, #128	; 0x80
    c79a:	f383 8811 	msr	BASEPRI, r3
    c79e:	f3bf 8f6f 	isb	sy
    c7a2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
    c7a6:	f001 f9cf 	bl	db48 <xTaskIncrementTick>
    c7aa:	b128      	cbz	r0, c7b8 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    c7ac:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c7b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c7b4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
    c7b8:	2300      	movs	r3, #0
    c7ba:	f383 8811 	msr	BASEPRI, r3
}
    c7be:	bd08      	pop	{r3, pc}

0000c7c0 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
    c7c0:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
    c7c4:	2b0f      	cmp	r3, #15
    c7c6:	d906      	bls.n	c7d6 <vPortValidateInterruptPriority+0x16>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    c7c8:	4909      	ldr	r1, [pc, #36]	; (c7f0 <vPortValidateInterruptPriority+0x30>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    c7ca:	4a0a      	ldr	r2, [pc, #40]	; (c7f4 <vPortValidateInterruptPriority+0x34>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
    c7cc:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
    c7ce:	7812      	ldrb	r2, [r2, #0]
    c7d0:	429a      	cmp	r2, r3
    c7d2:	d900      	bls.n	c7d6 <vPortValidateInterruptPriority+0x16>
    c7d4:	e7fe      	b.n	c7d4 <vPortValidateInterruptPriority+0x14>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
    c7d6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c7da:	4a07      	ldr	r2, [pc, #28]	; (c7f8 <vPortValidateInterruptPriority+0x38>)
    c7dc:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
    c7e0:	6812      	ldr	r2, [r2, #0]
    c7e2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    c7e6:	4293      	cmp	r3, r2
    c7e8:	d900      	bls.n	c7ec <vPortValidateInterruptPriority+0x2c>
    c7ea:	e7fe      	b.n	c7ea <vPortValidateInterruptPriority+0x2a>
	}
    c7ec:	4770      	bx	lr
    c7ee:	bf00      	nop
    c7f0:	e000e3f0 	.word	0xe000e3f0
    c7f4:	10002350 	.word	0x10002350
    c7f8:	10002354 	.word	0x10002354

0000c7fc <vPortSuppressTicksAndSleep>:
 * resolution of the Tick timer.
 */
	static uint32_t xMaximumPossibleSuppressedTicks = 0;

void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
    c7fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t New_Timer, Delta_Sleep;
	TickType_t xModifiableIdleTime;
    uint32_t elapsed_time;

	/* Make sure the SysTick reload value does not overflow the counter. */
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    c800:	4b2c      	ldr	r3, [pc, #176]	; (c8b4 <vPortSuppressTicksAndSleep+0xb8>)


	/* Calculate the reload value required to wait xExpectedIdleTime
	tick periods.  -1 is used because this code will execute part way
	through one of the tick periods. */
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    c802:	f8df 90b8 	ldr.w	r9, [pc, #184]	; c8bc <vPortSuppressTicksAndSleep+0xc0>
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    c806:	f8d3 a000 	ldr.w	sl, [r3]
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    c80a:	f8d9 8000 	ldr.w	r8, [r9]
{
    c80e:	4605      	mov	r5, r0

	/* Enter a critical section but don't use the taskENTER_CRITICAL()
	method as that will mask interrupts that should exit sleep mode. */
	__asm volatile( "cpsid i" );
    c810:	b672      	cpsid	i
	__asm volatile( "dsb" );
    c812:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    c816:	f3bf 8f6f 	isb	sy
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
    // Adjust for the time already elapsed
    uint32_t curTime = am_hal_stimer_counter_get();
    c81a:	f004 f85d 	bl	108d8 <am_hal_stimer_counter_get>
    gF_stimerGetHistory[gF_stimerGetHistoryCount][1] = curTime;
    gF_stimerGetHistory[gF_stimerGetHistoryCount][2] = AM_REGVAL(AM_REG_STIMER_COMPARE(0, 0));
    gF_stimerGetHistory[gF_stimerGetHistoryCount][3] = gF_stimerHistoryCount;
    gF_stimerGetHistoryCount++;
#endif
    elapsed_time = curTime - g_lastSTimerVal;
    c81e:	4f26      	ldr	r7, [pc, #152]	; (c8b8 <vPortSuppressTicksAndSleep+0xbc>)
    uint32_t curTime = am_hal_stimer_counter_get();
    c820:	4604      	mov	r4, r0
    elapsed_time = curTime - g_lastSTimerVal;
    c822:	683e      	ldr	r6, [r7, #0]


	/* If a context switch is pending or a task is waiting for the scheduler
	to be unsuspended then abandon the low power entry. */
    /* Abandon low power entry if the sleep time is too short */
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    c824:	f001 fccc 	bl	e1c0 <eTaskConfirmSleepModeStatus>
    c828:	b158      	cbz	r0, c842 <vPortSuppressTicksAndSleep+0x46>
    c82a:	4555      	cmp	r5, sl
    c82c:	f8d9 3000 	ldr.w	r3, [r9]
    c830:	bf28      	it	cs
    c832:	4655      	movcs	r5, sl
    c834:	1b9b      	subs	r3, r3, r6
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    c836:	1e69      	subs	r1, r5, #1
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    c838:	4423      	add	r3, r4
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
    c83a:	fb08 f801 	mul.w	r8, r8, r1
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
    c83e:	4543      	cmp	r3, r8
    c840:	d902      	bls.n	c848 <vPortSuppressTicksAndSleep+0x4c>

        am_hal_ctimer_start(configCTIMER_NUM, AM_HAL_CTIMER_BOTH);
#endif
		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile( "cpsie i" );
    c842:	b662      	cpsie	i

	}
}
    c844:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ulReloadValue -= elapsed_time;
    c848:	4446      	add	r6, r8
    c84a:	1b34      	subs	r4, r6, r4
        am_hal_stimer_compare_delta_set(0, ulReloadValue);
    c84c:	4621      	mov	r1, r4
    c84e:	2000      	movs	r0, #0
    c850:	f004 f852 	bl	108f8 <am_hal_stimer_compare_delta_set>
        am_hal_stimer_compare_delta_set(1, ulReloadValue+1);
    c854:	2001      	movs	r0, #1
    c856:	1c61      	adds	r1, r4, #1
    c858:	f004 f84e 	bl	108f8 <am_hal_stimer_compare_delta_set>
		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );       // Turn OFF all Periphials in this function
    c85c:	4628      	mov	r0, r5
    c85e:	f7ff febf 	bl	c5e0 <am_freertos_sleep>
		if( xModifiableIdleTime > 0 )
    c862:	b120      	cbz	r0, c86e <vPortSuppressTicksAndSleep+0x72>
			__asm volatile( "dsb" );
    c864:	f3bf 8f4f 	dsb	sy
			__asm volatile( "wfi" );
    c868:	bf30      	wfi
			__asm volatile( "isb" );
    c86a:	f3bf 8f6f 	isb	sy
		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );       // Turn ON all Periphials in this function
    c86e:	4628      	mov	r0, r5
    c870:	f7ff febc 	bl	c5ec <am_freertos_wakeup>
        New_Timer = am_hal_stimer_counter_get();
    c874:	f004 f830 	bl	108d8 <am_hal_stimer_counter_get>
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
    c878:	683b      	ldr	r3, [r7, #0]
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    c87a:	f8d9 1000 	ldr.w	r1, [r9]
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
    c87e:	1ac3      	subs	r3, r0, r3
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    c880:	fbb3 f2f1 	udiv	r2, r3, r1
    c884:	fb01 3312 	mls	r3, r1, r2, r3
    c888:	1ac3      	subs	r3, r0, r3
        vTaskStepTick( Delta_Sleep );
    c88a:	4610      	mov	r0, r2
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
    c88c:	603b      	str	r3, [r7, #0]
        vTaskStepTick( Delta_Sleep );
    c88e:	f001 f94b 	bl	db28 <vTaskStepTick>
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA | AM_HAL_STIMER_INT_COMPAREB);
    c892:	2003      	movs	r0, #3
    c894:	f004 f896 	bl	109c4 <am_hal_stimer_int_clear>
        am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    c898:	f8d9 1000 	ldr.w	r1, [r9]
    c89c:	2000      	movs	r0, #0
    c89e:	f004 f82b 	bl	108f8 <am_hal_stimer_compare_delta_set>
        am_hal_stimer_compare_delta_set(1, ulTimerCountsForOneTick+1);
    c8a2:	f8d9 1000 	ldr.w	r1, [r9]
    c8a6:	2001      	movs	r0, #1
    c8a8:	4401      	add	r1, r0
    c8aa:	f004 f825 	bl	108f8 <am_hal_stimer_compare_delta_set>
		__asm volatile( "cpsie i" );
    c8ae:	b662      	cpsie	i
}
    c8b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c8b4:	1000235c 	.word	0x1000235c
    c8b8:	1000234c 	.word	0x1000234c
    c8bc:	10002358 	.word	0x10002358

0000c8c0 <xPortStimerTickHandler>:
//
//
//*****************************************************************************
void
xPortStimerTickHandler(uint32_t delta)
{
    c8c0:	b570      	push	{r4, r5, r6, lr}

    curSTimer = am_hal_stimer_counter_get();
    //
    // Configure the STIMER->COMPARE_0
    //
    am_hal_stimer_compare_delta_set(0, (ulTimerCountsForOneTick-delta));
    c8c2:	4e1c      	ldr	r6, [pc, #112]	; (c934 <xPortStimerTickHandler+0x74>)
{
    c8c4:	4604      	mov	r4, r0
    curSTimer = am_hal_stimer_counter_get();
    c8c6:	f004 f807 	bl	108d8 <am_hal_stimer_counter_get>
    am_hal_stimer_compare_delta_set(0, (ulTimerCountsForOneTick-delta));
    c8ca:	6831      	ldr	r1, [r6, #0]
    curSTimer = am_hal_stimer_counter_get();
    c8cc:	4605      	mov	r5, r0
    am_hal_stimer_compare_delta_set(0, (ulTimerCountsForOneTick-delta));
    c8ce:	1b09      	subs	r1, r1, r4
    c8d0:	2000      	movs	r0, #0
    c8d2:	f004 f811 	bl	108f8 <am_hal_stimer_compare_delta_set>
#ifdef AM_FREERTOS_STIMER_BACKUP
    am_hal_stimer_compare_delta_set(1, (ulTimerCountsForOneTick-delta+1));
    c8d6:	6831      	ldr	r1, [r6, #0]
    c8d8:	2001      	movs	r0, #1
    c8da:	4401      	add	r1, r0
    c8dc:	1b09      	subs	r1, r1, r4
    c8de:	f004 f80b 	bl	108f8 <am_hal_stimer_compare_delta_set>
#endif

    timerCounts = curSTimer - g_lastSTimerVal;
    c8e2:	4915      	ldr	r1, [pc, #84]	; (c938 <xPortStimerTickHandler+0x78>)
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
    c8e4:	6832      	ldr	r2, [r6, #0]
    timerCounts = curSTimer - g_lastSTimerVal;
    c8e6:	680b      	ldr	r3, [r1, #0]
    c8e8:	1aeb      	subs	r3, r5, r3
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
    c8ea:	fbb3 f4f2 	udiv	r4, r3, r2
    remainder = timerCounts % ulTimerCountsForOneTick;
    c8ee:	fb02 3014 	mls	r0, r2, r4, r3
    g_lastSTimerVal = curSTimer - remainder;
    c8f2:	1a2d      	subs	r5, r5, r0
    c8f4:	600d      	str	r5, [r1, #0]
	__asm volatile
    c8f6:	f3ef 8111 	mrs	r1, BASEPRI
    c8fa:	f04f 0080 	mov.w	r0, #128	; 0x80
    c8fe:	f380 8811 	msr	BASEPRI, r0
    c902:	f3bf 8f6f 	isb	sy
    c906:	f3bf 8f4f 	dsb	sy
        //
        // Increment RTOS tick
        // Allowing for need to increment the tick more than one... to avoid accumulation of
        // error in case of interrupt latencies
        //
        while (numTicksElapsed--)
    c90a:	429a      	cmp	r2, r3
    c90c:	d80e      	bhi.n	c92c <xPortStimerTickHandler+0x6c>
    BaseType_t ctxtSwitchReqd = pdFALSE;
    c90e:	2500      	movs	r5, #0
        {
            ctxtSwitchReqd = (( xTaskIncrementTick() != pdFALSE ) ? pdTRUE : ctxtSwitchReqd);
    c910:	f001 f91a 	bl	db48 <xTaskIncrementTick>
    c914:	2800      	cmp	r0, #0
    c916:	bf18      	it	ne
    c918:	2501      	movne	r5, #1
        while (numTicksElapsed--)
    c91a:	3c01      	subs	r4, #1
    c91c:	d1f8      	bne.n	c910 <xPortStimerTickHandler+0x50>
        }
        if ( ctxtSwitchReqd != pdFALSE )
    c91e:	b12d      	cbz	r5, c92c <xPortStimerTickHandler+0x6c>
            //
            // A context switch is required.  Context switching is
            // performed in the PendSV interrupt. Pend the PendSV
            // interrupt.
            //
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    c920:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    c924:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c928:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
    c92c:	2300      	movs	r3, #0
    c92e:	f383 8811 	msr	BASEPRI, r3
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(0);
}
    c932:	bd70      	pop	{r4, r5, r6, pc}
    c934:	10002358 	.word	0x10002358
    c938:	1000234c 	.word	0x1000234c

0000c93c <am_stimer_cmpr0_isr>:
// Interrupt handler for the STIMER module Compare 0.
//
//*****************************************************************************
void
am_stimer_cmpr0_isr(void)
{
    c93c:	b508      	push	{r3, lr}

    //
    // Check the timer interrupt status.
    //
    uint32_t ui32Status = am_hal_stimer_int_status_get(false);
    c93e:	2000      	movs	r0, #0
    c940:	f004 f846 	bl	109d0 <am_hal_stimer_int_status_get>
    if (ui32Status & AM_HAL_STIMER_INT_COMPAREA)
    c944:	07c3      	lsls	r3, r0, #31
    c946:	d400      	bmi.n	c94a <am_stimer_cmpr0_isr+0xe>
        //
        // Run handlers for the various possible timer events.
        //
        xPortStimerTickHandler(0);
    }
}
    c948:	bd08      	pop	{r3, pc}
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
    c94a:	2001      	movs	r0, #1
    c94c:	f004 f83a 	bl	109c4 <am_hal_stimer_int_clear>
}
    c950:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        xPortStimerTickHandler(0);
    c954:	2000      	movs	r0, #0
    c956:	f7ff bfb3 	b.w	c8c0 <xPortStimerTickHandler>
    c95a:	bf00      	nop

0000c95c <am_stimer_cmpr1_isr>:
// Interrupt handler for the STIMER module Compare 0.
//
//*****************************************************************************
void
am_stimer_cmpr1_isr(void)
{
    c95c:	b508      	push	{r3, lr}

    //
    // Check the timer interrupt status.
    //
    uint32_t ui32Status = am_hal_stimer_int_status_get(false);
    c95e:	2000      	movs	r0, #0
    c960:	f004 f836 	bl	109d0 <am_hal_stimer_int_status_get>
    if (ui32Status & AM_HAL_STIMER_INT_COMPAREB)
    c964:	0783      	lsls	r3, r0, #30
    c966:	d400      	bmi.n	c96a <am_stimer_cmpr1_isr+0xe>
        //
        // Run handlers for the various possible timer events.
        //
        xPortStimerTickHandler(1);
    }
}
    c968:	bd08      	pop	{r3, pc}
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREB);
    c96a:	2002      	movs	r0, #2
    c96c:	f004 f82a 	bl	109c4 <am_hal_stimer_int_clear>
        gNumCmpB++;
    c970:	4a04      	ldr	r2, [pc, #16]	; (c984 <am_stimer_cmpr1_isr+0x28>)
    c972:	6813      	ldr	r3, [r2, #0]
        xPortStimerTickHandler(1);
    c974:	2001      	movs	r0, #1
        gNumCmpB++;
    c976:	4403      	add	r3, r0
    c978:	6013      	str	r3, [r2, #0]
}
    c97a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        xPortStimerTickHandler(1);
    c97e:	f7ff bf9f 	b.w	c8c0 <xPortStimerTickHandler>
    c982:	bf00      	nop
    c984:	10002348 	.word	0x10002348

0000c988 <vPortSetupTimerInterrupt>:

#endif // AM_FREERTOS_USE_STIMER_FOR_TICK


void vPortSetupTimerInterrupt( void )
{
    c988:	b538      	push	{r3, r4, r5, lr}
    /* Calculate the constants required to configure the tick interrupt. */
    #if configUSE_TICKLESS_IDLE == 2
    {
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
#ifdef AM_FREERTOS_STIMER_BACKUP
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick - 1;
    c98a:	4b18      	ldr	r3, [pc, #96]	; (c9ec <vPortSetupTimerInterrupt+0x64>)
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    c98c:	4d18      	ldr	r5, [pc, #96]	; (c9f0 <vPortSetupTimerInterrupt+0x68>)
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick - 1;
    c98e:	4a19      	ldr	r2, [pc, #100]	; (c9f4 <vPortSetupTimerInterrupt+0x6c>)
    c990:	601a      	str	r2, [r3, #0]
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    c992:	2120      	movs	r1, #32
    #endif /* configUSE_TICKLESS_IDLE */
    //
    //
    //
#ifdef AM_FREERTOS_STIMER_BACKUP
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA | AM_HAL_STIMER_INT_COMPAREB);
    c994:	2003      	movs	r0, #3
        ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    c996:	6029      	str	r1, [r5, #0]
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA | AM_HAL_STIMER_INT_COMPAREB);
    c998:	f004 f80a 	bl	109b0 <am_hal_stimer_int_enable>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    c99c:	4b16      	ldr	r3, [pc, #88]	; (c9f8 <vPortSetupTimerInterrupt+0x70>)
    c99e:	22e0      	movs	r2, #224	; 0xe0
    c9a0:	f883 2317 	strb.w	r2, [r3, #791]	; 0x317
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c9a4:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
    c9a8:	6019      	str	r1, [r3, #0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    c9aa:	f883 2318 	strb.w	r2, [r3, #792]	; 0x318
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c9ae:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    c9b2:	601a      	str	r2, [r3, #0]
#endif // AM_CMSIS_REGS
#endif
    //
    // Configure the STIMER
    //
    oldCfg = am_hal_stimer_config(AM_HAL_STIMER_CFG_FREEZE);
    c9b4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    c9b8:	f003 ff84 	bl	108c4 <am_hal_stimer_config>
    c9bc:	4604      	mov	r4, r0
    g_lastSTimerVal = am_hal_stimer_counter_get();
    c9be:	f003 ff8b 	bl	108d8 <am_hal_stimer_counter_get>
    c9c2:	4b0e      	ldr	r3, [pc, #56]	; (c9fc <vPortSetupTimerInterrupt+0x74>)
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    c9c4:	6829      	ldr	r1, [r5, #0]
    g_lastSTimerVal = am_hal_stimer_counter_get();
    c9c6:	6018      	str	r0, [r3, #0]
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
    c9c8:	2000      	movs	r0, #0
    c9ca:	f003 ff95 	bl	108f8 <am_hal_stimer_compare_delta_set>
#ifdef AM_FREERTOS_STIMER_BACKUP
    am_hal_stimer_compare_delta_set(1, ulTimerCountsForOneTick+1);
    c9ce:	6829      	ldr	r1, [r5, #0]
    c9d0:	2001      	movs	r0, #1
    c9d2:	4401      	add	r1, r0
    c9d4:	f003 ff90 	bl	108f8 <am_hal_stimer_compare_delta_set>
#if AM_CMSIS_REGS
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE | CTIMER_STCFG_CLKSEL_Msk)) | configSTIMER_CLOCK | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE | AM_HAL_STIMER_CFG_COMPARE_B_ENABLE);
    c9d8:	4809      	ldr	r0, [pc, #36]	; (ca00 <vPortSetupTimerInterrupt+0x78>)
    c9da:	4020      	ands	r0, r4
    c9dc:	f440 7040 	orr.w	r0, r0, #768	; 0x300
    //
    am_hal_ctimer_start(configCTIMER_NUM, AM_HAL_CTIMER_BOTH);


#endif // AM_FREERTOS_USE_STIMER_FOR_TICK
}
    c9e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE | CTIMER_STCFG_CLKSEL_Msk)) | configSTIMER_CLOCK | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE | AM_HAL_STIMER_CFG_COMPARE_B_ENABLE);
    c9e4:	f040 0003 	orr.w	r0, r0, #3
    c9e8:	f003 bf6c 	b.w	108c4 <am_hal_stimer_config>
    c9ec:	1000235c 	.word	0x1000235c
    c9f0:	10002358 	.word	0x10002358
    c9f4:	07fffffe 	.word	0x07fffffe
    c9f8:	e000e100 	.word	0xe000e100
    c9fc:	1000234c 	.word	0x1000234c
    ca00:	7ffffcf0 	.word	0x7ffffcf0

0000ca04 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
    ca04:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    ca08:	4a36      	ldr	r2, [pc, #216]	; (cae4 <xPortStartScheduler+0xe0>)
    ca0a:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	; 0xd00
    ca0e:	4291      	cmp	r1, r2
    ca10:	d02b      	beq.n	ca6a <xPortStartScheduler+0x66>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
    ca12:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
    ca16:	4b34      	ldr	r3, [pc, #208]	; (cae8 <xPortStartScheduler+0xe4>)
    ca18:	429a      	cmp	r2, r3
    ca1a:	d027      	beq.n	ca6c <xPortStartScheduler+0x68>
{
    ca1c:	b570      	push	{r4, r5, r6, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    ca1e:	4b33      	ldr	r3, [pc, #204]	; (caec <xPortStartScheduler+0xe8>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    ca20:	4933      	ldr	r1, [pc, #204]	; (caf0 <xPortStartScheduler+0xec>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    ca22:	781a      	ldrb	r2, [r3, #0]
{
    ca24:	b084      	sub	sp, #16
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    ca26:	b2d2      	uxtb	r2, r2
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    ca28:	20ff      	movs	r0, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    ca2a:	9202      	str	r2, [sp, #8]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    ca2c:	7018      	strb	r0, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    ca2e:	781b      	ldrb	r3, [r3, #0]
    ca30:	b2db      	uxtb	r3, r3
    ca32:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    ca36:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    ca3a:	f89d 2007 	ldrb.w	r2, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    ca3e:	f003 0380 	and.w	r3, r3, #128	; 0x80
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    ca42:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    ca44:	700b      	strb	r3, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    ca46:	d50f      	bpl.n	ca68 <xPortStartScheduler+0x64>
    ca48:	2206      	movs	r2, #6
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
    ca4a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca4e:	005b      	lsls	r3, r3, #1
    ca50:	b2db      	uxtb	r3, r3
    ca52:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    ca56:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca5a:	061b      	lsls	r3, r3, #24
    ca5c:	4611      	mov	r1, r2
    ca5e:	f102 32ff 	add.w	r2, r2, #4294967295
    ca62:	d4f2      	bmi.n	ca4a <xPortStartScheduler+0x46>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
    ca64:	2904      	cmp	r1, #4
    ca66:	d002      	beq.n	ca6e <xPortStartScheduler+0x6a>
    ca68:	e7fe      	b.n	ca68 <xPortStartScheduler+0x64>
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
    ca6a:	e7fe      	b.n	ca6a <xPortStartScheduler+0x66>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
    ca6c:	e7fe      	b.n	ca6c <xPortStartScheduler+0x68>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    ca6e:	9b02      	ldr	r3, [sp, #8]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    ca70:	4920      	ldr	r1, [pc, #128]	; (caf4 <xPortStartScheduler+0xf0>)
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    ca72:	4a1e      	ldr	r2, [pc, #120]	; (caec <xPortStartScheduler+0xe8>)
	uxCriticalNesting = 0;
    ca74:	4d20      	ldr	r5, [pc, #128]	; (caf8 <xPortStartScheduler+0xf4>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    ca76:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    ca7a:	f44f 6080 	mov.w	r0, #1024	; 0x400
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    ca7e:	b2db      	uxtb	r3, r3
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    ca80:	6008      	str	r0, [r1, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    ca82:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    ca84:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    ca88:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
    ca8c:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    ca90:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
    ca94:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
    ca98:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	uxCriticalNesting = 0;
    ca9c:	2600      	movs	r6, #0
	vPortSetupTimerInterrupt();
    ca9e:	f7ff ff73 	bl	c988 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
    caa2:	602e      	str	r6, [r5, #0]
	vPortEnableVFP();
    caa4:	f7ff fdec 	bl	c680 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
    caa8:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
    caac:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    cab0:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
    cab4:	f7ff fdd0 	bl	c658 <prvPortStartFirstTask>
	vTaskSwitchContext();
    cab8:	f001 f9de 	bl	de78 <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
    cabc:	682b      	ldr	r3, [r5, #0]
volatile uint32_t ulDummy = 0;
    cabe:	9603      	str	r6, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
    cac0:	3301      	adds	r3, #1
    cac2:	d000      	beq.n	cac6 <xPortStartScheduler+0xc2>
    cac4:	e7fe      	b.n	cac4 <xPortStartScheduler+0xc0>
	__asm volatile
    cac6:	f04f 0380 	mov.w	r3, #128	; 0x80
    caca:	f383 8811 	msr	BASEPRI, r3
    cace:	f3bf 8f6f 	isb	sy
    cad2:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
    cad6:	9b03      	ldr	r3, [sp, #12]
    cad8:	2b00      	cmp	r3, #0
    cada:	d0fc      	beq.n	cad6 <xPortStartScheduler+0xd2>
}
    cadc:	2000      	movs	r0, #0
    cade:	b004      	add	sp, #16
    cae0:	bd70      	pop	{r4, r5, r6, pc}
    cae2:	bf00      	nop
    cae4:	410fc271 	.word	0x410fc271
    cae8:	410fc270 	.word	0x410fc270
    caec:	e000e400 	.word	0xe000e400
    caf0:	10002350 	.word	0x10002350
    caf4:	10002354 	.word	0x10002354
    caf8:	10002300 	.word	0x10002300

0000cafc <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    cafc:	b510      	push	{r4, lr}
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    cafe:	2018      	movs	r0, #24
    cb00:	f002 fd20 	bl	f544 <pvPortMalloc>

		if( pxEventBits != NULL )
    cb04:	4604      	mov	r4, r0
    cb06:	b120      	cbz	r0, cb12 <xEventGroupCreate+0x16>
		{
			pxEventBits->uxEventBits = 0;
    cb08:	2300      	movs	r3, #0
    cb0a:	f840 3b04 	str.w	r3, [r0], #4
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    cb0e:	f000 f8a1 	bl	cc54 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
	}
    cb12:	4620      	mov	r0, r4
    cb14:	bd10      	pop	{r4, pc}
    cb16:	bf00      	nop

0000cb18 <xEventGroupWaitBits>:
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
    cb18:	b130      	cbz	r0, cb28 <xEventGroupWaitBits+0x10>
{
    cb1a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    cb1e:	f011 487f 	ands.w	r8, r1, #4278190080	; 0xff000000
    cb22:	460c      	mov	r4, r1
    cb24:	d001      	beq.n	cb2a <xEventGroupWaitBits+0x12>
    cb26:	e7fe      	b.n	cb26 <xEventGroupWaitBits+0xe>
	configASSERT( xEventGroup );
    cb28:	e7fe      	b.n	cb28 <xEventGroupWaitBits+0x10>
	configASSERT( uxBitsToWaitFor != 0 );
    cb2a:	b901      	cbnz	r1, cb2e <xEventGroupWaitBits+0x16>
    cb2c:	e7fe      	b.n	cb2c <xEventGroupWaitBits+0x14>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    cb2e:	4617      	mov	r7, r2
    cb30:	461e      	mov	r6, r3
    cb32:	4605      	mov	r5, r0
    cb34:	f001 fb60 	bl	e1f8 <xTaskGetSchedulerState>
    cb38:	b908      	cbnz	r0, cb3e <xEventGroupWaitBits+0x26>
    cb3a:	9b08      	ldr	r3, [sp, #32]
    cb3c:	bb8b      	cbnz	r3, cba2 <xEventGroupWaitBits+0x8a>
	}
	#endif

	vTaskSuspendAll();
    cb3e:	f000 ffe5 	bl	db0c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    cb42:	f8d5 9000 	ldr.w	r9, [r5]

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
    cb46:	b36e      	cbz	r6, cba4 <xEventGroupWaitBits+0x8c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    cb48:	ea34 0309 	bics.w	r3, r4, r9
    cb4c:	d02d      	beq.n	cbaa <xEventGroupWaitBits+0x92>
		else if( xTicksToWait == ( TickType_t ) 0 )
    cb4e:	9b08      	ldr	r3, [sp, #32]
    cb50:	b393      	cbz	r3, cbb8 <xEventGroupWaitBits+0xa0>
			if( xClearOnExit != pdFALSE )
    cb52:	2f00      	cmp	r7, #0
    cb54:	bf16      	itet	ne
    cb56:	f04f 7880 	movne.w	r8, #16777216	; 0x1000000
    cb5a:	f04f 6180 	moveq.w	r1, #67108864	; 0x4000000
    cb5e:	f04f 61a0 	movne.w	r1, #83886080	; 0x5000000
			if( xWaitForAllBits != pdFALSE )
    cb62:	2e00      	cmp	r6, #0
    cb64:	bf08      	it	eq
    cb66:	4641      	moveq	r1, r8
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    cb68:	4321      	orrs	r1, r4
    cb6a:	461a      	mov	r2, r3
    cb6c:	1d28      	adds	r0, r5, #4
    cb6e:	f001 f9cd 	bl	df0c <vTaskPlaceOnUnorderedEventList>
	xAlreadyYielded = xTaskResumeAll();
    cb72:	f001 f913 	bl	dd9c <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
    cb76:	b948      	cbnz	r0, cb8c <xEventGroupWaitBits+0x74>
			portYIELD_WITHIN_API();
    cb78:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    cb7c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cb80:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    cb84:	f3bf 8f4f 	dsb	sy
    cb88:	f3bf 8f6f 	isb	sy
		uxReturn = uxTaskResetEventItemValue();
    cb8c:	f001 fb44 	bl	e218 <uxTaskResetEventItemValue>
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    cb90:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
		uxReturn = uxTaskResetEventItemValue();
    cb94:	4681      	mov	r9, r0
		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    cb96:	d012      	beq.n	cbbe <xEventGroupWaitBits+0xa6>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    cb98:	f029 497f 	bic.w	r9, r9, #4278190080	; 0xff000000
}
    cb9c:	4648      	mov	r0, r9
    cb9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    cba2:	e7fe      	b.n	cba2 <xEventGroupWaitBits+0x8a>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    cba4:	ea14 0f09 	tst.w	r4, r9
    cba8:	d0d1      	beq.n	cb4e <xEventGroupWaitBits+0x36>
			if( xClearOnExit != pdFALSE )
    cbaa:	b12f      	cbz	r7, cbb8 <xEventGroupWaitBits+0xa0>
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    cbac:	ea29 0404 	bic.w	r4, r9, r4
    cbb0:	602c      	str	r4, [r5, #0]
	xAlreadyYielded = xTaskResumeAll();
    cbb2:	f001 f8f3 	bl	dd9c <xTaskResumeAll>
	if( xTicksToWait != ( TickType_t ) 0 )
    cbb6:	e7f1      	b.n	cb9c <xEventGroupWaitBits+0x84>
	xAlreadyYielded = xTaskResumeAll();
    cbb8:	f001 f8f0 	bl	dd9c <xTaskResumeAll>
	if( xTicksToWait != ( TickType_t ) 0 )
    cbbc:	e7ee      	b.n	cb9c <xEventGroupWaitBits+0x84>
			taskENTER_CRITICAL();
    cbbe:	f7ff fd91 	bl	c6e4 <vPortEnterCritical>
				uxReturn = pxEventBits->uxEventBits;
    cbc2:	f8d5 9000 	ldr.w	r9, [r5]
	if( xWaitForAllBits == pdFALSE )
    cbc6:	b94e      	cbnz	r6, cbdc <xEventGroupWaitBits+0xc4>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    cbc8:	ea14 0f09 	tst.w	r4, r9
    cbcc:	d003      	beq.n	cbd6 <xEventGroupWaitBits+0xbe>
					if( xClearOnExit != pdFALSE )
    cbce:	b117      	cbz	r7, cbd6 <xEventGroupWaitBits+0xbe>
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    cbd0:	ea29 0404 	bic.w	r4, r9, r4
    cbd4:	602c      	str	r4, [r5, #0]
			taskEXIT_CRITICAL();
    cbd6:	f7ff fd9f 	bl	c718 <vPortExitCritical>
    cbda:	e7dd      	b.n	cb98 <xEventGroupWaitBits+0x80>
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    cbdc:	ea34 0309 	bics.w	r3, r4, r9
    cbe0:	d1f9      	bne.n	cbd6 <xEventGroupWaitBits+0xbe>
    cbe2:	e7f4      	b.n	cbce <xEventGroupWaitBits+0xb6>

0000cbe4 <vEventGroupSetBitsCallback>:
	configASSERT( xEventGroup );
    cbe4:	b130      	cbz	r0, cbf4 <vEventGroupSetBitsCallback+0x10>
{
    cbe6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    cbea:	f011 467f 	ands.w	r6, r1, #4278190080	; 0xff000000
    cbee:	4688      	mov	r8, r1
    cbf0:	d001      	beq.n	cbf6 <vEventGroupSetBitsCallback+0x12>
    cbf2:	e7fe      	b.n	cbf2 <vEventGroupSetBitsCallback+0xe>
	configASSERT( xEventGroup );
    cbf4:	e7fe      	b.n	cbf4 <vEventGroupSetBitsCallback+0x10>
    cbf6:	4605      	mov	r5, r0
	vTaskSuspendAll();
    cbf8:	f000 ff88 	bl	db0c <vTaskSuspendAll>
		pxEventBits->uxEventBits |= uxBitsToSet;
    cbfc:	682b      	ldr	r3, [r5, #0]
		pxListItem = listGET_HEAD_ENTRY( pxList );
    cbfe:	692c      	ldr	r4, [r5, #16]
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    cc00:	f105 070c 	add.w	r7, r5, #12
		pxEventBits->uxEventBits |= uxBitsToSet;
    cc04:	ea48 0303 	orr.w	r3, r8, r3
		while( pxListItem != pxListEnd )
    cc08:	42a7      	cmp	r7, r4
		pxEventBits->uxEventBits |= uxBitsToSet;
    cc0a:	602b      	str	r3, [r5, #0]
		while( pxListItem != pxListEnd )
    cc0c:	d10c      	bne.n	cc28 <vEventGroupSetBitsCallback+0x44>
    cc0e:	e01c      	b.n	cc4a <vEventGroupSetBitsCallback+0x66>
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    cc10:	ea1c 0f03 	tst.w	ip, r3
    cc14:	d006      	beq.n	cc24 <vEventGroupSetBitsCallback+0x40>
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    cc16:	01d3      	lsls	r3, r2, #7
					uxBitsToClear |= uxBitsWaitedFor;
    cc18:	bf48      	it	mi
    cc1a:	ea46 060c 	orrmi.w	r6, r6, ip
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    cc1e:	f001 fa51 	bl	e0c4 <vTaskRemoveFromUnorderedEventList>
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    cc22:	682b      	ldr	r3, [r5, #0]
		while( pxListItem != pxListEnd )
    cc24:	42a7      	cmp	r7, r4
    cc26:	d00e      	beq.n	cc46 <vEventGroupSetBitsCallback+0x62>
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    cc28:	4620      	mov	r0, r4
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    cc2a:	f043 7100 	orr.w	r1, r3, #33554432	; 0x2000000
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    cc2e:	6802      	ldr	r2, [r0, #0]
			pxNext = listGET_NEXT( pxListItem );
    cc30:	6864      	ldr	r4, [r4, #4]
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    cc32:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    cc36:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    cc3a:	d0e9      	beq.n	cc10 <vEventGroupSetBitsCallback+0x2c>
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    cc3c:	ea3c 0e03 	bics.w	lr, ip, r3
    cc40:	d0e9      	beq.n	cc16 <vEventGroupSetBitsCallback+0x32>
		while( pxListItem != pxListEnd )
    cc42:	42a7      	cmp	r7, r4
    cc44:	d1f0      	bne.n	cc28 <vEventGroupSetBitsCallback+0x44>
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    cc46:	ea23 0306 	bic.w	r3, r3, r6
    cc4a:	602b      	str	r3, [r5, #0]
}
    cc4c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	( void ) xTaskResumeAll();
    cc50:	f001 b8a4 	b.w	dd9c <xTaskResumeAll>

0000cc54 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    cc54:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    cc58:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    cc5c:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    cc5e:	e9c0 3101 	strd	r3, r1, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    cc62:	e9c0 3303 	strd	r3, r3, [r0, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    cc66:	6002      	str	r2, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    cc68:	4770      	bx	lr
    cc6a:	bf00      	nop

0000cc6c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    cc6c:	2300      	movs	r3, #0
    cc6e:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    cc70:	4770      	bx	lr
    cc72:	bf00      	nop

0000cc74 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
    cc74:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    cc76:	689a      	ldr	r2, [r3, #8]
    cc78:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
    cc7a:	6802      	ldr	r2, [r0, #0]
{
    cc7c:	b410      	push	{r4}
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    cc7e:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
    cc80:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
    cc82:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    cc84:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
    cc86:	6099      	str	r1, [r3, #8]
}
    cc88:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
    cc8c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    cc8e:	6002      	str	r2, [r0, #0]
}
    cc90:	4770      	bx	lr
    cc92:	bf00      	nop

0000cc94 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    cc94:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    cc96:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    cc98:	1c6b      	adds	r3, r5, #1
    cc9a:	d010      	beq.n	ccbe <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    cc9c:	f100 0308 	add.w	r3, r0, #8
    cca0:	461c      	mov	r4, r3
    cca2:	685b      	ldr	r3, [r3, #4]
    cca4:	681a      	ldr	r2, [r3, #0]
    cca6:	42aa      	cmp	r2, r5
    cca8:	d9fa      	bls.n	cca0 <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
    ccaa:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
    ccac:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
    ccae:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    ccb0:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    ccb2:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
    ccb4:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
    ccb6:	6108      	str	r0, [r1, #16]
}
    ccb8:	bc30      	pop	{r4, r5}
	( pxList->uxNumberOfItems )++;
    ccba:	6002      	str	r2, [r0, #0]
}
    ccbc:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
    ccbe:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
    ccc0:	6863      	ldr	r3, [r4, #4]
    ccc2:	e7f2      	b.n	ccaa <vListInsert+0x16>

0000ccc4 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    ccc4:	6903      	ldr	r3, [r0, #16]
{
    ccc6:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    ccc8:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    cccc:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    ccce:	608a      	str	r2, [r1, #8]
	if( pxList->pxIndex == pxItemToRemove )
    ccd0:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    ccd2:	6051      	str	r1, [r2, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    ccd4:	bf08      	it	eq
    ccd6:	605a      	streq	r2, [r3, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
    ccd8:	681a      	ldr	r2, [r3, #0]

	return pxList->uxNumberOfItems;
}
    ccda:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxContainer = NULL;
    ccde:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
    cce0:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
    cce2:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
    cce4:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
    cce6:	6818      	ldr	r0, [r3, #0]
}
    cce8:	4770      	bx	lr
    ccea:	bf00      	nop

0000ccec <xQueueGenericCreate>:
	{
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    ccec:	b358      	cbz	r0, cd46 <xQueueGenericCreate+0x5a>
	{
    ccee:	b570      	push	{r4, r5, r6, lr}
    ccf0:	460e      	mov	r6, r1
    ccf2:	4605      	mov	r5, r0

		if( uxItemSize == ( UBaseType_t ) 0 )
    ccf4:	bb41      	cbnz	r1, cd48 <xQueueGenericCreate+0x5c>
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    ccf6:	2048      	movs	r0, #72	; 0x48
    ccf8:	f002 fc24 	bl	f544 <pvPortMalloc>

		if( pxNewQueue != NULL )
    ccfc:	4604      	mov	r4, r0
    ccfe:	b370      	cbz	r0, cd5e <xQueueGenericCreate+0x72>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    cd00:	6024      	str	r4, [r4, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
    cd02:	e9c4 560f 	strd	r5, r6, [r4, #60]	; 0x3c
	taskENTER_CRITICAL();
    cd06:	f7ff fced 	bl	c6e4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd0a:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
    cd0e:	6821      	ldr	r1, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
    cd10:	6061      	str	r1, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd12:	fb03 f202 	mul.w	r2, r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd16:	1ad3      	subs	r3, r2, r3
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd18:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd1a:	440b      	add	r3, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd1c:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    cd1e:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
    cd20:	22ff      	movs	r2, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    cd22:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd24:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
    cd26:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    cd2a:	f104 0010 	add.w	r0, r4, #16
		pxQueue->cTxLock = queueUNLOCKED;
    cd2e:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    cd32:	f7ff ff8f 	bl	cc54 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    cd36:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cd3a:	f7ff ff8b 	bl	cc54 <vListInitialise>
	taskEXIT_CRITICAL();
    cd3e:	f7ff fceb 	bl	c718 <vPortExitCritical>
	}
    cd42:	4620      	mov	r0, r4
    cd44:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    cd46:	e7fe      	b.n	cd46 <xQueueGenericCreate+0x5a>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    cd48:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    cd4c:	3048      	adds	r0, #72	; 0x48
    cd4e:	f002 fbf9 	bl	f544 <pvPortMalloc>
		if( pxNewQueue != NULL )
    cd52:	4604      	mov	r4, r0
    cd54:	b118      	cbz	r0, cd5e <xQueueGenericCreate+0x72>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    cd56:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    cd5a:	6003      	str	r3, [r0, #0]
    cd5c:	e7d1      	b.n	cd02 <xQueueGenericCreate+0x16>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    cd5e:	2400      	movs	r4, #0
	}
    cd60:	4620      	mov	r0, r4
    cd62:	bd70      	pop	{r4, r5, r6, pc}

0000cd64 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    cd64:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    cd68:	b085      	sub	sp, #20
    cd6a:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    cd6c:	b158      	cbz	r0, cd86 <xQueueGenericSend+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    cd6e:	4688      	mov	r8, r1
    cd70:	461f      	mov	r7, r3
    cd72:	4604      	mov	r4, r0
    cd74:	2900      	cmp	r1, #0
    cd76:	f000 808d 	beq.w	ce94 <xQueueGenericSend+0x130>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    cd7a:	2f02      	cmp	r7, #2
    cd7c:	d104      	bne.n	cd88 <xQueueGenericSend+0x24>
    cd7e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cd80:	2b01      	cmp	r3, #1
    cd82:	d001      	beq.n	cd88 <xQueueGenericSend+0x24>
    cd84:	e7fe      	b.n	cd84 <xQueueGenericSend+0x20>
	configASSERT( pxQueue );
    cd86:	e7fe      	b.n	cd86 <xQueueGenericSend+0x22>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    cd88:	f001 fa36 	bl	e1f8 <xTaskGetSchedulerState>
    cd8c:	4605      	mov	r5, r0
    cd8e:	2800      	cmp	r0, #0
    cd90:	f040 8086 	bne.w	cea0 <xQueueGenericSend+0x13c>
    cd94:	9b01      	ldr	r3, [sp, #4]
    cd96:	2b00      	cmp	r3, #0
    cd98:	f040 8081 	bne.w	ce9e <xQueueGenericSend+0x13a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cd9c:	f104 0624 	add.w	r6, r4, #36	; 0x24
		taskENTER_CRITICAL();
    cda0:	f7ff fca0 	bl	c6e4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    cda4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    cda6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cda8:	429a      	cmp	r2, r3
    cdaa:	f0c0 80ec 	bcc.w	cf86 <xQueueGenericSend+0x222>
    cdae:	2f02      	cmp	r7, #2
    cdb0:	f000 80d1 	beq.w	cf56 <xQueueGenericSend+0x1f2>
				if( xTicksToWait == ( TickType_t ) 0 )
    cdb4:	9801      	ldr	r0, [sp, #4]
    cdb6:	2800      	cmp	r0, #0
    cdb8:	f000 80f4 	beq.w	cfa4 <xQueueGenericSend+0x240>
				else if( xEntryTimeSet == pdFALSE )
    cdbc:	2d00      	cmp	r5, #0
    cdbe:	f000 80c6 	beq.w	cf4e <xQueueGenericSend+0x1ea>
		taskEXIT_CRITICAL();
    cdc2:	f7ff fca9 	bl	c718 <vPortExitCritical>
		vTaskSuspendAll();
    cdc6:	f000 fea1 	bl	db0c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    cdca:	f7ff fc8b 	bl	c6e4 <vPortEnterCritical>
    cdce:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    cdd2:	2bff      	cmp	r3, #255	; 0xff
    cdd4:	bf04      	itt	eq
    cdd6:	2300      	moveq	r3, #0
    cdd8:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    cddc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    cde0:	2bff      	cmp	r3, #255	; 0xff
    cde2:	bf04      	itt	eq
    cde4:	2300      	moveq	r3, #0
    cde6:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    cdea:	f7ff fc95 	bl	c718 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    cdee:	a901      	add	r1, sp, #4
    cdf0:	a802      	add	r0, sp, #8
    cdf2:	f001 f9a7 	bl	e144 <xTaskCheckForTimeOut>
    cdf6:	2800      	cmp	r0, #0
    cdf8:	f040 80d9 	bne.w	cfae <xQueueGenericSend+0x24a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    cdfc:	f7ff fc72 	bl	c6e4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    ce00:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    ce02:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    ce04:	429a      	cmp	r2, r3
    ce06:	d04d      	beq.n	cea4 <xQueueGenericSend+0x140>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    ce08:	f7ff fc86 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    ce0c:	f7ff fc6a 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    ce10:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
    ce14:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ce16:	2d00      	cmp	r5, #0
    ce18:	dc04      	bgt.n	ce24 <xQueueGenericSend+0xc0>
    ce1a:	e011      	b.n	ce40 <xQueueGenericSend+0xdc>
			--cTxLock;
    ce1c:	1e6a      	subs	r2, r5, #1
    ce1e:	b2d3      	uxtb	r3, r2
    ce20:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ce22:	b16b      	cbz	r3, ce40 <xQueueGenericSend+0xdc>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    ce24:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ce26:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    ce28:	b153      	cbz	r3, ce40 <xQueueGenericSend+0xdc>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ce2a:	f001 f8f7 	bl	e01c <xTaskRemoveFromEventList>
    ce2e:	2800      	cmp	r0, #0
    ce30:	d0f4      	beq.n	ce1c <xQueueGenericSend+0xb8>
						vTaskMissedYield();
    ce32:	f001 f9bf 	bl	e1b4 <vTaskMissedYield>
			--cTxLock;
    ce36:	1e6a      	subs	r2, r5, #1
    ce38:	b2d3      	uxtb	r3, r2
    ce3a:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ce3c:	2b00      	cmp	r3, #0
    ce3e:	d1f1      	bne.n	ce24 <xQueueGenericSend+0xc0>
		pxQueue->cTxLock = queueUNLOCKED;
    ce40:	23ff      	movs	r3, #255	; 0xff
    ce42:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    ce46:	f7ff fc67 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    ce4a:	f7ff fc4b 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    ce4e:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
    ce52:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ce54:	2d00      	cmp	r5, #0
    ce56:	dd14      	ble.n	ce82 <xQueueGenericSend+0x11e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    ce58:	f104 0910 	add.w	r9, r4, #16
    ce5c:	e003      	b.n	ce66 <xQueueGenericSend+0x102>
				--cRxLock;
    ce5e:	1e6a      	subs	r2, r5, #1
    ce60:	b2d3      	uxtb	r3, r2
    ce62:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ce64:	b16b      	cbz	r3, ce82 <xQueueGenericSend+0x11e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    ce66:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    ce68:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    ce6a:	b153      	cbz	r3, ce82 <xQueueGenericSend+0x11e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    ce6c:	f001 f8d6 	bl	e01c <xTaskRemoveFromEventList>
    ce70:	2800      	cmp	r0, #0
    ce72:	d0f4      	beq.n	ce5e <xQueueGenericSend+0xfa>
					vTaskMissedYield();
    ce74:	f001 f99e 	bl	e1b4 <vTaskMissedYield>
				--cRxLock;
    ce78:	1e6a      	subs	r2, r5, #1
    ce7a:	b2d3      	uxtb	r3, r2
    ce7c:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
    ce7e:	2b00      	cmp	r3, #0
    ce80:	d1f1      	bne.n	ce66 <xQueueGenericSend+0x102>
		pxQueue->cRxLock = queueUNLOCKED;
    ce82:	23ff      	movs	r3, #255	; 0xff
    ce84:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    ce88:	f7ff fc46 	bl	c718 <vPortExitCritical>
				( void ) xTaskResumeAll();
    ce8c:	f000 ff86 	bl	dd9c <xTaskResumeAll>
    ce90:	2501      	movs	r5, #1
    ce92:	e785      	b.n	cda0 <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    ce94:	6c03      	ldr	r3, [r0, #64]	; 0x40
    ce96:	2b00      	cmp	r3, #0
    ce98:	f43f af6f 	beq.w	cd7a <xQueueGenericSend+0x16>
    ce9c:	e7fe      	b.n	ce9c <xQueueGenericSend+0x138>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    ce9e:	e7fe      	b.n	ce9e <xQueueGenericSend+0x13a>
    cea0:	2500      	movs	r5, #0
    cea2:	e77b      	b.n	cd9c <xQueueGenericSend+0x38>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    cea4:	f104 0910 	add.w	r9, r4, #16
	taskEXIT_CRITICAL();
    cea8:	f7ff fc36 	bl	c718 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    ceac:	9901      	ldr	r1, [sp, #4]
    ceae:	4648      	mov	r0, r9
    ceb0:	f000 fff0 	bl	de94 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
    ceb4:	f7ff fc16 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    ceb8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    cebc:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cebe:	2d00      	cmp	r5, #0
    cec0:	dc04      	bgt.n	cecc <xQueueGenericSend+0x168>
    cec2:	e011      	b.n	cee8 <xQueueGenericSend+0x184>
			--cTxLock;
    cec4:	1e6b      	subs	r3, r5, #1
    cec6:	b2da      	uxtb	r2, r3
    cec8:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    ceca:	b16a      	cbz	r2, cee8 <xQueueGenericSend+0x184>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cecc:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cece:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    ced0:	b153      	cbz	r3, cee8 <xQueueGenericSend+0x184>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ced2:	f001 f8a3 	bl	e01c <xTaskRemoveFromEventList>
    ced6:	2800      	cmp	r0, #0
    ced8:	d0f4      	beq.n	cec4 <xQueueGenericSend+0x160>
						vTaskMissedYield();
    ceda:	f001 f96b 	bl	e1b4 <vTaskMissedYield>
			--cTxLock;
    cede:	1e6b      	subs	r3, r5, #1
    cee0:	b2da      	uxtb	r2, r3
    cee2:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cee4:	2a00      	cmp	r2, #0
    cee6:	d1f1      	bne.n	cecc <xQueueGenericSend+0x168>
		pxQueue->cTxLock = queueUNLOCKED;
    cee8:	23ff      	movs	r3, #255	; 0xff
    ceea:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    ceee:	f7ff fc13 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    cef2:	f7ff fbf7 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    cef6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    cefa:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cefc:	2d00      	cmp	r5, #0
    cefe:	dc04      	bgt.n	cf0a <xQueueGenericSend+0x1a6>
    cf00:	e011      	b.n	cf26 <xQueueGenericSend+0x1c2>
				--cRxLock;
    cf02:	1e6b      	subs	r3, r5, #1
    cf04:	b2da      	uxtb	r2, r3
    cf06:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cf08:	b16a      	cbz	r2, cf26 <xQueueGenericSend+0x1c2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cf0a:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cf0c:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    cf0e:	b153      	cbz	r3, cf26 <xQueueGenericSend+0x1c2>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cf10:	f001 f884 	bl	e01c <xTaskRemoveFromEventList>
    cf14:	2800      	cmp	r0, #0
    cf16:	d0f4      	beq.n	cf02 <xQueueGenericSend+0x19e>
					vTaskMissedYield();
    cf18:	f001 f94c 	bl	e1b4 <vTaskMissedYield>
				--cRxLock;
    cf1c:	1e6b      	subs	r3, r5, #1
    cf1e:	b2da      	uxtb	r2, r3
    cf20:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cf22:	2a00      	cmp	r2, #0
    cf24:	d1f1      	bne.n	cf0a <xQueueGenericSend+0x1a6>
		pxQueue->cRxLock = queueUNLOCKED;
    cf26:	23ff      	movs	r3, #255	; 0xff
    cf28:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    cf2c:	f7ff fbf4 	bl	c718 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
    cf30:	f000 ff34 	bl	dd9c <xTaskResumeAll>
    cf34:	2800      	cmp	r0, #0
    cf36:	d1ab      	bne.n	ce90 <xQueueGenericSend+0x12c>
					portYIELD_WITHIN_API();
    cf38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    cf3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cf40:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    cf44:	f3bf 8f4f 	dsb	sy
    cf48:	f3bf 8f6f 	isb	sy
    cf4c:	e7a0      	b.n	ce90 <xQueueGenericSend+0x12c>
					vTaskInternalSetTimeOutState( &xTimeOut );
    cf4e:	a802      	add	r0, sp, #8
    cf50:	f001 f8ec 	bl	e12c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    cf54:	e735      	b.n	cdc2 <xQueueGenericSend+0x5e>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    cf56:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    cf58:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    cf5a:	b1c2      	cbz	r2, cf8e <xQueueGenericSend+0x22a>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    cf5c:	4641      	mov	r1, r8
    cf5e:	68e0      	ldr	r0, [r4, #12]
    cf60:	f7ff f8ce 	bl	c100 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    cf64:	6c22      	ldr	r2, [r4, #64]	; 0x40
    cf66:	68e3      	ldr	r3, [r4, #12]
    cf68:	4251      	negs	r1, r2
    cf6a:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    cf6c:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    cf6e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    cf70:	4293      	cmp	r3, r2
    cf72:	d204      	bcs.n	cf7e <xQueueGenericSend+0x21a>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    cf74:	68a3      	ldr	r3, [r4, #8]
    cf76:	440b      	add	r3, r1
    cf78:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    cf7a:	2f02      	cmp	r7, #2
    cf7c:	d107      	bne.n	cf8e <xQueueGenericSend+0x22a>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    cf7e:	2d01      	cmp	r5, #1
    cf80:	bf38      	it	cc
    cf82:	2501      	movcc	r5, #1
    cf84:	e004      	b.n	cf90 <xQueueGenericSend+0x22c>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    cf86:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    cf88:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    cf8a:	2a00      	cmp	r2, #0
    cf8c:	d15e      	bne.n	d04c <xQueueGenericSend+0x2e8>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    cf8e:	3501      	adds	r5, #1
    cf90:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cf92:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cf94:	2b00      	cmp	r3, #0
    cf96:	d148      	bne.n	d02a <xQueueGenericSend+0x2c6>
				taskEXIT_CRITICAL();
    cf98:	f7ff fbbe 	bl	c718 <vPortExitCritical>
				return pdPASS;
    cf9c:	2001      	movs	r0, #1
}
    cf9e:	b005      	add	sp, #20
    cfa0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    cfa4:	9000      	str	r0, [sp, #0]
					taskEXIT_CRITICAL();
    cfa6:	f7ff fbb7 	bl	c718 <vPortExitCritical>
					return errQUEUE_FULL;
    cfaa:	9800      	ldr	r0, [sp, #0]
    cfac:	e7f7      	b.n	cf9e <xQueueGenericSend+0x23a>
	taskENTER_CRITICAL();
    cfae:	f7ff fb99 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    cfb2:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    cfb6:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cfb8:	2d00      	cmp	r5, #0
    cfba:	dd10      	ble.n	cfde <xQueueGenericSend+0x27a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cfbc:	f104 0624 	add.w	r6, r4, #36	; 0x24
    cfc0:	e003      	b.n	cfca <xQueueGenericSend+0x266>
			--cTxLock;
    cfc2:	1e6b      	subs	r3, r5, #1
    cfc4:	b2da      	uxtb	r2, r3
    cfc6:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    cfc8:	b14a      	cbz	r2, cfde <xQueueGenericSend+0x27a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cfca:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cfcc:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    cfce:	b133      	cbz	r3, cfde <xQueueGenericSend+0x27a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    cfd0:	f001 f824 	bl	e01c <xTaskRemoveFromEventList>
    cfd4:	2800      	cmp	r0, #0
    cfd6:	d0f4      	beq.n	cfc2 <xQueueGenericSend+0x25e>
						vTaskMissedYield();
    cfd8:	f001 f8ec 	bl	e1b4 <vTaskMissedYield>
    cfdc:	e7f1      	b.n	cfc2 <xQueueGenericSend+0x25e>
		pxQueue->cTxLock = queueUNLOCKED;
    cfde:	23ff      	movs	r3, #255	; 0xff
    cfe0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    cfe4:	f7ff fb98 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    cfe8:	f7ff fb7c 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    cfec:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    cff0:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    cff2:	2d00      	cmp	r5, #0
    cff4:	dd10      	ble.n	d018 <xQueueGenericSend+0x2b4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    cff6:	f104 0610 	add.w	r6, r4, #16
    cffa:	e003      	b.n	d004 <xQueueGenericSend+0x2a0>
				--cRxLock;
    cffc:	1e6b      	subs	r3, r5, #1
    cffe:	b2da      	uxtb	r2, r3
    d000:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d002:	b14a      	cbz	r2, d018 <xQueueGenericSend+0x2b4>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d004:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d006:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d008:	b133      	cbz	r3, d018 <xQueueGenericSend+0x2b4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d00a:	f001 f807 	bl	e01c <xTaskRemoveFromEventList>
    d00e:	2800      	cmp	r0, #0
    d010:	d0f4      	beq.n	cffc <xQueueGenericSend+0x298>
					vTaskMissedYield();
    d012:	f001 f8cf 	bl	e1b4 <vTaskMissedYield>
    d016:	e7f1      	b.n	cffc <xQueueGenericSend+0x298>
		pxQueue->cRxLock = queueUNLOCKED;
    d018:	23ff      	movs	r3, #255	; 0xff
    d01a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    d01e:	f7ff fb7b 	bl	c718 <vPortExitCritical>
			( void ) xTaskResumeAll();
    d022:	f000 febb 	bl	dd9c <xTaskResumeAll>
			return errQUEUE_FULL;
    d026:	2000      	movs	r0, #0
    d028:	e7b9      	b.n	cf9e <xQueueGenericSend+0x23a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d02a:	f104 0024 	add.w	r0, r4, #36	; 0x24
    d02e:	f000 fff5 	bl	e01c <xTaskRemoveFromEventList>
    d032:	2800      	cmp	r0, #0
    d034:	d0b0      	beq.n	cf98 <xQueueGenericSend+0x234>
							queueYIELD_IF_USING_PREEMPTION();
    d036:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    d03a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d03e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    d042:	f3bf 8f4f 	dsb	sy
    d046:	f3bf 8f6f 	isb	sy
    d04a:	e7a5      	b.n	cf98 <xQueueGenericSend+0x234>
	else if( xPosition == queueSEND_TO_BACK )
    d04c:	b977      	cbnz	r7, d06c <xQueueGenericSend+0x308>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    d04e:	4641      	mov	r1, r8
    d050:	6860      	ldr	r0, [r4, #4]
    d052:	f7ff f855 	bl	c100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d056:	6863      	ldr	r3, [r4, #4]
    d058:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d05a:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d05c:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d05e:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d060:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d062:	d394      	bcc.n	cf8e <xQueueGenericSend+0x22a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    d064:	6823      	ldr	r3, [r4, #0]
    d066:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    d068:	3501      	adds	r5, #1
    d06a:	e791      	b.n	cf90 <xQueueGenericSend+0x22c>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    d06c:	4641      	mov	r1, r8
    d06e:	68e0      	ldr	r0, [r4, #12]
    d070:	f7ff f846 	bl	c100 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d074:	6c22      	ldr	r2, [r4, #64]	; 0x40
    d076:	68e3      	ldr	r3, [r4, #12]
    d078:	4251      	negs	r1, r2
    d07a:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d07c:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d07e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d080:	4293      	cmp	r3, r2
    d082:	f4bf af7a 	bcs.w	cf7a <xQueueGenericSend+0x216>
    d086:	e775      	b.n	cf74 <xQueueGenericSend+0x210>

0000d088 <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
    d088:	b160      	cbz	r0, d0a4 <xQueueGenericSendFromISR+0x1c>
{
    d08a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d08e:	460e      	mov	r6, r1
    d090:	4617      	mov	r7, r2
    d092:	461d      	mov	r5, r3
    d094:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d096:	b1e9      	cbz	r1, d0d4 <xQueueGenericSendFromISR+0x4c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    d098:	2d02      	cmp	r5, #2
    d09a:	d104      	bne.n	d0a6 <xQueueGenericSendFromISR+0x1e>
    d09c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    d09e:	2b01      	cmp	r3, #1
    d0a0:	d001      	beq.n	d0a6 <xQueueGenericSendFromISR+0x1e>
    d0a2:	e7fe      	b.n	d0a2 <xQueueGenericSendFromISR+0x1a>
	configASSERT( pxQueue );
    d0a4:	e7fe      	b.n	d0a4 <xQueueGenericSendFromISR+0x1c>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    d0a6:	f7ff fb8b 	bl	c7c0 <vPortValidateInterruptPriority>
	__asm volatile
    d0aa:	f3ef 8a11 	mrs	sl, BASEPRI
    d0ae:	f04f 0380 	mov.w	r3, #128	; 0x80
    d0b2:	f383 8811 	msr	BASEPRI, r3
    d0b6:	f3bf 8f6f 	isb	sy
    d0ba:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    d0be:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    d0c0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    d0c2:	429a      	cmp	r2, r3
    d0c4:	d339      	bcc.n	d13a <xQueueGenericSendFromISR+0xb2>
    d0c6:	2d02      	cmp	r5, #2
    d0c8:	d008      	beq.n	d0dc <xQueueGenericSendFromISR+0x54>
			xReturn = errQUEUE_FULL;
    d0ca:	2000      	movs	r0, #0
	__asm volatile
    d0cc:	f38a 8811 	msr	BASEPRI, sl
}
    d0d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d0d4:	6c03      	ldr	r3, [r0, #64]	; 0x40
    d0d6:	2b00      	cmp	r3, #0
    d0d8:	d0de      	beq.n	d098 <xQueueGenericSendFromISR+0x10>
    d0da:	e7fe      	b.n	d0da <xQueueGenericSendFromISR+0x52>
			const int8_t cTxLock = pxQueue->cTxLock;
    d0dc:	f894 8045 	ldrb.w	r8, [r4, #69]	; 0x45
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    d0e0:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d0e2:	f8d4 9038 	ldr.w	r9, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    d0e6:	fa4f f888 	sxtb.w	r8, r8
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    d0ea:	b1b2      	cbz	r2, d11a <xQueueGenericSendFromISR+0x92>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    d0ec:	4631      	mov	r1, r6
    d0ee:	68e0      	ldr	r0, [r4, #12]
    d0f0:	f7ff f806 	bl	c100 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d0f4:	6c23      	ldr	r3, [r4, #64]	; 0x40
    d0f6:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d0f8:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d0fa:	1ad2      	subs	r2, r2, r3
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d0fc:	428a      	cmp	r2, r1
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d0fe:	60e2      	str	r2, [r4, #12]
    d100:	f1c3 0300 	rsb	r3, r3, #0
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d104:	d204      	bcs.n	d110 <xQueueGenericSendFromISR+0x88>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    d106:	68a2      	ldr	r2, [r4, #8]
    d108:	4413      	add	r3, r2
    d10a:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    d10c:	2d02      	cmp	r5, #2
    d10e:	d104      	bne.n	d11a <xQueueGenericSendFromISR+0x92>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d110:	464b      	mov	r3, r9
    d112:	2b01      	cmp	r3, #1
    d114:	bf38      	it	cc
    d116:	2301      	movcc	r3, #1
    d118:	e001      	b.n	d11e <xQueueGenericSendFromISR+0x96>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    d11a:	f109 0301 	add.w	r3, r9, #1
			if( cTxLock == queueUNLOCKED )
    d11e:	f1b8 3fff 	cmp.w	r8, #4294967295
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    d122:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
    d124:	d023      	beq.n	d16e <xQueueGenericSendFromISR+0xe6>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    d126:	f108 0301 	add.w	r3, r8, #1
    d12a:	b25b      	sxtb	r3, r3
    d12c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
    d130:	2001      	movs	r0, #1
    d132:	f38a 8811 	msr	BASEPRI, sl
}
    d136:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			const int8_t cTxLock = pxQueue->cTxLock;
    d13a:	f894 8045 	ldrb.w	r8, [r4, #69]	; 0x45
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    d13e:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d140:	f8d4 9038 	ldr.w	r9, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    d144:	fa4f f888 	sxtb.w	r8, r8
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    d148:	2a00      	cmp	r2, #0
    d14a:	d0e6      	beq.n	d11a <xQueueGenericSendFromISR+0x92>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    d14c:	4631      	mov	r1, r6
	else if( xPosition == queueSEND_TO_BACK )
    d14e:	b9e5      	cbnz	r5, d18a <xQueueGenericSendFromISR+0x102>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    d150:	6860      	ldr	r0, [r4, #4]
    d152:	f7fe ffd5 	bl	c100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d156:	6863      	ldr	r3, [r4, #4]
    d158:	6c22      	ldr	r2, [r4, #64]	; 0x40
    d15a:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d15c:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d15e:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d160:	4293      	cmp	r3, r2
			pxQueue->pcWriteTo = pxQueue->pcHead;
    d162:	bf24      	itt	cs
    d164:	6822      	ldrcs	r2, [r4, #0]
    d166:	6062      	strcs	r2, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    d168:	f109 0301 	add.w	r3, r9, #1
			pxQueue->pcWriteTo = pxQueue->pcHead;
    d16c:	e7d7      	b.n	d11e <xQueueGenericSendFromISR+0x96>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d16e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    d170:	2b00      	cmp	r3, #0
    d172:	d0dd      	beq.n	d130 <xQueueGenericSendFromISR+0xa8>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d174:	f104 0024 	add.w	r0, r4, #36	; 0x24
    d178:	f000 ff50 	bl	e01c <xTaskRemoveFromEventList>
    d17c:	2800      	cmp	r0, #0
    d17e:	d0d7      	beq.n	d130 <xQueueGenericSendFromISR+0xa8>
							if( pxHigherPriorityTaskWoken != NULL )
    d180:	2f00      	cmp	r7, #0
    d182:	d0d5      	beq.n	d130 <xQueueGenericSendFromISR+0xa8>
								*pxHigherPriorityTaskWoken = pdTRUE;
    d184:	2001      	movs	r0, #1
    d186:	6038      	str	r0, [r7, #0]
    d188:	e7a0      	b.n	d0cc <xQueueGenericSendFromISR+0x44>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    d18a:	68e0      	ldr	r0, [r4, #12]
    d18c:	f7fe ffb8 	bl	c100 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d190:	6c23      	ldr	r3, [r4, #64]	; 0x40
    d192:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d194:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d196:	1ad2      	subs	r2, r2, r3
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d198:	428a      	cmp	r2, r1
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    d19a:	60e2      	str	r2, [r4, #12]
    d19c:	f1c3 0300 	rsb	r3, r3, #0
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    d1a0:	d2b4      	bcs.n	d10c <xQueueGenericSendFromISR+0x84>
    d1a2:	e7b0      	b.n	d106 <xQueueGenericSendFromISR+0x7e>

0000d1a4 <xQueueReceive>:
{
    d1a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d1a8:	b085      	sub	sp, #20
    d1aa:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
    d1ac:	2800      	cmp	r0, #0
    d1ae:	f000 8099 	beq.w	d2e4 <xQueueReceive+0x140>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d1b2:	460f      	mov	r7, r1
    d1b4:	4604      	mov	r4, r0
    d1b6:	2900      	cmp	r1, #0
    d1b8:	f000 8095 	beq.w	d2e6 <xQueueReceive+0x142>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    d1bc:	f001 f81c 	bl	e1f8 <xTaskGetSchedulerState>
    d1c0:	2800      	cmp	r0, #0
    d1c2:	f000 8095 	beq.w	d2f0 <xQueueReceive+0x14c>
		taskENTER_CRITICAL();
    d1c6:	f7ff fa8d 	bl	c6e4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d1ca:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d1cc:	2d00      	cmp	r5, #0
    d1ce:	d172      	bne.n	d2b6 <xQueueReceive+0x112>
				if( xTicksToWait == ( TickType_t ) 0 )
    d1d0:	9b01      	ldr	r3, [sp, #4]
    d1d2:	2b00      	cmp	r3, #0
    d1d4:	f000 80e2 	beq.w	d39c <xQueueReceive+0x1f8>
					vTaskInternalSetTimeOutState( &xTimeOut );
    d1d8:	a802      	add	r0, sp, #8
    d1da:	f000 ffa7 	bl	e12c <vTaskInternalSetTimeOutState>
		prvLockQueue( pxQueue );
    d1de:	46a8      	mov	r8, r5
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d1e0:	f104 0624 	add.w	r6, r4, #36	; 0x24
		taskEXIT_CRITICAL();
    d1e4:	f7ff fa98 	bl	c718 <vPortExitCritical>
		vTaskSuspendAll();
    d1e8:	f000 fc90 	bl	db0c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    d1ec:	f7ff fa7a 	bl	c6e4 <vPortEnterCritical>
    d1f0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    d1f4:	2bff      	cmp	r3, #255	; 0xff
    d1f6:	bf08      	it	eq
    d1f8:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
    d1fc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d200:	2bff      	cmp	r3, #255	; 0xff
    d202:	bf08      	it	eq
    d204:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
    d208:	f7ff fa86 	bl	c718 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    d20c:	a901      	add	r1, sp, #4
    d20e:	a802      	add	r0, sp, #8
    d210:	f000 ff98 	bl	e144 <xTaskCheckForTimeOut>
    d214:	2800      	cmp	r0, #0
    d216:	d170      	bne.n	d2fa <xQueueReceive+0x156>
	taskENTER_CRITICAL();
    d218:	f7ff fa64 	bl	c6e4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    d21c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d21e:	2b00      	cmp	r3, #0
    d220:	f000 80c2 	beq.w	d3a8 <xQueueReceive+0x204>
	taskEXIT_CRITICAL();
    d224:	f7ff fa78 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    d228:	f7ff fa5c 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    d22c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d230:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d232:	2d00      	cmp	r5, #0
    d234:	dc04      	bgt.n	d240 <xQueueReceive+0x9c>
    d236:	e011      	b.n	d25c <xQueueReceive+0xb8>
			--cTxLock;
    d238:	1e6b      	subs	r3, r5, #1
    d23a:	b2da      	uxtb	r2, r3
    d23c:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d23e:	b16a      	cbz	r2, d25c <xQueueReceive+0xb8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d240:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d242:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d244:	b153      	cbz	r3, d25c <xQueueReceive+0xb8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d246:	f000 fee9 	bl	e01c <xTaskRemoveFromEventList>
    d24a:	2800      	cmp	r0, #0
    d24c:	d0f4      	beq.n	d238 <xQueueReceive+0x94>
						vTaskMissedYield();
    d24e:	f000 ffb1 	bl	e1b4 <vTaskMissedYield>
			--cTxLock;
    d252:	1e6b      	subs	r3, r5, #1
    d254:	b2da      	uxtb	r2, r3
    d256:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d258:	2a00      	cmp	r2, #0
    d25a:	d1f1      	bne.n	d240 <xQueueReceive+0x9c>
		pxQueue->cTxLock = queueUNLOCKED;
    d25c:	23ff      	movs	r3, #255	; 0xff
    d25e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    d262:	f7ff fa59 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    d266:	f7ff fa3d 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    d26a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    d26e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d270:	2d00      	cmp	r5, #0
    d272:	dd14      	ble.n	d29e <xQueueReceive+0xfa>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d274:	f104 0910 	add.w	r9, r4, #16
    d278:	e003      	b.n	d282 <xQueueReceive+0xde>
				--cRxLock;
    d27a:	1e6b      	subs	r3, r5, #1
    d27c:	b2da      	uxtb	r2, r3
    d27e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d280:	b16a      	cbz	r2, d29e <xQueueReceive+0xfa>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d282:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d284:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d286:	b153      	cbz	r3, d29e <xQueueReceive+0xfa>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d288:	f000 fec8 	bl	e01c <xTaskRemoveFromEventList>
    d28c:	2800      	cmp	r0, #0
    d28e:	d0f4      	beq.n	d27a <xQueueReceive+0xd6>
					vTaskMissedYield();
    d290:	f000 ff90 	bl	e1b4 <vTaskMissedYield>
				--cRxLock;
    d294:	1e6b      	subs	r3, r5, #1
    d296:	b2da      	uxtb	r2, r3
    d298:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d29a:	2a00      	cmp	r2, #0
    d29c:	d1f1      	bne.n	d282 <xQueueReceive+0xde>
		pxQueue->cRxLock = queueUNLOCKED;
    d29e:	23ff      	movs	r3, #255	; 0xff
    d2a0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    d2a4:	f7ff fa38 	bl	c718 <vPortExitCritical>
				( void ) xTaskResumeAll();
    d2a8:	f000 fd78 	bl	dd9c <xTaskResumeAll>
		taskENTER_CRITICAL();
    d2ac:	f7ff fa1a 	bl	c6e4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d2b0:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d2b2:	2d00      	cmp	r5, #0
    d2b4:	d06e      	beq.n	d394 <xQueueReceive+0x1f0>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    d2b6:	6c22      	ldr	r2, [r4, #64]	; 0x40
    d2b8:	b152      	cbz	r2, d2d0 <xQueueReceive+0x12c>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d2ba:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    d2bc:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d2be:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    d2c0:	4299      	cmp	r1, r3
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    d2c2:	60e1      	str	r1, [r4, #12]
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    d2c4:	bf24      	itt	cs
    d2c6:	6821      	ldrcs	r1, [r4, #0]
    d2c8:	60e1      	strcs	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    d2ca:	4638      	mov	r0, r7
    d2cc:	f7fe ff18 	bl	c100 <memcpy>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    d2d0:	3d01      	subs	r5, #1
    d2d2:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d2d4:	6923      	ldr	r3, [r4, #16]
    d2d6:	2b00      	cmp	r3, #0
    d2d8:	f040 80bb 	bne.w	d452 <xQueueReceive+0x2ae>
				taskEXIT_CRITICAL();
    d2dc:	f7ff fa1c 	bl	c718 <vPortExitCritical>
				return pdPASS;
    d2e0:	2001      	movs	r0, #1
    d2e2:	e05e      	b.n	d3a2 <xQueueReceive+0x1fe>
	configASSERT( ( pxQueue ) );
    d2e4:	e7fe      	b.n	d2e4 <xQueueReceive+0x140>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    d2e6:	6c03      	ldr	r3, [r0, #64]	; 0x40
    d2e8:	2b00      	cmp	r3, #0
    d2ea:	f43f af67 	beq.w	d1bc <xQueueReceive+0x18>
    d2ee:	e7fe      	b.n	d2ee <xQueueReceive+0x14a>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    d2f0:	9b01      	ldr	r3, [sp, #4]
    d2f2:	2b00      	cmp	r3, #0
    d2f4:	f43f af67 	beq.w	d1c6 <xQueueReceive+0x22>
    d2f8:	e7fe      	b.n	d2f8 <xQueueReceive+0x154>
	taskENTER_CRITICAL();
    d2fa:	f7ff f9f3 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    d2fe:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d302:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d304:	2d00      	cmp	r5, #0
    d306:	dc04      	bgt.n	d312 <xQueueReceive+0x16e>
    d308:	e011      	b.n	d32e <xQueueReceive+0x18a>
			--cTxLock;
    d30a:	1e6b      	subs	r3, r5, #1
    d30c:	b2da      	uxtb	r2, r3
    d30e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d310:	b16a      	cbz	r2, d32e <xQueueReceive+0x18a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d312:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d314:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d316:	b153      	cbz	r3, d32e <xQueueReceive+0x18a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d318:	f000 fe80 	bl	e01c <xTaskRemoveFromEventList>
    d31c:	2800      	cmp	r0, #0
    d31e:	d0f4      	beq.n	d30a <xQueueReceive+0x166>
						vTaskMissedYield();
    d320:	f000 ff48 	bl	e1b4 <vTaskMissedYield>
			--cTxLock;
    d324:	1e6b      	subs	r3, r5, #1
    d326:	b2da      	uxtb	r2, r3
    d328:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d32a:	2a00      	cmp	r2, #0
    d32c:	d1f1      	bne.n	d312 <xQueueReceive+0x16e>
		pxQueue->cTxLock = queueUNLOCKED;
    d32e:	23ff      	movs	r3, #255	; 0xff
    d330:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    d334:	f7ff f9f0 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    d338:	f7ff f9d4 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    d33c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    d340:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d342:	2d00      	cmp	r5, #0
    d344:	dd14      	ble.n	d370 <xQueueReceive+0x1cc>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d346:	f104 0910 	add.w	r9, r4, #16
    d34a:	e003      	b.n	d354 <xQueueReceive+0x1b0>
				--cRxLock;
    d34c:	1e6b      	subs	r3, r5, #1
    d34e:	b2da      	uxtb	r2, r3
    d350:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d352:	b16a      	cbz	r2, d370 <xQueueReceive+0x1cc>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d354:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d356:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d358:	b153      	cbz	r3, d370 <xQueueReceive+0x1cc>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d35a:	f000 fe5f 	bl	e01c <xTaskRemoveFromEventList>
    d35e:	2800      	cmp	r0, #0
    d360:	d0f4      	beq.n	d34c <xQueueReceive+0x1a8>
					vTaskMissedYield();
    d362:	f000 ff27 	bl	e1b4 <vTaskMissedYield>
				--cRxLock;
    d366:	1e6b      	subs	r3, r5, #1
    d368:	b2da      	uxtb	r2, r3
    d36a:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d36c:	2a00      	cmp	r2, #0
    d36e:	d1f1      	bne.n	d354 <xQueueReceive+0x1b0>
		pxQueue->cRxLock = queueUNLOCKED;
    d370:	23ff      	movs	r3, #255	; 0xff
    d372:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    d376:	f7ff f9cf 	bl	c718 <vPortExitCritical>
			( void ) xTaskResumeAll();
    d37a:	f000 fd0f 	bl	dd9c <xTaskResumeAll>
	taskENTER_CRITICAL();
    d37e:	f7ff f9b1 	bl	c6e4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    d382:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d384:	b153      	cbz	r3, d39c <xQueueReceive+0x1f8>
	taskEXIT_CRITICAL();
    d386:	f7ff f9c7 	bl	c718 <vPortExitCritical>
		taskENTER_CRITICAL();
    d38a:	f7ff f9ab 	bl	c6e4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d38e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    d390:	2d00      	cmp	r5, #0
    d392:	d190      	bne.n	d2b6 <xQueueReceive+0x112>
				if( xTicksToWait == ( TickType_t ) 0 )
    d394:	9b01      	ldr	r3, [sp, #4]
    d396:	2b00      	cmp	r3, #0
    d398:	f47f af24 	bne.w	d1e4 <xQueueReceive+0x40>
					taskEXIT_CRITICAL();
    d39c:	f7ff f9bc 	bl	c718 <vPortExitCritical>
					return errQUEUE_EMPTY;
    d3a0:	2000      	movs	r0, #0
}
    d3a2:	b005      	add	sp, #20
    d3a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	taskEXIT_CRITICAL();
    d3a8:	f7ff f9b6 	bl	c718 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    d3ac:	9901      	ldr	r1, [sp, #4]
    d3ae:	4630      	mov	r0, r6
    d3b0:	f000 fd70 	bl	de94 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
    d3b4:	f7ff f996 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    d3b8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d3bc:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d3be:	2d00      	cmp	r5, #0
    d3c0:	dc04      	bgt.n	d3cc <xQueueReceive+0x228>
    d3c2:	e011      	b.n	d3e8 <xQueueReceive+0x244>
			--cTxLock;
    d3c4:	1e6b      	subs	r3, r5, #1
    d3c6:	b2da      	uxtb	r2, r3
    d3c8:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d3ca:	b16a      	cbz	r2, d3e8 <xQueueReceive+0x244>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d3cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d3ce:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d3d0:	b153      	cbz	r3, d3e8 <xQueueReceive+0x244>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d3d2:	f000 fe23 	bl	e01c <xTaskRemoveFromEventList>
    d3d6:	2800      	cmp	r0, #0
    d3d8:	d0f4      	beq.n	d3c4 <xQueueReceive+0x220>
						vTaskMissedYield();
    d3da:	f000 feeb 	bl	e1b4 <vTaskMissedYield>
			--cTxLock;
    d3de:	1e6b      	subs	r3, r5, #1
    d3e0:	b2da      	uxtb	r2, r3
    d3e2:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d3e4:	2a00      	cmp	r2, #0
    d3e6:	d1f1      	bne.n	d3cc <xQueueReceive+0x228>
		pxQueue->cTxLock = queueUNLOCKED;
    d3e8:	23ff      	movs	r3, #255	; 0xff
    d3ea:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    d3ee:	f7ff f993 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    d3f2:	f7ff f977 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    d3f6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    d3fa:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d3fc:	2d00      	cmp	r5, #0
    d3fe:	dd14      	ble.n	d42a <xQueueReceive+0x286>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d400:	f104 0910 	add.w	r9, r4, #16
    d404:	e003      	b.n	d40e <xQueueReceive+0x26a>
				--cRxLock;
    d406:	1e6b      	subs	r3, r5, #1
    d408:	b2da      	uxtb	r2, r3
    d40a:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d40c:	b16a      	cbz	r2, d42a <xQueueReceive+0x286>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d40e:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d410:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d412:	b153      	cbz	r3, d42a <xQueueReceive+0x286>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d414:	f000 fe02 	bl	e01c <xTaskRemoveFromEventList>
    d418:	2800      	cmp	r0, #0
    d41a:	d0f4      	beq.n	d406 <xQueueReceive+0x262>
					vTaskMissedYield();
    d41c:	f000 feca 	bl	e1b4 <vTaskMissedYield>
				--cRxLock;
    d420:	1e6b      	subs	r3, r5, #1
    d422:	b2da      	uxtb	r2, r3
    d424:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d426:	2a00      	cmp	r2, #0
    d428:	d1f1      	bne.n	d40e <xQueueReceive+0x26a>
		pxQueue->cRxLock = queueUNLOCKED;
    d42a:	23ff      	movs	r3, #255	; 0xff
    d42c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    d430:	f7ff f972 	bl	c718 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
    d434:	f000 fcb2 	bl	dd9c <xTaskResumeAll>
    d438:	2800      	cmp	r0, #0
    d43a:	d1a6      	bne.n	d38a <xQueueReceive+0x1e6>
					portYIELD_WITHIN_API();
    d43c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    d440:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d444:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    d448:	f3bf 8f4f 	dsb	sy
    d44c:	f3bf 8f6f 	isb	sy
		taskENTER_CRITICAL();
    d450:	e79b      	b.n	d38a <xQueueReceive+0x1e6>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d452:	f104 0010 	add.w	r0, r4, #16
    d456:	f000 fde1 	bl	e01c <xTaskRemoveFromEventList>
    d45a:	2800      	cmp	r0, #0
    d45c:	f43f af3e 	beq.w	d2dc <xQueueReceive+0x138>
						queueYIELD_IF_USING_PREEMPTION();
    d460:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    d464:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d468:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    d46c:	f3bf 8f4f 	dsb	sy
    d470:	f3bf 8f6f 	isb	sy
    d474:	e732      	b.n	d2dc <xQueueReceive+0x138>
    d476:	bf00      	nop

0000d478 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    d478:	b570      	push	{r4, r5, r6, lr}
    d47a:	4605      	mov	r5, r0
    d47c:	460e      	mov	r6, r1
    d47e:	4614      	mov	r4, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    d480:	f7ff f930 	bl	c6e4 <vPortEnterCritical>
    d484:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
    d488:	2bff      	cmp	r3, #255	; 0xff
    d48a:	bf04      	itt	eq
    d48c:	2300      	moveq	r3, #0
    d48e:	f885 3044 	strbeq.w	r3, [r5, #68]	; 0x44
    d492:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
    d496:	2bff      	cmp	r3, #255	; 0xff
    d498:	bf04      	itt	eq
    d49a:	2300      	moveq	r3, #0
    d49c:	f885 3045 	strbeq.w	r3, [r5, #69]	; 0x45
    d4a0:	f7ff f93a 	bl	c718 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    d4a4:	6bab      	ldr	r3, [r5, #56]	; 0x38
    d4a6:	2b00      	cmp	r3, #0
    d4a8:	d043      	beq.n	d532 <vQueueWaitForMessageRestricted+0xba>
	taskENTER_CRITICAL();
    d4aa:	f7ff f91b 	bl	c6e4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
    d4ae:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
    d4b2:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d4b4:	2c00      	cmp	r4, #0
    d4b6:	dd14      	ble.n	d4e2 <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d4b8:	f105 0624 	add.w	r6, r5, #36	; 0x24
    d4bc:	e003      	b.n	d4c6 <vQueueWaitForMessageRestricted+0x4e>
			--cTxLock;
    d4be:	1e63      	subs	r3, r4, #1
    d4c0:	b2da      	uxtb	r2, r3
    d4c2:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d4c4:	b16a      	cbz	r2, d4e2 <vQueueWaitForMessageRestricted+0x6a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d4c6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d4c8:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    d4ca:	b153      	cbz	r3, d4e2 <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    d4cc:	f000 fda6 	bl	e01c <xTaskRemoveFromEventList>
    d4d0:	2800      	cmp	r0, #0
    d4d2:	d0f4      	beq.n	d4be <vQueueWaitForMessageRestricted+0x46>
						vTaskMissedYield();
    d4d4:	f000 fe6e 	bl	e1b4 <vTaskMissedYield>
			--cTxLock;
    d4d8:	1e63      	subs	r3, r4, #1
    d4da:	b2da      	uxtb	r2, r3
    d4dc:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
    d4de:	2a00      	cmp	r2, #0
    d4e0:	d1f1      	bne.n	d4c6 <vQueueWaitForMessageRestricted+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
    d4e2:	23ff      	movs	r3, #255	; 0xff
    d4e4:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
    d4e8:	f7ff f916 	bl	c718 <vPortExitCritical>
	taskENTER_CRITICAL();
    d4ec:	f7ff f8fa 	bl	c6e4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
    d4f0:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
    d4f4:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d4f6:	2c00      	cmp	r4, #0
    d4f8:	dd14      	ble.n	d524 <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d4fa:	f105 0610 	add.w	r6, r5, #16
    d4fe:	e003      	b.n	d508 <vQueueWaitForMessageRestricted+0x90>
				--cRxLock;
    d500:	1e63      	subs	r3, r4, #1
    d502:	b2da      	uxtb	r2, r3
    d504:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d506:	b16a      	cbz	r2, d524 <vQueueWaitForMessageRestricted+0xac>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d508:	692b      	ldr	r3, [r5, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d50a:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    d50c:	b153      	cbz	r3, d524 <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    d50e:	f000 fd85 	bl	e01c <xTaskRemoveFromEventList>
    d512:	2800      	cmp	r0, #0
    d514:	d0f4      	beq.n	d500 <vQueueWaitForMessageRestricted+0x88>
					vTaskMissedYield();
    d516:	f000 fe4d 	bl	e1b4 <vTaskMissedYield>
				--cRxLock;
    d51a:	1e63      	subs	r3, r4, #1
    d51c:	b2da      	uxtb	r2, r3
    d51e:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
    d520:	2a00      	cmp	r2, #0
    d522:	d1f1      	bne.n	d508 <vQueueWaitForMessageRestricted+0x90>
		pxQueue->cRxLock = queueUNLOCKED;
    d524:	23ff      	movs	r3, #255	; 0xff
    d526:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
    d52a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
    d52e:	f7ff b8f3 	b.w	c718 <vPortExitCritical>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    d532:	4622      	mov	r2, r4
    d534:	4631      	mov	r1, r6
    d536:	f105 0024 	add.w	r0, r5, #36	; 0x24
    d53a:	f000 fd2d 	bl	df98 <vTaskPlaceOnEventListRestricted>
    d53e:	e7b4      	b.n	d4aa <vQueueWaitForMessageRestricted+0x32>

0000d540 <vTaskSwitchContext.part.0>:
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    d540:	4b2b      	ldr	r3, [pc, #172]	; (d5f0 <vTaskSwitchContext.part.0+0xb0>)
void vTaskSwitchContext( void )
    d542:	b570      	push	{r4, r5, r6, lr}
		xYieldPending = pdFALSE;
    d544:	2200      	movs	r2, #0
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    d546:	4c2b      	ldr	r4, [pc, #172]	; (d5f4 <vTaskSwitchContext.part.0+0xb4>)
		xYieldPending = pdFALSE;
    d548:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
    d54a:	6823      	ldr	r3, [r4, #0]
    d54c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    d54e:	681a      	ldr	r2, [r3, #0]
    d550:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d554:	d103      	bne.n	d55e <vTaskSwitchContext.part.0+0x1e>
    d556:	685a      	ldr	r2, [r3, #4]
    d558:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d55c:	d03f      	beq.n	d5de <vTaskSwitchContext.part.0+0x9e>
    d55e:	6820      	ldr	r0, [r4, #0]
    d560:	6821      	ldr	r1, [r4, #0]
    d562:	3134      	adds	r1, #52	; 0x34
    d564:	f7ff f846 	bl	c5f4 <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    d568:	4d23      	ldr	r5, [pc, #140]	; (d5f8 <vTaskSwitchContext.part.0+0xb8>)
    d56a:	4a24      	ldr	r2, [pc, #144]	; (d5fc <vTaskSwitchContext.part.0+0xbc>)
    d56c:	682b      	ldr	r3, [r5, #0]
    d56e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d572:	0080      	lsls	r0, r0, #2
    d574:	0099      	lsls	r1, r3, #2
    d576:	5810      	ldr	r0, [r2, r0]
    d578:	bb08      	cbnz	r0, d5be <vTaskSwitchContext.part.0+0x7e>
    d57a:	b1f3      	cbz	r3, d5ba <vTaskSwitchContext.part.0+0x7a>
    d57c:	1e58      	subs	r0, r3, #1
    d57e:	eb00 0180 	add.w	r1, r0, r0, lsl #2
    d582:	0089      	lsls	r1, r1, #2
    d584:	5856      	ldr	r6, [r2, r1]
    d586:	0081      	lsls	r1, r0, #2
    d588:	b9c6      	cbnz	r6, d5bc <vTaskSwitchContext.part.0+0x7c>
    d58a:	b1b0      	cbz	r0, d5ba <vTaskSwitchContext.part.0+0x7a>
    d58c:	1e98      	subs	r0, r3, #2
    d58e:	eb00 0180 	add.w	r1, r0, r0, lsl #2
    d592:	0089      	lsls	r1, r1, #2
    d594:	5856      	ldr	r6, [r2, r1]
    d596:	0081      	lsls	r1, r0, #2
    d598:	b986      	cbnz	r6, d5bc <vTaskSwitchContext.part.0+0x7c>
    d59a:	b170      	cbz	r0, d5ba <vTaskSwitchContext.part.0+0x7a>
    d59c:	1ed8      	subs	r0, r3, #3
    d59e:	eb00 0180 	add.w	r1, r0, r0, lsl #2
    d5a2:	0089      	lsls	r1, r1, #2
    d5a4:	5856      	ldr	r6, [r2, r1]
    d5a6:	0081      	lsls	r1, r0, #2
    d5a8:	b946      	cbnz	r6, d5bc <vTaskSwitchContext.part.0+0x7c>
    d5aa:	b130      	cbz	r0, d5ba <vTaskSwitchContext.part.0+0x7a>
    d5ac:	3b04      	subs	r3, #4
    d5ae:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    d5b2:	0080      	lsls	r0, r0, #2
    d5b4:	0099      	lsls	r1, r3, #2
    d5b6:	5810      	ldr	r0, [r2, r0]
    d5b8:	b908      	cbnz	r0, d5be <vTaskSwitchContext.part.0+0x7e>
    d5ba:	e7fe      	b.n	d5ba <vTaskSwitchContext.part.0+0x7a>
    d5bc:	4603      	mov	r3, r0
    d5be:	4419      	add	r1, r3
    d5c0:	eb02 0081 	add.w	r0, r2, r1, lsl #2
    d5c4:	4602      	mov	r2, r0
    d5c6:	6841      	ldr	r1, [r0, #4]
    d5c8:	6849      	ldr	r1, [r1, #4]
    d5ca:	6041      	str	r1, [r0, #4]
    d5cc:	3208      	adds	r2, #8
    d5ce:	4291      	cmp	r1, r2
    d5d0:	bf04      	itt	eq
    d5d2:	6849      	ldreq	r1, [r1, #4]
    d5d4:	6041      	streq	r1, [r0, #4]
    d5d6:	68ca      	ldr	r2, [r1, #12]
    d5d8:	6022      	str	r2, [r4, #0]
    d5da:	602b      	str	r3, [r5, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    d5dc:	bd70      	pop	{r4, r5, r6, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
    d5de:	689a      	ldr	r2, [r3, #8]
    d5e0:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
    d5e4:	d1bb      	bne.n	d55e <vTaskSwitchContext.part.0+0x1e>
    d5e6:	68db      	ldr	r3, [r3, #12]
    d5e8:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
    d5ec:	d1b7      	bne.n	d55e <vTaskSwitchContext.part.0+0x1e>
    d5ee:	e7bb      	b.n	d568 <vTaskSwitchContext.part.0+0x28>
    d5f0:	10002434 	.word	0x10002434
    d5f4:	10002360 	.word	0x10002360
    d5f8:	100023cc 	.word	0x100023cc
    d5fc:	1000236c 	.word	0x1000236c

0000d600 <xTaskCreate>:
	{
    d600:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    d604:	ea4f 0882 	mov.w	r8, r2, lsl #2
	{
    d608:	4607      	mov	r7, r0
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    d60a:	4640      	mov	r0, r8
	{
    d60c:	460c      	mov	r4, r1
    d60e:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    d610:	f001 ff98 	bl	f544 <pvPortMalloc>
			if( pxStack != NULL )
    d614:	2800      	cmp	r0, #0
    d616:	f000 80c3 	beq.w	d7a0 <xTaskCreate+0x1a0>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    d61a:	4606      	mov	r6, r0
    d61c:	204c      	movs	r0, #76	; 0x4c
    d61e:	f001 ff91 	bl	f544 <pvPortMalloc>
				if( pxNewTCB != NULL )
    d622:	4605      	mov	r5, r0
    d624:	2800      	cmp	r0, #0
    d626:	f000 80c0 	beq.w	d7aa <xTaskCreate+0x1aa>
					pxNewTCB->pxStack = pxStack;
    d62a:	6306      	str	r6, [r0, #48]	; 0x30
	configASSERT( pcName );
    d62c:	2c00      	cmp	r4, #0
    d62e:	f000 80bb 	beq.w	d7a8 <xTaskCreate+0x1a8>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    d632:	4642      	mov	r2, r8
    d634:	4630      	mov	r0, r6
    d636:	21a5      	movs	r1, #165	; 0xa5
    d638:	f002 f8b0 	bl	f79c <memset>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d63c:	7823      	ldrb	r3, [r4, #0]
    d63e:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    d642:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    d644:	f1a8 0204 	sub.w	r2, r8, #4
    d648:	4413      	add	r3, r2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    d64a:	f023 0a07 	bic.w	sl, r3, #7
		if( pcName[ x ] == ( char ) 0x00 )
    d64e:	7823      	ldrb	r3, [r4, #0]
    d650:	2b00      	cmp	r3, #0
    d652:	d04d      	beq.n	d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d654:	7863      	ldrb	r3, [r4, #1]
    d656:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
		if( pcName[ x ] == ( char ) 0x00 )
    d65a:	7863      	ldrb	r3, [r4, #1]
    d65c:	2b00      	cmp	r3, #0
    d65e:	d047      	beq.n	d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d660:	78a3      	ldrb	r3, [r4, #2]
    d662:	f885 3036 	strb.w	r3, [r5, #54]	; 0x36
		if( pcName[ x ] == ( char ) 0x00 )
    d666:	78a3      	ldrb	r3, [r4, #2]
    d668:	2b00      	cmp	r3, #0
    d66a:	d041      	beq.n	d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d66c:	78e3      	ldrb	r3, [r4, #3]
    d66e:	f885 3037 	strb.w	r3, [r5, #55]	; 0x37
		if( pcName[ x ] == ( char ) 0x00 )
    d672:	78e3      	ldrb	r3, [r4, #3]
    d674:	2b00      	cmp	r3, #0
    d676:	d03b      	beq.n	d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d678:	7923      	ldrb	r3, [r4, #4]
    d67a:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
		if( pcName[ x ] == ( char ) 0x00 )
    d67e:	7923      	ldrb	r3, [r4, #4]
    d680:	2b00      	cmp	r3, #0
    d682:	d035      	beq.n	d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d684:	7963      	ldrb	r3, [r4, #5]
    d686:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
		if( pcName[ x ] == ( char ) 0x00 )
    d68a:	7963      	ldrb	r3, [r4, #5]
    d68c:	2b00      	cmp	r3, #0
    d68e:	d02f      	beq.n	d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d690:	79a3      	ldrb	r3, [r4, #6]
    d692:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
		if( pcName[ x ] == ( char ) 0x00 )
    d696:	79a3      	ldrb	r3, [r4, #6]
    d698:	b353      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d69a:	79e3      	ldrb	r3, [r4, #7]
    d69c:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
		if( pcName[ x ] == ( char ) 0x00 )
    d6a0:	79e3      	ldrb	r3, [r4, #7]
    d6a2:	b32b      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6a4:	7a23      	ldrb	r3, [r4, #8]
    d6a6:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
		if( pcName[ x ] == ( char ) 0x00 )
    d6aa:	7a23      	ldrb	r3, [r4, #8]
    d6ac:	b303      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6ae:	7a63      	ldrb	r3, [r4, #9]
    d6b0:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
		if( pcName[ x ] == ( char ) 0x00 )
    d6b4:	7a63      	ldrb	r3, [r4, #9]
    d6b6:	b1db      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6b8:	7aa3      	ldrb	r3, [r4, #10]
    d6ba:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
		if( pcName[ x ] == ( char ) 0x00 )
    d6be:	7aa3      	ldrb	r3, [r4, #10]
    d6c0:	b1b3      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6c2:	7ae3      	ldrb	r3, [r4, #11]
    d6c4:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
		if( pcName[ x ] == ( char ) 0x00 )
    d6c8:	7ae3      	ldrb	r3, [r4, #11]
    d6ca:	b18b      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6cc:	7b23      	ldrb	r3, [r4, #12]
    d6ce:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
		if( pcName[ x ] == ( char ) 0x00 )
    d6d2:	7b23      	ldrb	r3, [r4, #12]
    d6d4:	b163      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6d6:	7b63      	ldrb	r3, [r4, #13]
    d6d8:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
		if( pcName[ x ] == ( char ) 0x00 )
    d6dc:	7b63      	ldrb	r3, [r4, #13]
    d6de:	b13b      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6e0:	7ba3      	ldrb	r3, [r4, #14]
    d6e2:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
		if( pcName[ x ] == ( char ) 0x00 )
    d6e6:	7ba3      	ldrb	r3, [r4, #14]
    d6e8:	b113      	cbz	r3, d6f0 <xTaskCreate+0xf0>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d6ea:	7be3      	ldrb	r3, [r4, #15]
    d6ec:	f885 3043 	strb.w	r3, [r5, #67]	; 0x43
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    d6f0:	9c08      	ldr	r4, [sp, #32]
    d6f2:	2c03      	cmp	r4, #3
    d6f4:	bf28      	it	cs
    d6f6:	2403      	movcs	r4, #3
    d6f8:	f04f 0800 	mov.w	r8, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d6fc:	1d2e      	adds	r6, r5, #4
	pxNewTCB->uxPriority = uxPriority;
    d6fe:	62ec      	str	r4, [r5, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d700:	4630      	mov	r0, r6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    d702:	f885 8043 	strb.w	r8, [r5, #67]	; 0x43
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d706:	f7ff fab1 	bl	cc6c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d70a:	f1c4 0404 	rsb	r4, r4, #4
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    d70e:	f105 0018 	add.w	r0, r5, #24
    d712:	f7ff faab 	bl	cc6c <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
    d716:	f8c5 8044 	str.w	r8, [r5, #68]	; 0x44
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d71a:	61ac      	str	r4, [r5, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    d71c:	f885 8048 	strb.w	r8, [r5, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    d720:	612d      	str	r5, [r5, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    d722:	626d      	str	r5, [r5, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d724:	464a      	mov	r2, r9
    d726:	4639      	mov	r1, r7
    d728:	4650      	mov	r0, sl
    d72a:	f7fe ffb3 	bl	c694 <pxPortInitialiseStack>
	if( pxCreatedTask != NULL )
    d72e:	9b09      	ldr	r3, [sp, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d730:	6028      	str	r0, [r5, #0]
	if( pxCreatedTask != NULL )
    d732:	b103      	cbz	r3, d736 <xTaskCreate+0x136>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    d734:	601d      	str	r5, [r3, #0]
	taskENTER_CRITICAL();
    d736:	f7fe ffd5 	bl	c6e4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
    d73a:	4a3a      	ldr	r2, [pc, #232]	; (d824 <xTaskCreate+0x224>)
		if( pxCurrentTCB == NULL )
    d73c:	4c3a      	ldr	r4, [pc, #232]	; (d828 <xTaskCreate+0x228>)
		uxCurrentNumberOfTasks++;
    d73e:	6813      	ldr	r3, [r2, #0]
    d740:	3301      	adds	r3, #1
    d742:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
    d744:	6823      	ldr	r3, [r4, #0]
    d746:	2b00      	cmp	r3, #0
    d748:	d03f      	beq.n	d7ca <xTaskCreate+0x1ca>
			if( xSchedulerRunning == pdFALSE )
    d74a:	4f38      	ldr	r7, [pc, #224]	; (d82c <xTaskCreate+0x22c>)
    d74c:	683b      	ldr	r3, [r7, #0]
    d74e:	2b00      	cmp	r3, #0
    d750:	d034      	beq.n	d7bc <xTaskCreate+0x1bc>
		prvAddTaskToReadyList( pxNewTCB );
    d752:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
		uxTaskNumber++;
    d754:	4a36      	ldr	r2, [pc, #216]	; (d830 <xTaskCreate+0x230>)
		prvAddTaskToReadyList( pxNewTCB );
    d756:	4937      	ldr	r1, [pc, #220]	; (d834 <xTaskCreate+0x234>)
		uxTaskNumber++;
    d758:	6813      	ldr	r3, [r2, #0]
    d75a:	3301      	adds	r3, #1
    d75c:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
    d75e:	680b      	ldr	r3, [r1, #0]
    d760:	4283      	cmp	r3, r0
    d762:	4b35      	ldr	r3, [pc, #212]	; (d838 <xTaskCreate+0x238>)
    d764:	bf38      	it	cc
    d766:	6008      	strcc	r0, [r1, #0]
    d768:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    d76c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    d770:	4631      	mov	r1, r6
    d772:	f7ff fa7f 	bl	cc74 <vListInsertEnd>
	taskEXIT_CRITICAL();
    d776:	f7fe ffcf 	bl	c718 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
    d77a:	683b      	ldr	r3, [r7, #0]
    d77c:	b1db      	cbz	r3, d7b6 <xTaskCreate+0x1b6>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    d77e:	6822      	ldr	r2, [r4, #0]
    d780:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    d782:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d784:	429a      	cmp	r2, r3
    d786:	d216      	bcs.n	d7b6 <xTaskCreate+0x1b6>
			taskYIELD_IF_USING_PREEMPTION();
    d788:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    d78c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d790:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    d794:	f3bf 8f4f 	dsb	sy
    d798:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
    d79c:	2001      	movs	r0, #1
    d79e:	e001      	b.n	d7a4 <xTaskCreate+0x1a4>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    d7a0:	f04f 30ff 	mov.w	r0, #4294967295
	}
    d7a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( pcName );
    d7a8:	e7fe      	b.n	d7a8 <xTaskCreate+0x1a8>
					vPortFree( pxStack );
    d7aa:	4630      	mov	r0, r6
    d7ac:	f001 ff28 	bl	f600 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    d7b0:	f04f 30ff 	mov.w	r0, #4294967295
    d7b4:	e7f6      	b.n	d7a4 <xTaskCreate+0x1a4>
			xReturn = pdPASS;
    d7b6:	2001      	movs	r0, #1
	}
    d7b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    d7bc:	6823      	ldr	r3, [r4, #0]
    d7be:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    d7c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    d7c2:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
    d7c4:	bf98      	it	ls
    d7c6:	6025      	strls	r5, [r4, #0]
    d7c8:	e7c4      	b.n	d754 <xTaskCreate+0x154>
			pxCurrentTCB = pxNewTCB;
    d7ca:	6025      	str	r5, [r4, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    d7cc:	6813      	ldr	r3, [r2, #0]
    d7ce:	2b01      	cmp	r3, #1
    d7d0:	d002      	beq.n	d7d8 <xTaskCreate+0x1d8>
		prvAddTaskToReadyList( pxNewTCB );
    d7d2:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    d7d4:	4f15      	ldr	r7, [pc, #84]	; (d82c <xTaskCreate+0x22c>)
    d7d6:	e7bd      	b.n	d754 <xTaskCreate+0x154>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    d7d8:	4817      	ldr	r0, [pc, #92]	; (d838 <xTaskCreate+0x238>)
	}

	vListInitialise( &xDelayedTaskList1 );
    d7da:	f8df 907c 	ldr.w	r9, [pc, #124]	; d858 <xTaskCreate+0x258>
	vListInitialise( &xDelayedTaskList2 );
    d7de:	f8df 807c 	ldr.w	r8, [pc, #124]	; d85c <xTaskCreate+0x25c>
    d7e2:	4f12      	ldr	r7, [pc, #72]	; (d82c <xTaskCreate+0x22c>)
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    d7e4:	f7ff fa36 	bl	cc54 <vListInitialise>
    d7e8:	4814      	ldr	r0, [pc, #80]	; (d83c <xTaskCreate+0x23c>)
    d7ea:	f7ff fa33 	bl	cc54 <vListInitialise>
    d7ee:	4814      	ldr	r0, [pc, #80]	; (d840 <xTaskCreate+0x240>)
    d7f0:	f7ff fa30 	bl	cc54 <vListInitialise>
    d7f4:	4813      	ldr	r0, [pc, #76]	; (d844 <xTaskCreate+0x244>)
    d7f6:	f7ff fa2d 	bl	cc54 <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
    d7fa:	4648      	mov	r0, r9
    d7fc:	f7ff fa2a 	bl	cc54 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    d800:	4640      	mov	r0, r8
    d802:	f7ff fa27 	bl	cc54 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    d806:	4810      	ldr	r0, [pc, #64]	; (d848 <xTaskCreate+0x248>)
    d808:	f7ff fa24 	bl	cc54 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    d80c:	480f      	ldr	r0, [pc, #60]	; (d84c <xTaskCreate+0x24c>)
    d80e:	f7ff fa21 	bl	cc54 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    d812:	4b0f      	ldr	r3, [pc, #60]	; (d850 <xTaskCreate+0x250>)
		prvAddTaskToReadyList( pxNewTCB );
    d814:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
    d816:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    d81a:	4b0e      	ldr	r3, [pc, #56]	; (d854 <xTaskCreate+0x254>)
    d81c:	f8c3 8000 	str.w	r8, [r3]
}
    d820:	e798      	b.n	d754 <xTaskCreate+0x154>
    d822:	bf00      	nop
    d824:	100023bc 	.word	0x100023bc
    d828:	10002360 	.word	0x10002360
    d82c:	10002418 	.word	0x10002418
    d830:	100023c8 	.word	0x100023c8
    d834:	100023cc 	.word	0x100023cc
    d838:	1000236c 	.word	0x1000236c
    d83c:	10002380 	.word	0x10002380
    d840:	10002394 	.word	0x10002394
    d844:	100023a8 	.word	0x100023a8
    d848:	10002404 	.word	0x10002404
    d84c:	1000241c 	.word	0x1000241c
    d850:	10002364 	.word	0x10002364
    d854:	10002368 	.word	0x10002368
    d858:	100023d0 	.word	0x100023d0
    d85c:	100023e4 	.word	0x100023e4

0000d860 <vTaskSuspend>:
	{
    d860:	b570      	push	{r4, r5, r6, lr}
    d862:	4604      	mov	r4, r0
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    d864:	4e2e      	ldr	r6, [pc, #184]	; (d920 <vTaskSuspend+0xc0>)
		taskENTER_CRITICAL();
    d866:	f7fe ff3d 	bl	c6e4 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    d86a:	2c00      	cmp	r4, #0
    d86c:	d03d      	beq.n	d8ea <vTaskSuspend+0x8a>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    d86e:	1d25      	adds	r5, r4, #4
    d870:	4628      	mov	r0, r5
    d872:	f7ff fa27 	bl	ccc4 <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    d876:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    d878:	b11b      	cbz	r3, d882 <vTaskSuspend+0x22>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    d87a:	f104 0018 	add.w	r0, r4, #24
    d87e:	f7ff fa21 	bl	ccc4 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    d882:	4629      	mov	r1, r5
    d884:	4827      	ldr	r0, [pc, #156]	; (d924 <vTaskSuspend+0xc4>)
		if( xSchedulerRunning != pdFALSE )
    d886:	4d28      	ldr	r5, [pc, #160]	; (d928 <vTaskSuspend+0xc8>)
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    d888:	f7ff f9f4 	bl	cc74 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    d88c:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    d890:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    d892:	bf04      	itt	eq
    d894:	2300      	moveq	r3, #0
    d896:	f884 3048 	strbeq.w	r3, [r4, #72]	; 0x48
		taskEXIT_CRITICAL();
    d89a:	f7fe ff3d 	bl	c718 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
    d89e:	682b      	ldr	r3, [r5, #0]
    d8a0:	b9a3      	cbnz	r3, d8cc <vTaskSuspend+0x6c>
		if( pxTCB == pxCurrentTCB )
    d8a2:	6833      	ldr	r3, [r6, #0]
    d8a4:	42a3      	cmp	r3, r4
    d8a6:	d000      	beq.n	d8aa <vTaskSuspend+0x4a>
	}
    d8a8:	bd70      	pop	{r4, r5, r6, pc}
			if( xSchedulerRunning != pdFALSE )
    d8aa:	682b      	ldr	r3, [r5, #0]
    d8ac:	b323      	cbz	r3, d8f8 <vTaskSuspend+0x98>
				configASSERT( uxSchedulerSuspended == 0 );
    d8ae:	4b1f      	ldr	r3, [pc, #124]	; (d92c <vTaskSuspend+0xcc>)
    d8b0:	681b      	ldr	r3, [r3, #0]
    d8b2:	2b00      	cmp	r3, #0
    d8b4:	d12d      	bne.n	d912 <vTaskSuspend+0xb2>
				portYIELD_WITHIN_API();
    d8b6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    d8ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d8be:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    d8c2:	f3bf 8f4f 	dsb	sy
    d8c6:	f3bf 8f6f 	isb	sy
	}
    d8ca:	bd70      	pop	{r4, r5, r6, pc}
			taskENTER_CRITICAL();
    d8cc:	f7fe ff0a 	bl	c6e4 <vPortEnterCritical>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    d8d0:	4b17      	ldr	r3, [pc, #92]	; (d930 <vTaskSuspend+0xd0>)
    d8d2:	681a      	ldr	r2, [r3, #0]
    d8d4:	6812      	ldr	r2, [r2, #0]
    d8d6:	b152      	cbz	r2, d8ee <vTaskSuspend+0x8e>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    d8d8:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    d8da:	4b16      	ldr	r3, [pc, #88]	; (d934 <vTaskSuspend+0xd4>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    d8dc:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    d8de:	68d2      	ldr	r2, [r2, #12]
    d8e0:	6852      	ldr	r2, [r2, #4]
    d8e2:	601a      	str	r2, [r3, #0]
			taskEXIT_CRITICAL();
    d8e4:	f7fe ff18 	bl	c718 <vPortExitCritical>
    d8e8:	e7db      	b.n	d8a2 <vTaskSuspend+0x42>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    d8ea:	6834      	ldr	r4, [r6, #0]
    d8ec:	e7bf      	b.n	d86e <vTaskSuspend+0xe>
		xNextTaskUnblockTime = portMAX_DELAY;
    d8ee:	4b11      	ldr	r3, [pc, #68]	; (d934 <vTaskSuspend+0xd4>)
    d8f0:	f04f 32ff 	mov.w	r2, #4294967295
    d8f4:	601a      	str	r2, [r3, #0]
    d8f6:	e7f5      	b.n	d8e4 <vTaskSuspend+0x84>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    d8f8:	490a      	ldr	r1, [pc, #40]	; (d924 <vTaskSuspend+0xc4>)
    d8fa:	4a0f      	ldr	r2, [pc, #60]	; (d938 <vTaskSuspend+0xd8>)
    d8fc:	6809      	ldr	r1, [r1, #0]
    d8fe:	6812      	ldr	r2, [r2, #0]
    d900:	4291      	cmp	r1, r2
    d902:	d007      	beq.n	d914 <vTaskSuspend+0xb4>
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    d904:	4b09      	ldr	r3, [pc, #36]	; (d92c <vTaskSuspend+0xcc>)
    d906:	681b      	ldr	r3, [r3, #0]
    d908:	b133      	cbz	r3, d918 <vTaskSuspend+0xb8>
		xYieldPending = pdTRUE;
    d90a:	4b0c      	ldr	r3, [pc, #48]	; (d93c <vTaskSuspend+0xdc>)
    d90c:	2201      	movs	r2, #1
    d90e:	601a      	str	r2, [r3, #0]
	}
    d910:	bd70      	pop	{r4, r5, r6, pc}
				configASSERT( uxSchedulerSuspended == 0 );
    d912:	e7fe      	b.n	d912 <vTaskSuspend+0xb2>
					pxCurrentTCB = NULL;
    d914:	6033      	str	r3, [r6, #0]
	}
    d916:	bd70      	pop	{r4, r5, r6, pc}
    d918:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    d91c:	f7ff be10 	b.w	d540 <vTaskSwitchContext.part.0>
    d920:	10002360 	.word	0x10002360
    d924:	1000241c 	.word	0x1000241c
    d928:	10002418 	.word	0x10002418
    d92c:	100023c4 	.word	0x100023c4
    d930:	10002364 	.word	0x10002364
    d934:	100023fc 	.word	0x100023fc
    d938:	100023bc 	.word	0x100023bc
    d93c:	10002434 	.word	0x10002434

0000d940 <vTaskStartScheduler>:
{
    d940:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    d944:	f44f 6080 	mov.w	r0, #1024	; 0x400
    d948:	f001 fdfc 	bl	f544 <pvPortMalloc>
			if( pxStack != NULL )
    d94c:	2800      	cmp	r0, #0
    d94e:	d06d      	beq.n	da2c <vTaskStartScheduler+0xec>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    d950:	4605      	mov	r5, r0
    d952:	204c      	movs	r0, #76	; 0x4c
    d954:	f001 fdf6 	bl	f544 <pvPortMalloc>
				if( pxNewTCB != NULL )
    d958:	4604      	mov	r4, r0
    d95a:	2800      	cmp	r0, #0
    d95c:	d063      	beq.n	da26 <vTaskStartScheduler+0xe6>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    d95e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    d962:	21a5      	movs	r1, #165	; 0xa5
					pxNewTCB->pxStack = pxStack;
    d964:	6305      	str	r5, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    d966:	4628      	mov	r0, r5
    d968:	f001 ff18 	bl	f79c <memset>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d96c:	2500      	movs	r5, #0
    d96e:	4b53      	ldr	r3, [pc, #332]	; (dabc <vTaskStartScheduler+0x17c>)
    d970:	6363      	str	r3, [r4, #52]	; 0x34
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d972:	1d27      	adds	r7, r4, #4
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    d974:	6b26      	ldr	r6, [r4, #48]	; 0x30
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    d976:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d97a:	4638      	mov	r0, r7
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    d97c:	f884 5043 	strb.w	r5, [r4, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
    d980:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    d982:	f7ff f973 	bl	cc6c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    d986:	f104 0018 	add.w	r0, r4, #24
    d98a:	f7ff f96f 	bl	cc6c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d98e:	2304      	movs	r3, #4
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    d990:	f506 707f 	add.w	r0, r6, #1020	; 0x3fc
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d994:	462a      	mov	r2, r5
		pxNewTCB->ulNotifiedValue = 0;
    d996:	6465      	str	r5, [r4, #68]	; 0x44
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d998:	4949      	ldr	r1, [pc, #292]	; (dac0 <vTaskStartScheduler+0x180>)
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    d99a:	61a3      	str	r3, [r4, #24]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    d99c:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    d9a0:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    d9a2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d9a4:	f020 0007 	bic.w	r0, r0, #7
    d9a8:	f7fe fe74 	bl	c694 <pxPortInitialiseStack>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    d9ac:	4b45      	ldr	r3, [pc, #276]	; (dac4 <vTaskStartScheduler+0x184>)
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    d9ae:	6020      	str	r0, [r4, #0]
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    d9b0:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    d9b2:	f7fe fe97 	bl	c6e4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
    d9b6:	4a44      	ldr	r2, [pc, #272]	; (dac8 <vTaskStartScheduler+0x188>)
		if( pxCurrentTCB == NULL )
    d9b8:	4d44      	ldr	r5, [pc, #272]	; (dacc <vTaskStartScheduler+0x18c>)
		uxCurrentNumberOfTasks++;
    d9ba:	6813      	ldr	r3, [r2, #0]
    d9bc:	3301      	adds	r3, #1
    d9be:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
    d9c0:	682b      	ldr	r3, [r5, #0]
    d9c2:	2b00      	cmp	r3, #0
    d9c4:	d04e      	beq.n	da64 <vTaskStartScheduler+0x124>
			if( xSchedulerRunning == pdFALSE )
    d9c6:	4e42      	ldr	r6, [pc, #264]	; (dad0 <vTaskStartScheduler+0x190>)
    d9c8:	6833      	ldr	r3, [r6, #0]
    d9ca:	b383      	cbz	r3, da2e <vTaskStartScheduler+0xee>
		prvAddTaskToReadyList( pxNewTCB );
    d9cc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
		uxTaskNumber++;
    d9ce:	4a41      	ldr	r2, [pc, #260]	; (dad4 <vTaskStartScheduler+0x194>)
		prvAddTaskToReadyList( pxNewTCB );
    d9d0:	4941      	ldr	r1, [pc, #260]	; (dad8 <vTaskStartScheduler+0x198>)
		uxTaskNumber++;
    d9d2:	6813      	ldr	r3, [r2, #0]
    d9d4:	3301      	adds	r3, #1
    d9d6:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
    d9d8:	680b      	ldr	r3, [r1, #0]
    d9da:	4298      	cmp	r0, r3
    d9dc:	d900      	bls.n	d9e0 <vTaskStartScheduler+0xa0>
    d9de:	6008      	str	r0, [r1, #0]
    d9e0:	4b3e      	ldr	r3, [pc, #248]	; (dadc <vTaskStartScheduler+0x19c>)
    d9e2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    d9e6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    d9ea:	4639      	mov	r1, r7
    d9ec:	f7ff f942 	bl	cc74 <vListInsertEnd>
	taskEXIT_CRITICAL();
    d9f0:	f7fe fe92 	bl	c718 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
    d9f4:	6833      	ldr	r3, [r6, #0]
    d9f6:	b173      	cbz	r3, da16 <vTaskStartScheduler+0xd6>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    d9f8:	682a      	ldr	r2, [r5, #0]
    d9fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    d9fc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    d9fe:	429a      	cmp	r2, r3
    da00:	d209      	bcs.n	da16 <vTaskStartScheduler+0xd6>
			taskYIELD_IF_USING_PREEMPTION();
    da02:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    da06:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    da0a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    da0e:	f3bf 8f4f 	dsb	sy
    da12:	f3bf 8f6f 	isb	sy
			xReturn = xTimerCreateTimerTask();
    da16:	f000 fd63 	bl	e4e0 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
    da1a:	2801      	cmp	r0, #1
    da1c:	d00e      	beq.n	da3c <vTaskStartScheduler+0xfc>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    da1e:	3001      	adds	r0, #1
    da20:	d004      	beq.n	da2c <vTaskStartScheduler+0xec>
}
    da22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
    da26:	4628      	mov	r0, r5
    da28:	f001 fdea 	bl	f600 <vPortFree>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    da2c:	e7fe      	b.n	da2c <vTaskStartScheduler+0xec>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    da2e:	682b      	ldr	r3, [r5, #0]
    da30:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    da32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    da34:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
    da36:	bf98      	it	ls
    da38:	602c      	strls	r4, [r5, #0]
    da3a:	e7c8      	b.n	d9ce <vTaskStartScheduler+0x8e>
	__asm volatile
    da3c:	f04f 0380 	mov.w	r3, #128	; 0x80
    da40:	f383 8811 	msr	BASEPRI, r3
    da44:	f3bf 8f6f 	isb	sy
    da48:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    da4c:	4a24      	ldr	r2, [pc, #144]	; (dae0 <vTaskStartScheduler+0x1a0>)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    da4e:	4b25      	ldr	r3, [pc, #148]	; (dae4 <vTaskStartScheduler+0x1a4>)
		xNextTaskUnblockTime = portMAX_DELAY;
    da50:	f04f 31ff 	mov.w	r1, #4294967295
    da54:	6011      	str	r1, [r2, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    da56:	2200      	movs	r2, #0
		xSchedulerRunning = pdTRUE;
    da58:	6030      	str	r0, [r6, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    da5a:	601a      	str	r2, [r3, #0]
}
    da5c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		if( xPortStartScheduler() != pdFALSE )
    da60:	f7fe bfd0 	b.w	ca04 <xPortStartScheduler>
			pxCurrentTCB = pxNewTCB;
    da64:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    da66:	6813      	ldr	r3, [r2, #0]
    da68:	2b01      	cmp	r3, #1
    da6a:	d002      	beq.n	da72 <vTaskStartScheduler+0x132>
		prvAddTaskToReadyList( pxNewTCB );
    da6c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    da6e:	4e18      	ldr	r6, [pc, #96]	; (dad0 <vTaskStartScheduler+0x190>)
    da70:	e7ad      	b.n	d9ce <vTaskStartScheduler+0x8e>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    da72:	481a      	ldr	r0, [pc, #104]	; (dadc <vTaskStartScheduler+0x19c>)
	vListInitialise( &xDelayedTaskList1 );
    da74:	f8df 808c 	ldr.w	r8, [pc, #140]	; db04 <vTaskStartScheduler+0x1c4>
	vListInitialise( &xDelayedTaskList2 );
    da78:	f8df 908c 	ldr.w	r9, [pc, #140]	; db08 <vTaskStartScheduler+0x1c8>
    da7c:	4e14      	ldr	r6, [pc, #80]	; (dad0 <vTaskStartScheduler+0x190>)
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    da7e:	f7ff f8e9 	bl	cc54 <vListInitialise>
    da82:	4819      	ldr	r0, [pc, #100]	; (dae8 <vTaskStartScheduler+0x1a8>)
    da84:	f7ff f8e6 	bl	cc54 <vListInitialise>
    da88:	4818      	ldr	r0, [pc, #96]	; (daec <vTaskStartScheduler+0x1ac>)
    da8a:	f7ff f8e3 	bl	cc54 <vListInitialise>
    da8e:	4818      	ldr	r0, [pc, #96]	; (daf0 <vTaskStartScheduler+0x1b0>)
    da90:	f7ff f8e0 	bl	cc54 <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
    da94:	4640      	mov	r0, r8
    da96:	f7ff f8dd 	bl	cc54 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    da9a:	4648      	mov	r0, r9
    da9c:	f7ff f8da 	bl	cc54 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    daa0:	4814      	ldr	r0, [pc, #80]	; (daf4 <vTaskStartScheduler+0x1b4>)
    daa2:	f7ff f8d7 	bl	cc54 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
    daa6:	4814      	ldr	r0, [pc, #80]	; (daf8 <vTaskStartScheduler+0x1b8>)
    daa8:	f7ff f8d4 	bl	cc54 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
    daac:	4a13      	ldr	r2, [pc, #76]	; (dafc <vTaskStartScheduler+0x1bc>)
		prvAddTaskToReadyList( pxNewTCB );
    daae:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
    dab0:	f8c2 8000 	str.w	r8, [r2]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    dab4:	4a12      	ldr	r2, [pc, #72]	; (db00 <vTaskStartScheduler+0x1c0>)
    dab6:	f8c2 9000 	str.w	r9, [r2]
}
    daba:	e788      	b.n	d9ce <vTaskStartScheduler+0x8e>
    dabc:	454c4449 	.word	0x454c4449
    dac0:	0000ddad 	.word	0x0000ddad
    dac4:	100023f8 	.word	0x100023f8
    dac8:	100023bc 	.word	0x100023bc
    dacc:	10002360 	.word	0x10002360
    dad0:	10002418 	.word	0x10002418
    dad4:	100023c8 	.word	0x100023c8
    dad8:	100023cc 	.word	0x100023cc
    dadc:	1000236c 	.word	0x1000236c
    dae0:	100023fc 	.word	0x100023fc
    dae4:	10002430 	.word	0x10002430
    dae8:	10002380 	.word	0x10002380
    daec:	10002394 	.word	0x10002394
    daf0:	100023a8 	.word	0x100023a8
    daf4:	10002404 	.word	0x10002404
    daf8:	1000241c 	.word	0x1000241c
    dafc:	10002364 	.word	0x10002364
    db00:	10002368 	.word	0x10002368
    db04:	100023d0 	.word	0x100023d0
    db08:	100023e4 	.word	0x100023e4

0000db0c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    db0c:	4a02      	ldr	r2, [pc, #8]	; (db18 <vTaskSuspendAll+0xc>)
    db0e:	6813      	ldr	r3, [r2, #0]
    db10:	3301      	adds	r3, #1
    db12:	6013      	str	r3, [r2, #0]
}
    db14:	4770      	bx	lr
    db16:	bf00      	nop
    db18:	100023c4 	.word	0x100023c4

0000db1c <xTaskGetTickCount>:
		xTicks = xTickCount;
    db1c:	4b01      	ldr	r3, [pc, #4]	; (db24 <xTaskGetTickCount+0x8>)
    db1e:	6818      	ldr	r0, [r3, #0]
}
    db20:	4770      	bx	lr
    db22:	bf00      	nop
    db24:	10002430 	.word	0x10002430

0000db28 <vTaskStepTick>:
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
    db28:	4a05      	ldr	r2, [pc, #20]	; (db40 <vTaskStepTick+0x18>)
    db2a:	4906      	ldr	r1, [pc, #24]	; (db44 <vTaskStepTick+0x1c>)
    db2c:	6813      	ldr	r3, [r2, #0]
    db2e:	6809      	ldr	r1, [r1, #0]
    db30:	4403      	add	r3, r0
    db32:	428b      	cmp	r3, r1
    db34:	d803      	bhi.n	db3e <vTaskStepTick+0x16>
		xTickCount += xTicksToJump;
    db36:	6813      	ldr	r3, [r2, #0]
    db38:	4418      	add	r0, r3
    db3a:	6010      	str	r0, [r2, #0]
	}
    db3c:	4770      	bx	lr
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
    db3e:	e7fe      	b.n	db3e <vTaskStepTick+0x16>
    db40:	10002430 	.word	0x10002430
    db44:	100023fc 	.word	0x100023fc

0000db48 <xTaskIncrementTick>:
{
    db48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    db4c:	4b40      	ldr	r3, [pc, #256]	; (dc50 <xTaskIncrementTick+0x108>)
    db4e:	681b      	ldr	r3, [r3, #0]
{
    db50:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    db52:	2b00      	cmp	r3, #0
    db54:	d146      	bne.n	dbe4 <xTaskIncrementTick+0x9c>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    db56:	4b3f      	ldr	r3, [pc, #252]	; (dc54 <xTaskIncrementTick+0x10c>)
    db58:	681e      	ldr	r6, [r3, #0]
    db5a:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    db5c:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    db5e:	2e00      	cmp	r6, #0
    db60:	d04e      	beq.n	dc00 <xTaskIncrementTick+0xb8>
    db62:	f8df b108 	ldr.w	fp, [pc, #264]	; dc6c <xTaskIncrementTick+0x124>
		if( xConstTickCount >= xNextTaskUnblockTime )
    db66:	f8db 3000 	ldr.w	r3, [fp]
    db6a:	42b3      	cmp	r3, r6
    db6c:	d860      	bhi.n	dc30 <xTaskIncrementTick+0xe8>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    db6e:	4f3a      	ldr	r7, [pc, #232]	; (dc58 <xTaskIncrementTick+0x110>)
    db70:	683b      	ldr	r3, [r7, #0]
    db72:	681d      	ldr	r5, [r3, #0]
    db74:	2d00      	cmp	r5, #0
    db76:	d05d      	beq.n	dc34 <xTaskIncrementTick+0xec>
					prvAddTaskToReadyList( pxTCB );
    db78:	f8df 80f4 	ldr.w	r8, [pc, #244]	; dc70 <xTaskIncrementTick+0x128>
    db7c:	f8df a0f4 	ldr.w	sl, [pc, #244]	; dc74 <xTaskIncrementTick+0x12c>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    db80:	f8df 90f4 	ldr.w	r9, [pc, #244]	; dc78 <xTaskIncrementTick+0x130>
BaseType_t xSwitchRequired = pdFALSE;
    db84:	2500      	movs	r5, #0
    db86:	e022      	b.n	dbce <xTaskIncrementTick+0x86>
    db88:	9101      	str	r1, [sp, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    db8a:	f7ff f89b 	bl	ccc4 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    db8e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    db90:	9901      	ldr	r1, [sp, #4]
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    db92:	f104 0018 	add.w	r0, r4, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    db96:	b113      	cbz	r3, db9e <xTaskIncrementTick+0x56>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    db98:	f7ff f894 	bl	ccc4 <uxListRemove>
    db9c:	9901      	ldr	r1, [sp, #4]
					prvAddTaskToReadyList( pxTCB );
    db9e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    dba0:	f8d8 3000 	ldr.w	r3, [r8]
    dba4:	4298      	cmp	r0, r3
    dba6:	bf88      	it	hi
    dba8:	f8c8 0000 	strhi.w	r0, [r8]
    dbac:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    dbb0:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
    dbb4:	f7ff f85e 	bl	cc74 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    dbb8:	f8d9 3000 	ldr.w	r3, [r9]
    dbbc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    dbbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
    dbc0:	429a      	cmp	r2, r3
    dbc2:	bf28      	it	cs
    dbc4:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    dbc6:	683b      	ldr	r3, [r7, #0]
    dbc8:	681b      	ldr	r3, [r3, #0]
    dbca:	2b00      	cmp	r3, #0
    dbcc:	d032      	beq.n	dc34 <xTaskIncrementTick+0xec>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    dbce:	683b      	ldr	r3, [r7, #0]
    dbd0:	68db      	ldr	r3, [r3, #12]
    dbd2:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    dbd4:	6863      	ldr	r3, [r4, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    dbd6:	1d21      	adds	r1, r4, #4
					if( xConstTickCount < xItemValue )
    dbd8:	429e      	cmp	r6, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    dbda:	4608      	mov	r0, r1
					if( xConstTickCount < xItemValue )
    dbdc:	d2d4      	bcs.n	db88 <xTaskIncrementTick+0x40>
						xNextTaskUnblockTime = xItemValue;
    dbde:	f8cb 3000 	str.w	r3, [fp]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    dbe2:	e004      	b.n	dbee <xTaskIncrementTick+0xa6>
		++uxPendedTicks;
    dbe4:	4a1d      	ldr	r2, [pc, #116]	; (dc5c <xTaskIncrementTick+0x114>)
    dbe6:	6813      	ldr	r3, [r2, #0]
    dbe8:	3301      	adds	r3, #1
BaseType_t xSwitchRequired = pdFALSE;
    dbea:	2500      	movs	r5, #0
		++uxPendedTicks;
    dbec:	6013      	str	r3, [r2, #0]
		if( xYieldPending != pdFALSE )
    dbee:	4b1c      	ldr	r3, [pc, #112]	; (dc60 <xTaskIncrementTick+0x118>)
    dbf0:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
    dbf2:	2b00      	cmp	r3, #0
}
    dbf4:	bf0c      	ite	eq
    dbf6:	4628      	moveq	r0, r5
    dbf8:	2001      	movne	r0, #1
    dbfa:	b003      	add	sp, #12
    dbfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
    dc00:	4b15      	ldr	r3, [pc, #84]	; (dc58 <xTaskIncrementTick+0x110>)
    dc02:	681a      	ldr	r2, [r3, #0]
    dc04:	6812      	ldr	r2, [r2, #0]
    dc06:	b992      	cbnz	r2, dc2e <xTaskIncrementTick+0xe6>
    dc08:	4a16      	ldr	r2, [pc, #88]	; (dc64 <xTaskIncrementTick+0x11c>)
    dc0a:	6818      	ldr	r0, [r3, #0]
    dc0c:	6811      	ldr	r1, [r2, #0]
    dc0e:	6019      	str	r1, [r3, #0]
    dc10:	4915      	ldr	r1, [pc, #84]	; (dc68 <xTaskIncrementTick+0x120>)
    dc12:	6010      	str	r0, [r2, #0]
    dc14:	680a      	ldr	r2, [r1, #0]
    dc16:	3201      	adds	r2, #1
    dc18:	600a      	str	r2, [r1, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    dc1a:	681a      	ldr	r2, [r3, #0]
    dc1c:	6812      	ldr	r2, [r2, #0]
    dc1e:	b972      	cbnz	r2, dc3e <xTaskIncrementTick+0xf6>
		xNextTaskUnblockTime = portMAX_DELAY;
    dc20:	f8df b048 	ldr.w	fp, [pc, #72]	; dc6c <xTaskIncrementTick+0x124>
    dc24:	f04f 33ff 	mov.w	r3, #4294967295
    dc28:	f8cb 3000 	str.w	r3, [fp]
    dc2c:	e79b      	b.n	db66 <xTaskIncrementTick+0x1e>
			taskSWITCH_DELAYED_LISTS();
    dc2e:	e7fe      	b.n	dc2e <xTaskIncrementTick+0xe6>
BaseType_t xSwitchRequired = pdFALSE;
    dc30:	2500      	movs	r5, #0
    dc32:	e7dc      	b.n	dbee <xTaskIncrementTick+0xa6>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    dc34:	f04f 33ff 	mov.w	r3, #4294967295
    dc38:	f8cb 3000 	str.w	r3, [fp]
					break;
    dc3c:	e7d7      	b.n	dbee <xTaskIncrementTick+0xa6>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    dc3e:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    dc40:	f8df b028 	ldr.w	fp, [pc, #40]	; dc6c <xTaskIncrementTick+0x124>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    dc44:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    dc46:	68db      	ldr	r3, [r3, #12]
    dc48:	685b      	ldr	r3, [r3, #4]
    dc4a:	f8cb 3000 	str.w	r3, [fp]
	}
}
    dc4e:	e78a      	b.n	db66 <xTaskIncrementTick+0x1e>
    dc50:	100023c4 	.word	0x100023c4
    dc54:	10002430 	.word	0x10002430
    dc58:	10002364 	.word	0x10002364
    dc5c:	100023c0 	.word	0x100023c0
    dc60:	10002434 	.word	0x10002434
    dc64:	10002368 	.word	0x10002368
    dc68:	10002400 	.word	0x10002400
    dc6c:	100023fc 	.word	0x100023fc
    dc70:	100023cc 	.word	0x100023cc
    dc74:	1000236c 	.word	0x1000236c
    dc78:	10002360 	.word	0x10002360

0000dc7c <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
    dc7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dc80:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
    dc82:	f7fe fd2f 	bl	c6e4 <vPortEnterCritical>
		--uxSchedulerSuspended;
    dc86:	4b3b      	ldr	r3, [pc, #236]	; (dd74 <xTaskResumeAll.part.0+0xf8>)
    dc88:	681a      	ldr	r2, [r3, #0]
    dc8a:	3a01      	subs	r2, #1
    dc8c:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    dc8e:	681b      	ldr	r3, [r3, #0]
    dc90:	2b00      	cmp	r3, #0
    dc92:	d156      	bne.n	dd42 <xTaskResumeAll.part.0+0xc6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    dc94:	4b38      	ldr	r3, [pc, #224]	; (dd78 <xTaskResumeAll.part.0+0xfc>)
    dc96:	681b      	ldr	r3, [r3, #0]
    dc98:	2b00      	cmp	r3, #0
    dc9a:	d052      	beq.n	dd42 <xTaskResumeAll.part.0+0xc6>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    dc9c:	4d37      	ldr	r5, [pc, #220]	; (dd7c <xTaskResumeAll.part.0+0x100>)
    dc9e:	682b      	ldr	r3, [r5, #0]
    dca0:	2b00      	cmp	r3, #0
    dca2:	d063      	beq.n	dd6c <xTaskResumeAll.part.0+0xf0>
    dca4:	4e36      	ldr	r6, [pc, #216]	; (dd80 <xTaskResumeAll.part.0+0x104>)
    dca6:	f8df 80ec 	ldr.w	r8, [pc, #236]	; dd94 <xTaskResumeAll.part.0+0x118>
    dcaa:	4f36      	ldr	r7, [pc, #216]	; (dd84 <xTaskResumeAll.part.0+0x108>)
    dcac:	f8df 90e8 	ldr.w	r9, [pc, #232]	; dd98 <xTaskResumeAll.part.0+0x11c>
						xYieldPending = pdTRUE;
    dcb0:	f04f 0a01 	mov.w	sl, #1
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    dcb4:	68eb      	ldr	r3, [r5, #12]
    dcb6:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    dcb8:	f104 0b04 	add.w	fp, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    dcbc:	f104 0018 	add.w	r0, r4, #24
    dcc0:	f7ff f800 	bl	ccc4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    dcc4:	4658      	mov	r0, fp
    dcc6:	f7fe fffd 	bl	ccc4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    dcca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dccc:	6832      	ldr	r2, [r6, #0]
    dcce:	eb03 0083 	add.w	r0, r3, r3, lsl #2
    dcd2:	4293      	cmp	r3, r2
    dcd4:	4659      	mov	r1, fp
    dcd6:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    dcda:	bf88      	it	hi
    dcdc:	6033      	strhi	r3, [r6, #0]
    dcde:	f7fe ffc9 	bl	cc74 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    dce2:	683b      	ldr	r3, [r7, #0]
    dce4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    dce6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    dce8:	429a      	cmp	r2, r3
    dcea:	d332      	bcc.n	dd52 <xTaskResumeAll.part.0+0xd6>
						xYieldPending = pdTRUE;
    dcec:	f8c9 a000 	str.w	sl, [r9]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    dcf0:	682b      	ldr	r3, [r5, #0]
    dcf2:	2b00      	cmp	r3, #0
    dcf4:	d1de      	bne.n	dcb4 <xTaskResumeAll.part.0+0x38>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    dcf6:	4b24      	ldr	r3, [pc, #144]	; (dd88 <xTaskResumeAll.part.0+0x10c>)
    dcf8:	681a      	ldr	r2, [r3, #0]
    dcfa:	6812      	ldr	r2, [r2, #0]
    dcfc:	2a00      	cmp	r2, #0
    dcfe:	d030      	beq.n	dd62 <xTaskResumeAll.part.0+0xe6>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    dd00:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    dd02:	4b22      	ldr	r3, [pc, #136]	; (dd8c <xTaskResumeAll.part.0+0x110>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    dd04:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    dd06:	68d2      	ldr	r2, [r2, #12]
    dd08:	6852      	ldr	r2, [r2, #4]
    dd0a:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    dd0c:	4e20      	ldr	r6, [pc, #128]	; (dd90 <xTaskResumeAll.part.0+0x114>)
    dd0e:	6834      	ldr	r4, [r6, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    dd10:	b144      	cbz	r4, dd24 <xTaskResumeAll.part.0+0xa8>
								xYieldPending = pdTRUE;
    dd12:	2501      	movs	r5, #1
							if( xTaskIncrementTick() != pdFALSE )
    dd14:	f7ff ff18 	bl	db48 <xTaskIncrementTick>
    dd18:	b108      	cbz	r0, dd1e <xTaskResumeAll.part.0+0xa2>
								xYieldPending = pdTRUE;
    dd1a:	f8c9 5000 	str.w	r5, [r9]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    dd1e:	3c01      	subs	r4, #1
    dd20:	d1f8      	bne.n	dd14 <xTaskResumeAll.part.0+0x98>
						uxPendedTicks = 0;
    dd22:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
    dd24:	f8d9 3000 	ldr.w	r3, [r9]
    dd28:	b15b      	cbz	r3, dd42 <xTaskResumeAll.part.0+0xc6>
					taskYIELD_IF_USING_PREEMPTION();
    dd2a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    dd2e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    dd32:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    dd36:	f3bf 8f4f 	dsb	sy
    dd3a:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
    dd3e:	2001      	movs	r0, #1
    dd40:	e000      	b.n	dd44 <xTaskResumeAll.part.0+0xc8>
BaseType_t xAlreadyYielded = pdFALSE;
    dd42:	2000      	movs	r0, #0
    dd44:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
    dd46:	f7fe fce7 	bl	c718 <vPortExitCritical>
}
    dd4a:	9801      	ldr	r0, [sp, #4]
    dd4c:	b003      	add	sp, #12
    dd4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    dd52:	682b      	ldr	r3, [r5, #0]
    dd54:	2b00      	cmp	r3, #0
    dd56:	d1ad      	bne.n	dcb4 <xTaskResumeAll.part.0+0x38>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    dd58:	4b0b      	ldr	r3, [pc, #44]	; (dd88 <xTaskResumeAll.part.0+0x10c>)
    dd5a:	681a      	ldr	r2, [r3, #0]
    dd5c:	6812      	ldr	r2, [r2, #0]
    dd5e:	2a00      	cmp	r2, #0
    dd60:	d1ce      	bne.n	dd00 <xTaskResumeAll.part.0+0x84>
		xNextTaskUnblockTime = portMAX_DELAY;
    dd62:	4b0a      	ldr	r3, [pc, #40]	; (dd8c <xTaskResumeAll.part.0+0x110>)
    dd64:	f04f 32ff 	mov.w	r2, #4294967295
    dd68:	601a      	str	r2, [r3, #0]
    dd6a:	e7cf      	b.n	dd0c <xTaskResumeAll.part.0+0x90>
    dd6c:	f8df 9028 	ldr.w	r9, [pc, #40]	; dd98 <xTaskResumeAll.part.0+0x11c>
    dd70:	e7cc      	b.n	dd0c <xTaskResumeAll.part.0+0x90>
    dd72:	bf00      	nop
    dd74:	100023c4 	.word	0x100023c4
    dd78:	100023bc 	.word	0x100023bc
    dd7c:	10002404 	.word	0x10002404
    dd80:	100023cc 	.word	0x100023cc
    dd84:	10002360 	.word	0x10002360
    dd88:	10002364 	.word	0x10002364
    dd8c:	100023fc 	.word	0x100023fc
    dd90:	100023c0 	.word	0x100023c0
    dd94:	1000236c 	.word	0x1000236c
    dd98:	10002434 	.word	0x10002434

0000dd9c <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
    dd9c:	4b02      	ldr	r3, [pc, #8]	; (dda8 <xTaskResumeAll+0xc>)
    dd9e:	681b      	ldr	r3, [r3, #0]
    dda0:	b903      	cbnz	r3, dda4 <xTaskResumeAll+0x8>
    dda2:	e7fe      	b.n	dda2 <xTaskResumeAll+0x6>
    dda4:	f7ff bf6a 	b.w	dc7c <xTaskResumeAll.part.0>
    dda8:	100023c4 	.word	0x100023c4

0000ddac <prvIdleTask>:
{
    ddac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ddb0:	4c2b      	ldr	r4, [pc, #172]	; (de60 <prvIdleTask+0xb4>)
    ddb2:	4e2c      	ldr	r6, [pc, #176]	; (de64 <prvIdleTask+0xb8>)
    ddb4:	4d2c      	ldr	r5, [pc, #176]	; (de68 <prvIdleTask+0xbc>)
    ddb6:	f8df b0b4 	ldr.w	fp, [pc, #180]	; de6c <prvIdleTask+0xc0>
    ddba:	f8df a0b4 	ldr.w	sl, [pc, #180]	; de70 <prvIdleTask+0xc4>
    ddbe:	f8df 90b4 	ldr.w	r9, [pc, #180]	; de74 <prvIdleTask+0xc8>
				taskYIELD();
    ddc2:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    ddc6:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    ddca:	6823      	ldr	r3, [r4, #0]
    ddcc:	2b01      	cmp	r3, #1
    ddce:	d905      	bls.n	dddc <prvIdleTask+0x30>
				taskYIELD();
    ddd0:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04
    ddd4:	f3bf 8f4f 	dsb	sy
    ddd8:	f3bf 8f6f 	isb	sy
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    dddc:	6833      	ldr	r3, [r6, #0]
    ddde:	bb13      	cbnz	r3, de26 <prvIdleTask+0x7a>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    dde0:	682b      	ldr	r3, [r5, #0]
    dde2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    dde4:	2b00      	cmp	r3, #0
    dde6:	d1f0      	bne.n	ddca <prvIdleTask+0x1e>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    dde8:	6823      	ldr	r3, [r4, #0]
    ddea:	2b01      	cmp	r3, #1
    ddec:	d8ed      	bhi.n	ddca <prvIdleTask+0x1e>
			xReturn = xNextTaskUnblockTime - xTickCount;
    ddee:	f8db 3000 	ldr.w	r3, [fp]
    ddf2:	f8da 2000 	ldr.w	r2, [sl]
    ddf6:	1a9b      	subs	r3, r3, r2
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    ddf8:	2b01      	cmp	r3, #1
    ddfa:	d9e6      	bls.n	ddca <prvIdleTask+0x1e>
	++uxSchedulerSuspended;
    ddfc:	f8d9 3000 	ldr.w	r3, [r9]
    de00:	3301      	adds	r3, #1
    de02:	f8c9 3000 	str.w	r3, [r9]
					configASSERT( xNextTaskUnblockTime >= xTickCount );
    de06:	f8db 2000 	ldr.w	r2, [fp]
    de0a:	f8da 3000 	ldr.w	r3, [sl]
    de0e:	429a      	cmp	r2, r3
    de10:	d308      	bcc.n	de24 <prvIdleTask+0x78>
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    de12:	6833      	ldr	r3, [r6, #0]
    de14:	b16b      	cbz	r3, de32 <prvIdleTask+0x86>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    de16:	682b      	ldr	r3, [r5, #0]
    de18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    de1a:	b1f3      	cbz	r3, de5a <prvIdleTask+0xae>
	configASSERT( uxSchedulerSuspended );
    de1c:	f8d9 3000 	ldr.w	r3, [r9]
    de20:	b9c3      	cbnz	r3, de54 <prvIdleTask+0xa8>
    de22:	e7fe      	b.n	de22 <prvIdleTask+0x76>
					configASSERT( xNextTaskUnblockTime >= xTickCount );
    de24:	e7fe      	b.n	de24 <prvIdleTask+0x78>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    de26:	682b      	ldr	r3, [r5, #0]
    de28:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    de2a:	2b00      	cmp	r3, #0
    de2c:	d1cd      	bne.n	ddca <prvIdleTask+0x1e>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    de2e:	6823      	ldr	r3, [r4, #0]
    de30:	e7cb      	b.n	ddca <prvIdleTask+0x1e>
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    de32:	682b      	ldr	r3, [r5, #0]
    de34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    de36:	2b00      	cmp	r3, #0
    de38:	d1f0      	bne.n	de1c <prvIdleTask+0x70>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    de3a:	6823      	ldr	r3, [r4, #0]
    de3c:	2b01      	cmp	r3, #1
    de3e:	d8ed      	bhi.n	de1c <prvIdleTask+0x70>
			xReturn = xNextTaskUnblockTime - xTickCount;
    de40:	f8db 0000 	ldr.w	r0, [fp]
    de44:	f8da 3000 	ldr.w	r3, [sl]
    de48:	1ac0      	subs	r0, r0, r3
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    de4a:	2801      	cmp	r0, #1
    de4c:	d9e6      	bls.n	de1c <prvIdleTask+0x70>
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
    de4e:	f7fe fcd5 	bl	c7fc <vPortSuppressTicksAndSleep>
						traceLOW_POWER_IDLE_END();
    de52:	e7e3      	b.n	de1c <prvIdleTask+0x70>
    de54:	f7ff ff12 	bl	dc7c <xTaskResumeAll.part.0>
    de58:	e7b7      	b.n	ddca <prvIdleTask+0x1e>
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    de5a:	6823      	ldr	r3, [r4, #0]
    de5c:	e7de      	b.n	de1c <prvIdleTask+0x70>
    de5e:	bf00      	nop
    de60:	1000236c 	.word	0x1000236c
    de64:	100023cc 	.word	0x100023cc
    de68:	10002360 	.word	0x10002360
    de6c:	100023fc 	.word	0x100023fc
    de70:	10002430 	.word	0x10002430
    de74:	100023c4 	.word	0x100023c4

0000de78 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    de78:	4b04      	ldr	r3, [pc, #16]	; (de8c <vTaskSwitchContext+0x14>)
    de7a:	681b      	ldr	r3, [r3, #0]
    de7c:	b11b      	cbz	r3, de86 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
    de7e:	4b04      	ldr	r3, [pc, #16]	; (de90 <vTaskSwitchContext+0x18>)
    de80:	2201      	movs	r2, #1
    de82:	601a      	str	r2, [r3, #0]
}
    de84:	4770      	bx	lr
    de86:	f7ff bb5b 	b.w	d540 <vTaskSwitchContext.part.0>
    de8a:	bf00      	nop
    de8c:	100023c4 	.word	0x100023c4
    de90:	10002434 	.word	0x10002434

0000de94 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
    de94:	b1d0      	cbz	r0, decc <vTaskPlaceOnEventList+0x38>
{
    de96:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    de98:	4d16      	ldr	r5, [pc, #88]	; (def4 <vTaskPlaceOnEventList+0x60>)
    de9a:	460c      	mov	r4, r1
    de9c:	6829      	ldr	r1, [r5, #0]
    de9e:	3118      	adds	r1, #24
    dea0:	f7fe fef8 	bl	cc94 <vListInsert>


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    dea4:	4b14      	ldr	r3, [pc, #80]	; (def8 <vTaskPlaceOnEventList+0x64>)
    dea6:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    dea8:	6828      	ldr	r0, [r5, #0]
    deaa:	3004      	adds	r0, #4
    deac:	f7fe ff0a 	bl	ccc4 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    deb0:	1c63      	adds	r3, r4, #1
    deb2:	d00c      	beq.n	dece <vTaskPlaceOnEventList+0x3a>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    deb4:	682b      	ldr	r3, [r5, #0]
    deb6:	19a4      	adds	r4, r4, r6
    deb8:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    deba:	d30f      	bcc.n	dedc <vTaskPlaceOnEventList+0x48>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    debc:	4b0f      	ldr	r3, [pc, #60]	; (defc <vTaskPlaceOnEventList+0x68>)
    debe:	6818      	ldr	r0, [r3, #0]
    dec0:	6829      	ldr	r1, [r5, #0]
}
    dec2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dec6:	3104      	adds	r1, #4
    dec8:	f7fe bee4 	b.w	cc94 <vListInsert>
	configASSERT( pxEventList );
    decc:	e7fe      	b.n	decc <vTaskPlaceOnEventList+0x38>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dece:	6829      	ldr	r1, [r5, #0]
    ded0:	480b      	ldr	r0, [pc, #44]	; (df00 <vTaskPlaceOnEventList+0x6c>)
}
    ded2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    ded6:	3104      	adds	r1, #4
    ded8:	f7fe becc 	b.w	cc74 <vListInsertEnd>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dedc:	4b09      	ldr	r3, [pc, #36]	; (df04 <vTaskPlaceOnEventList+0x70>)
    dede:	6818      	ldr	r0, [r3, #0]
    dee0:	6829      	ldr	r1, [r5, #0]
    dee2:	3104      	adds	r1, #4
    dee4:	f7fe fed6 	bl	cc94 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    dee8:	4b07      	ldr	r3, [pc, #28]	; (df08 <vTaskPlaceOnEventList+0x74>)
    deea:	681a      	ldr	r2, [r3, #0]
    deec:	4294      	cmp	r4, r2
				{
					xNextTaskUnblockTime = xTimeToWake;
    deee:	bf38      	it	cc
    def0:	601c      	strcc	r4, [r3, #0]
}
    def2:	bd70      	pop	{r4, r5, r6, pc}
    def4:	10002360 	.word	0x10002360
    def8:	10002430 	.word	0x10002430
    defc:	10002368 	.word	0x10002368
    df00:	1000241c 	.word	0x1000241c
    df04:	10002364 	.word	0x10002364
    df08:	100023fc 	.word	0x100023fc

0000df0c <vTaskPlaceOnUnorderedEventList>:
	configASSERT( pxEventList );
    df0c:	b118      	cbz	r0, df16 <vTaskPlaceOnUnorderedEventList+0xa>
	configASSERT( uxSchedulerSuspended != 0 );
    df0e:	4b1b      	ldr	r3, [pc, #108]	; (df7c <vTaskPlaceOnUnorderedEventList+0x70>)
    df10:	681b      	ldr	r3, [r3, #0]
    df12:	b90b      	cbnz	r3, df18 <vTaskPlaceOnUnorderedEventList+0xc>
    df14:	e7fe      	b.n	df14 <vTaskPlaceOnUnorderedEventList+0x8>
	configASSERT( pxEventList );
    df16:	e7fe      	b.n	df16 <vTaskPlaceOnUnorderedEventList+0xa>
{
    df18:	b570      	push	{r4, r5, r6, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    df1a:	4d19      	ldr	r5, [pc, #100]	; (df80 <vTaskPlaceOnUnorderedEventList+0x74>)
    df1c:	682b      	ldr	r3, [r5, #0]
    df1e:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    df22:	6199      	str	r1, [r3, #24]
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    df24:	6829      	ldr	r1, [r5, #0]
    df26:	3118      	adds	r1, #24
    df28:	4614      	mov	r4, r2
    df2a:	f7fe fea3 	bl	cc74 <vListInsertEnd>
const TickType_t xConstTickCount = xTickCount;
    df2e:	4b15      	ldr	r3, [pc, #84]	; (df84 <vTaskPlaceOnUnorderedEventList+0x78>)
    df30:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    df32:	6828      	ldr	r0, [r5, #0]
    df34:	3004      	adds	r0, #4
    df36:	f7fe fec5 	bl	ccc4 <uxListRemove>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    df3a:	1c63      	adds	r3, r4, #1
    df3c:	d00b      	beq.n	df56 <vTaskPlaceOnUnorderedEventList+0x4a>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    df3e:	682b      	ldr	r3, [r5, #0]
    df40:	19a4      	adds	r4, r4, r6
    df42:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
    df44:	d30e      	bcc.n	df64 <vTaskPlaceOnUnorderedEventList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    df46:	4b10      	ldr	r3, [pc, #64]	; (df88 <vTaskPlaceOnUnorderedEventList+0x7c>)
    df48:	6818      	ldr	r0, [r3, #0]
    df4a:	6829      	ldr	r1, [r5, #0]
}
    df4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    df50:	3104      	adds	r1, #4
    df52:	f7fe be9f 	b.w	cc94 <vListInsert>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    df56:	6829      	ldr	r1, [r5, #0]
    df58:	480c      	ldr	r0, [pc, #48]	; (df8c <vTaskPlaceOnUnorderedEventList+0x80>)
}
    df5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    df5e:	3104      	adds	r1, #4
    df60:	f7fe be88 	b.w	cc74 <vListInsertEnd>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    df64:	4b0a      	ldr	r3, [pc, #40]	; (df90 <vTaskPlaceOnUnorderedEventList+0x84>)
    df66:	6818      	ldr	r0, [r3, #0]
    df68:	6829      	ldr	r1, [r5, #0]
    df6a:	3104      	adds	r1, #4
    df6c:	f7fe fe92 	bl	cc94 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
    df70:	4b08      	ldr	r3, [pc, #32]	; (df94 <vTaskPlaceOnUnorderedEventList+0x88>)
    df72:	681a      	ldr	r2, [r3, #0]
    df74:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
    df76:	bf38      	it	cc
    df78:	601c      	strcc	r4, [r3, #0]
}
    df7a:	bd70      	pop	{r4, r5, r6, pc}
    df7c:	100023c4 	.word	0x100023c4
    df80:	10002360 	.word	0x10002360
    df84:	10002430 	.word	0x10002430
    df88:	10002368 	.word	0x10002368
    df8c:	1000241c 	.word	0x1000241c
    df90:	10002364 	.word	0x10002364
    df94:	100023fc 	.word	0x100023fc

0000df98 <vTaskPlaceOnEventListRestricted>:
		configASSERT( pxEventList );
    df98:	b1d0      	cbz	r0, dfd0 <vTaskPlaceOnEventListRestricted+0x38>
	{
    df9a:	b570      	push	{r4, r5, r6, lr}
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    df9c:	4e19      	ldr	r6, [pc, #100]	; (e004 <vTaskPlaceOnEventListRestricted+0x6c>)
    df9e:	460c      	mov	r4, r1
    dfa0:	6831      	ldr	r1, [r6, #0]
    dfa2:	4615      	mov	r5, r2
    dfa4:	3118      	adds	r1, #24
    dfa6:	f7fe fe65 	bl	cc74 <vListInsertEnd>
const TickType_t xConstTickCount = xTickCount;
    dfaa:	4b17      	ldr	r3, [pc, #92]	; (e008 <vTaskPlaceOnEventListRestricted+0x70>)
		if( xWaitIndefinitely != pdFALSE )
    dfac:	b98d      	cbnz	r5, dfd2 <vTaskPlaceOnEventListRestricted+0x3a>
const TickType_t xConstTickCount = xTickCount;
    dfae:	681d      	ldr	r5, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    dfb0:	6830      	ldr	r0, [r6, #0]
    dfb2:	3004      	adds	r0, #4
    dfb4:	f7fe fe86 	bl	ccc4 <uxListRemove>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    dfb8:	6833      	ldr	r3, [r6, #0]
    dfba:	1964      	adds	r4, r4, r5
    dfbc:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
    dfbe:	d314      	bcc.n	dfea <vTaskPlaceOnEventListRestricted+0x52>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dfc0:	4b12      	ldr	r3, [pc, #72]	; (e00c <vTaskPlaceOnEventListRestricted+0x74>)
    dfc2:	6818      	ldr	r0, [r3, #0]
    dfc4:	6831      	ldr	r1, [r6, #0]
	}
    dfc6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dfca:	3104      	adds	r1, #4
    dfcc:	f7fe be62 	b.w	cc94 <vListInsert>
		configASSERT( pxEventList );
    dfd0:	e7fe      	b.n	dfd0 <vTaskPlaceOnEventListRestricted+0x38>
const TickType_t xConstTickCount = xTickCount;
    dfd2:	681b      	ldr	r3, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    dfd4:	6830      	ldr	r0, [r6, #0]
    dfd6:	3004      	adds	r0, #4
    dfd8:	f7fe fe74 	bl	ccc4 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dfdc:	6831      	ldr	r1, [r6, #0]
    dfde:	480c      	ldr	r0, [pc, #48]	; (e010 <vTaskPlaceOnEventListRestricted+0x78>)
	}
    dfe0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dfe4:	3104      	adds	r1, #4
    dfe6:	f7fe be45 	b.w	cc74 <vListInsertEnd>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    dfea:	4b0a      	ldr	r3, [pc, #40]	; (e014 <vTaskPlaceOnEventListRestricted+0x7c>)
    dfec:	6818      	ldr	r0, [r3, #0]
    dfee:	6831      	ldr	r1, [r6, #0]
    dff0:	3104      	adds	r1, #4
    dff2:	f7fe fe4f 	bl	cc94 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
    dff6:	4b08      	ldr	r3, [pc, #32]	; (e018 <vTaskPlaceOnEventListRestricted+0x80>)
    dff8:	681a      	ldr	r2, [r3, #0]
    dffa:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
    dffc:	bf38      	it	cc
    dffe:	601c      	strcc	r4, [r3, #0]
	}
    e000:	bd70      	pop	{r4, r5, r6, pc}
    e002:	bf00      	nop
    e004:	10002360 	.word	0x10002360
    e008:	10002430 	.word	0x10002430
    e00c:	10002368 	.word	0x10002368
    e010:	1000241c 	.word	0x1000241c
    e014:	10002364 	.word	0x10002364
    e018:	100023fc 	.word	0x100023fc

0000e01c <xTaskRemoveFromEventList>:
{
    e01c:	b530      	push	{r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    e01e:	68c3      	ldr	r3, [r0, #12]
    e020:	68dc      	ldr	r4, [r3, #12]
{
    e022:	b083      	sub	sp, #12
	configASSERT( pxUnblockedTCB );
    e024:	b304      	cbz	r4, e068 <xTaskRemoveFromEventList+0x4c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    e026:	f104 0518 	add.w	r5, r4, #24
    e02a:	4628      	mov	r0, r5
    e02c:	f7fe fe4a 	bl	ccc4 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    e030:	4b1c      	ldr	r3, [pc, #112]	; (e0a4 <xTaskRemoveFromEventList+0x88>)
    e032:	681b      	ldr	r3, [r3, #0]
    e034:	b1cb      	cbz	r3, e06a <xTaskRemoveFromEventList+0x4e>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    e036:	481c      	ldr	r0, [pc, #112]	; (e0a8 <xTaskRemoveFromEventList+0x8c>)
    e038:	4629      	mov	r1, r5
    e03a:	f7fe fe1b 	bl	cc74 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    e03e:	4b1b      	ldr	r3, [pc, #108]	; (e0ac <xTaskRemoveFromEventList+0x90>)
    e040:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    e042:	681b      	ldr	r3, [r3, #0]
    e044:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e046:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    e048:	bf82      	ittt	hi
    e04a:	4b19      	ldrhi	r3, [pc, #100]	; (e0b0 <xTaskRemoveFromEventList+0x94>)
    e04c:	2001      	movhi	r0, #1
    e04e:	6018      	strhi	r0, [r3, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    e050:	4b18      	ldr	r3, [pc, #96]	; (e0b4 <xTaskRemoveFromEventList+0x98>)
    e052:	681a      	ldr	r2, [r3, #0]
    e054:	6812      	ldr	r2, [r2, #0]
		xReturn = pdFALSE;
    e056:	bf98      	it	ls
    e058:	2000      	movls	r0, #0
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    e05a:	b9d2      	cbnz	r2, e092 <xTaskRemoveFromEventList+0x76>
		xNextTaskUnblockTime = portMAX_DELAY;
    e05c:	4b16      	ldr	r3, [pc, #88]	; (e0b8 <xTaskRemoveFromEventList+0x9c>)
    e05e:	f04f 32ff 	mov.w	r2, #4294967295
    e062:	601a      	str	r2, [r3, #0]
}
    e064:	b003      	add	sp, #12
    e066:	bd30      	pop	{r4, r5, pc}
	configASSERT( pxUnblockedTCB );
    e068:	e7fe      	b.n	e068 <xTaskRemoveFromEventList+0x4c>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    e06a:	1d21      	adds	r1, r4, #4
    e06c:	4608      	mov	r0, r1
    e06e:	9101      	str	r1, [sp, #4]
    e070:	f7fe fe28 	bl	ccc4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    e074:	4a11      	ldr	r2, [pc, #68]	; (e0bc <xTaskRemoveFromEventList+0xa0>)
    e076:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e078:	6810      	ldr	r0, [r2, #0]
    e07a:	9901      	ldr	r1, [sp, #4]
    e07c:	4283      	cmp	r3, r0
    e07e:	4810      	ldr	r0, [pc, #64]	; (e0c0 <xTaskRemoveFromEventList+0xa4>)
    e080:	bf88      	it	hi
    e082:	6013      	strhi	r3, [r2, #0]
    e084:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    e088:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    e08c:	f7fe fdf2 	bl	cc74 <vListInsertEnd>
    e090:	e7d5      	b.n	e03e <xTaskRemoveFromEventList+0x22>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    e092:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    e094:	4b08      	ldr	r3, [pc, #32]	; (e0b8 <xTaskRemoveFromEventList+0x9c>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    e096:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    e098:	68d2      	ldr	r2, [r2, #12]
    e09a:	6852      	ldr	r2, [r2, #4]
    e09c:	601a      	str	r2, [r3, #0]
}
    e09e:	b003      	add	sp, #12
    e0a0:	bd30      	pop	{r4, r5, pc}
    e0a2:	bf00      	nop
    e0a4:	100023c4 	.word	0x100023c4
    e0a8:	10002404 	.word	0x10002404
    e0ac:	10002360 	.word	0x10002360
    e0b0:	10002434 	.word	0x10002434
    e0b4:	10002364 	.word	0x10002364
    e0b8:	100023fc 	.word	0x100023fc
    e0bc:	100023cc 	.word	0x100023cc
    e0c0:	1000236c 	.word	0x1000236c

0000e0c4 <vTaskRemoveFromUnorderedEventList>:
{
    e0c4:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended != pdFALSE );
    e0c6:	4b14      	ldr	r3, [pc, #80]	; (e118 <vTaskRemoveFromUnorderedEventList+0x54>)
    e0c8:	681a      	ldr	r2, [r3, #0]
    e0ca:	b312      	cbz	r2, e112 <vTaskRemoveFromUnorderedEventList+0x4e>
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    e0cc:	68c4      	ldr	r4, [r0, #12]
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    e0ce:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    e0d2:	6001      	str	r1, [r0, #0]
	configASSERT( pxUnblockedTCB );
    e0d4:	b1f4      	cbz	r4, e114 <vTaskRemoveFromUnorderedEventList+0x50>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    e0d6:	1d25      	adds	r5, r4, #4
	( void ) uxListRemove( pxEventListItem );
    e0d8:	f7fe fdf4 	bl	ccc4 <uxListRemove>
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    e0dc:	4628      	mov	r0, r5
    e0de:	f7fe fdf1 	bl	ccc4 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    e0e2:	4a0e      	ldr	r2, [pc, #56]	; (e11c <vTaskRemoveFromUnorderedEventList+0x58>)
    e0e4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e0e6:	6811      	ldr	r1, [r2, #0]
    e0e8:	480d      	ldr	r0, [pc, #52]	; (e120 <vTaskRemoveFromUnorderedEventList+0x5c>)
    e0ea:	428b      	cmp	r3, r1
    e0ec:	bf88      	it	hi
    e0ee:	6013      	strhi	r3, [r2, #0]
    e0f0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    e0f4:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    e0f8:	4629      	mov	r1, r5
    e0fa:	f7fe fdbb 	bl	cc74 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    e0fe:	4b09      	ldr	r3, [pc, #36]	; (e124 <vTaskRemoveFromUnorderedEventList+0x60>)
    e100:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    e102:	681b      	ldr	r3, [r3, #0]
    e104:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    e106:	429a      	cmp	r2, r3
    e108:	d902      	bls.n	e110 <vTaskRemoveFromUnorderedEventList+0x4c>
		xYieldPending = pdTRUE;
    e10a:	4b07      	ldr	r3, [pc, #28]	; (e128 <vTaskRemoveFromUnorderedEventList+0x64>)
    e10c:	2201      	movs	r2, #1
    e10e:	601a      	str	r2, [r3, #0]
}
    e110:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( uxSchedulerSuspended != pdFALSE );
    e112:	e7fe      	b.n	e112 <vTaskRemoveFromUnorderedEventList+0x4e>
	configASSERT( pxUnblockedTCB );
    e114:	e7fe      	b.n	e114 <vTaskRemoveFromUnorderedEventList+0x50>
    e116:	bf00      	nop
    e118:	100023c4 	.word	0x100023c4
    e11c:	100023cc 	.word	0x100023cc
    e120:	1000236c 	.word	0x1000236c
    e124:	10002360 	.word	0x10002360
    e128:	10002434 	.word	0x10002434

0000e12c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    e12c:	4a03      	ldr	r2, [pc, #12]	; (e13c <vTaskInternalSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
    e12e:	4b04      	ldr	r3, [pc, #16]	; (e140 <vTaskInternalSetTimeOutState+0x14>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    e130:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    e132:	681b      	ldr	r3, [r3, #0]
    e134:	e9c0 2300 	strd	r2, r3, [r0]
}
    e138:	4770      	bx	lr
    e13a:	bf00      	nop
    e13c:	10002400 	.word	0x10002400
    e140:	10002430 	.word	0x10002430

0000e144 <xTaskCheckForTimeOut>:
	configASSERT( pxTimeOut );
    e144:	b1e8      	cbz	r0, e182 <xTaskCheckForTimeOut+0x3e>
{
    e146:	b5f0      	push	{r4, r5, r6, r7, lr}
    e148:	460d      	mov	r5, r1
    e14a:	b083      	sub	sp, #12
	configASSERT( pxTicksToWait );
    e14c:	b1c1      	cbz	r1, e180 <xTaskCheckForTimeOut+0x3c>
    e14e:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    e150:	f7fe fac8 	bl	c6e4 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
    e154:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
    e156:	4a15      	ldr	r2, [pc, #84]	; (e1ac <xTaskCheckForTimeOut+0x68>)
			if( *pxTicksToWait == portMAX_DELAY )
    e158:	1c58      	adds	r0, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    e15a:	6811      	ldr	r1, [r2, #0]
			if( *pxTicksToWait == portMAX_DELAY )
    e15c:	d020      	beq.n	e1a0 <xTaskCheckForTimeOut+0x5c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    e15e:	f8df c050 	ldr.w	ip, [pc, #80]	; e1b0 <xTaskCheckForTimeOut+0x6c>
    e162:	e9d4 6000 	ldrd	r6, r0, [r4]
    e166:	f8dc 7000 	ldr.w	r7, [ip]
    e16a:	42be      	cmp	r6, r7
    e16c:	d00a      	beq.n	e184 <xTaskCheckForTimeOut+0x40>
    e16e:	4288      	cmp	r0, r1
    e170:	d808      	bhi.n	e184 <xTaskCheckForTimeOut+0x40>
			xReturn = pdTRUE;
    e172:	2001      	movs	r0, #1
    e174:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
    e176:	f7fe facf 	bl	c718 <vPortExitCritical>
}
    e17a:	9801      	ldr	r0, [sp, #4]
    e17c:	b003      	add	sp, #12
    e17e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT( pxTicksToWait );
    e180:	e7fe      	b.n	e180 <xTaskCheckForTimeOut+0x3c>
	configASSERT( pxTimeOut );
    e182:	e7fe      	b.n	e182 <xTaskCheckForTimeOut+0x3e>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    e184:	eba1 0e00 	sub.w	lr, r1, r0
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    e188:	4573      	cmp	r3, lr
    e18a:	d90b      	bls.n	e1a4 <xTaskCheckForTimeOut+0x60>
			*pxTicksToWait -= xElapsedTime;
    e18c:	1a5b      	subs	r3, r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    e18e:	f8dc 1000 	ldr.w	r1, [ip]
	pxTimeOut->xTimeOnEntering = xTickCount;
    e192:	6812      	ldr	r2, [r2, #0]
			*pxTicksToWait -= xElapsedTime;
    e194:	4403      	add	r3, r0
    e196:	602b      	str	r3, [r5, #0]
			xReturn = pdFALSE;
    e198:	2000      	movs	r0, #0
	pxTimeOut->xTimeOnEntering = xTickCount;
    e19a:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
    e19e:	e7e9      	b.n	e174 <xTaskCheckForTimeOut+0x30>
				xReturn = pdFALSE;
    e1a0:	2000      	movs	r0, #0
    e1a2:	e7e7      	b.n	e174 <xTaskCheckForTimeOut+0x30>
			*pxTicksToWait = 0;
    e1a4:	2300      	movs	r3, #0
    e1a6:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
    e1a8:	2001      	movs	r0, #1
    e1aa:	e7e3      	b.n	e174 <xTaskCheckForTimeOut+0x30>
    e1ac:	10002430 	.word	0x10002430
    e1b0:	10002400 	.word	0x10002400

0000e1b4 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    e1b4:	4b01      	ldr	r3, [pc, #4]	; (e1bc <vTaskMissedYield+0x8>)
    e1b6:	2201      	movs	r2, #1
    e1b8:	601a      	str	r2, [r3, #0]
}
    e1ba:	4770      	bx	lr
    e1bc:	10002434 	.word	0x10002434

0000e1c0 <eTaskConfirmSleepModeStatus>:
		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
    e1c0:	4b09      	ldr	r3, [pc, #36]	; (e1e8 <eTaskConfirmSleepModeStatus+0x28>)
    e1c2:	6818      	ldr	r0, [r3, #0]
    e1c4:	b918      	cbnz	r0, e1ce <eTaskConfirmSleepModeStatus+0xe>
		else if( xYieldPending != pdFALSE )
    e1c6:	4b09      	ldr	r3, [pc, #36]	; (e1ec <eTaskConfirmSleepModeStatus+0x2c>)
    e1c8:	681b      	ldr	r3, [r3, #0]
    e1ca:	b113      	cbz	r3, e1d2 <eTaskConfirmSleepModeStatus+0x12>
	}
    e1cc:	4770      	bx	lr
			eReturn = eAbortSleep;
    e1ce:	2000      	movs	r0, #0
	}
    e1d0:	4770      	bx	lr
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
    e1d2:	4a07      	ldr	r2, [pc, #28]	; (e1f0 <eTaskConfirmSleepModeStatus+0x30>)
    e1d4:	4b07      	ldr	r3, [pc, #28]	; (e1f4 <eTaskConfirmSleepModeStatus+0x34>)
    e1d6:	6810      	ldr	r0, [r2, #0]
    e1d8:	681b      	ldr	r3, [r3, #0]
    e1da:	3b01      	subs	r3, #1
				eReturn = eNoTasksWaitingTimeout;
    e1dc:	4298      	cmp	r0, r3
    e1de:	bf14      	ite	ne
    e1e0:	2001      	movne	r0, #1
    e1e2:	2002      	moveq	r0, #2
    e1e4:	4770      	bx	lr
    e1e6:	bf00      	nop
    e1e8:	10002404 	.word	0x10002404
    e1ec:	10002434 	.word	0x10002434
    e1f0:	1000241c 	.word	0x1000241c
    e1f4:	100023bc 	.word	0x100023bc

0000e1f8 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    e1f8:	4b05      	ldr	r3, [pc, #20]	; (e210 <xTaskGetSchedulerState+0x18>)
    e1fa:	681b      	ldr	r3, [r3, #0]
    e1fc:	b133      	cbz	r3, e20c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    e1fe:	4b05      	ldr	r3, [pc, #20]	; (e214 <xTaskGetSchedulerState+0x1c>)
    e200:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
    e202:	2b00      	cmp	r3, #0
    e204:	bf0c      	ite	eq
    e206:	2002      	moveq	r0, #2
    e208:	2000      	movne	r0, #0
    e20a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    e20c:	2001      	movs	r0, #1
	}
    e20e:	4770      	bx	lr
    e210:	10002418 	.word	0x10002418
    e214:	100023c4 	.word	0x100023c4

0000e218 <uxTaskResetEventItemValue>:
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    e218:	4a04      	ldr	r2, [pc, #16]	; (e22c <uxTaskResetEventItemValue+0x14>)
    e21a:	6811      	ldr	r1, [r2, #0]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    e21c:	6813      	ldr	r3, [r2, #0]
    e21e:	6812      	ldr	r2, [r2, #0]
    e220:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    e222:	6988      	ldr	r0, [r1, #24]
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    e224:	f1c3 0304 	rsb	r3, r3, #4
    e228:	6193      	str	r3, [r2, #24]
}
    e22a:	4770      	bx	lr
    e22c:	10002360 	.word	0x10002360

0000e230 <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    e230:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e234:	4e1d      	ldr	r6, [pc, #116]	; (e2ac <prvSwitchTimerLists+0x7c>)
	if( xTimerQueue != NULL )
    e236:	f8df 907c 	ldr.w	r9, [pc, #124]	; e2b4 <prvSwitchTimerLists+0x84>
{
    e23a:	b085      	sub	sp, #20
		xMessage.xMessageID = xCommandID;
    e23c:	f04f 0800 	mov.w	r8, #0

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    e240:	e00c      	b.n	e25c <prvSwitchTimerLists+0x2c>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    e242:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    e244:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    e246:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    e248:	1d25      	adds	r5, r4, #4
    e24a:	4628      	mov	r0, r5
    e24c:	f7fe fd3a 	bl	ccc4 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    e250:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e252:	4620      	mov	r0, r4
    e254:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    e256:	69e3      	ldr	r3, [r4, #28]
    e258:	2b01      	cmp	r3, #1
    e25a:	d00a      	beq.n	e272 <prvSwitchTimerLists+0x42>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    e25c:	6833      	ldr	r3, [r6, #0]
    e25e:	681a      	ldr	r2, [r3, #0]
    e260:	2a00      	cmp	r2, #0
    e262:	d1ee      	bne.n	e242 <prvSwitchTimerLists+0x12>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    e264:	4a12      	ldr	r2, [pc, #72]	; (e2b0 <prvSwitchTimerLists+0x80>)
    e266:	6811      	ldr	r1, [r2, #0]
    e268:	6031      	str	r1, [r6, #0]
	pxOverflowTimerList = pxTemp;
    e26a:	6013      	str	r3, [r2, #0]
}
    e26c:	b005      	add	sp, #20
    e26e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    e272:	69a3      	ldr	r3, [r4, #24]
    e274:	443b      	add	r3, r7
			if( xReloadTime > xNextExpireTime )
    e276:	429f      	cmp	r7, r3
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    e278:	4629      	mov	r1, r5
			if( xReloadTime > xNextExpireTime )
    e27a:	d205      	bcs.n	e288 <prvSwitchTimerLists+0x58>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    e27c:	6830      	ldr	r0, [r6, #0]
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    e27e:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    e280:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    e282:	f7fe fd07 	bl	cc94 <vListInsert>
    e286:	e7e9      	b.n	e25c <prvSwitchTimerLists+0x2c>
	if( xTimerQueue != NULL )
    e288:	f8d9 3000 	ldr.w	r3, [r9]
    e28c:	b16b      	cbz	r3, e2aa <prvSwitchTimerLists+0x7a>
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    e28e:	e9cd 8700 	strd	r8, r7, [sp]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    e292:	9402      	str	r4, [sp, #8]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    e294:	f7ff ffb0 	bl	e1f8 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    e298:	2300      	movs	r3, #0
    e29a:	f8d9 0000 	ldr.w	r0, [r9]
    e29e:	461a      	mov	r2, r3
    e2a0:	4669      	mov	r1, sp
    e2a2:	f7fe fd5f 	bl	cd64 <xQueueGenericSend>
				configASSERT( xResult );
    e2a6:	2800      	cmp	r0, #0
    e2a8:	d1d8      	bne.n	e25c <prvSwitchTimerLists+0x2c>
    e2aa:	e7fe      	b.n	e2aa <prvSwitchTimerLists+0x7a>
    e2ac:	10002438 	.word	0x10002438
    e2b0:	1000243c 	.word	0x1000243c
    e2b4:	1000246c 	.word	0x1000246c

0000e2b8 <prvTimerTask>:
{
    e2b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e2bc:	4e84      	ldr	r6, [pc, #528]	; (e4d0 <prvTimerTask+0x218>)
    e2be:	4d85      	ldr	r5, [pc, #532]	; (e4d4 <prvTimerTask+0x21c>)
    e2c0:	4c85      	ldr	r4, [pc, #532]	; (e4d8 <prvTimerTask+0x220>)
    e2c2:	b08b      	sub	sp, #44	; 0x2c
					portYIELD_WITHIN_API();
    e2c4:	f04f 29e0 	mov.w	r9, #3758153728	; 0xe000e000
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    e2c8:	6833      	ldr	r3, [r6, #0]
    e2ca:	f8d3 a000 	ldr.w	sl, [r3]
    e2ce:	f1ba 0f00 	cmp.w	sl, #0
    e2d2:	f000 8098 	beq.w	e406 <prvTimerTask+0x14e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    e2d6:	68db      	ldr	r3, [r3, #12]
    e2d8:	f8d3 a000 	ldr.w	sl, [r3]
	vTaskSuspendAll();
    e2dc:	f7ff fc16 	bl	db0c <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
    e2e0:	f7ff fc1c 	bl	db1c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    e2e4:	682a      	ldr	r2, [r5, #0]
    e2e6:	4282      	cmp	r2, r0
	xTimeNow = xTaskGetTickCount();
    e2e8:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
    e2ea:	f200 809d 	bhi.w	e428 <prvTimerTask+0x170>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    e2ee:	4582      	cmp	sl, r0
	xLastTime = xTimeNow;
    e2f0:	6028      	str	r0, [r5, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    e2f2:	f240 80ac 	bls.w	e44e <prvTimerTask+0x196>
    e2f6:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    e2f8:	6820      	ldr	r0, [r4, #0]
    e2fa:	ebaa 0108 	sub.w	r1, sl, r8
    e2fe:	f7ff f8bb 	bl	d478 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
    e302:	f7ff fd4b 	bl	dd9c <xTaskResumeAll>
    e306:	b938      	cbnz	r0, e318 <prvTimerTask+0x60>
					portYIELD_WITHIN_API();
    e308:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    e30c:	f8c9 3d04 	str.w	r3, [r9, #3332]	; 0xd04
    e310:	f3bf 8f4f 	dsb	sy
    e314:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    e318:	6820      	ldr	r0, [r4, #0]
    e31a:	2200      	movs	r2, #0
    e31c:	a902      	add	r1, sp, #8
    e31e:	f7fe ff41 	bl	d1a4 <xQueueReceive>
    e322:	2800      	cmp	r0, #0
    e324:	d0d0      	beq.n	e2c8 <prvTimerTask+0x10>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    e326:	9b02      	ldr	r3, [sp, #8]
    e328:	2b00      	cmp	r3, #0
    e32a:	db64      	blt.n	e3f6 <prvTimerTask+0x13e>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    e32c:	9f04      	ldr	r7, [sp, #16]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    e32e:	697b      	ldr	r3, [r7, #20]
    e330:	b113      	cbz	r3, e338 <prvTimerTask+0x80>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    e332:	1d38      	adds	r0, r7, #4
    e334:	f7fe fcc6 	bl	ccc4 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
    e338:	f7ff fbf0 	bl	db1c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    e33c:	682b      	ldr	r3, [r5, #0]
    e33e:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    e340:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
    e342:	d378      	bcc.n	e436 <prvTimerTask+0x17e>
			switch( xMessage.xMessageID )
    e344:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
    e346:	f8c5 8000 	str.w	r8, [r5]
			switch( xMessage.xMessageID )
    e34a:	2b09      	cmp	r3, #9
    e34c:	d8e4      	bhi.n	e318 <prvTimerTask+0x60>
    e34e:	a201      	add	r2, pc, #4	; (adr r2, e354 <prvTimerTask+0x9c>)
    e350:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    e354:	0000e37d 	.word	0x0000e37d
    e358:	0000e37d 	.word	0x0000e37d
    e35c:	0000e37d 	.word	0x0000e37d
    e360:	0000e319 	.word	0x0000e319
    e364:	0000e3d1 	.word	0x0000e3d1
    e368:	0000e3ef 	.word	0x0000e3ef
    e36c:	0000e37d 	.word	0x0000e37d
    e370:	0000e37d 	.word	0x0000e37d
    e374:	0000e319 	.word	0x0000e319
    e378:	0000e3d1 	.word	0x0000e3d1
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    e37c:	9b03      	ldr	r3, [sp, #12]
    e37e:	69ba      	ldr	r2, [r7, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    e380:	613f      	str	r7, [r7, #16]
    e382:	1899      	adds	r1, r3, r2
    e384:	bf2c      	ite	cs
    e386:	2001      	movcs	r0, #1
    e388:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
    e38a:	4541      	cmp	r1, r8
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    e38c:	6079      	str	r1, [r7, #4]
	if( xNextExpiryTime <= xTimeNow )
    e38e:	d855      	bhi.n	e43c <prvTimerTask+0x184>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    e390:	eba8 0303 	sub.w	r3, r8, r3
    e394:	429a      	cmp	r2, r3
    e396:	d823      	bhi.n	e3e0 <prvTimerTask+0x128>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    e398:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    e39a:	4638      	mov	r0, r7
    e39c:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    e39e:	69fb      	ldr	r3, [r7, #28]
    e3a0:	2b01      	cmp	r3, #1
    e3a2:	d1b9      	bne.n	e318 <prvTimerTask+0x60>
	if( xTimerQueue != NULL )
    e3a4:	6823      	ldr	r3, [r4, #0]
    e3a6:	2b00      	cmp	r3, #0
    e3a8:	f000 808c 	beq.w	e4c4 <prvTimerTask+0x20c>
		xMessage.xMessageID = xCommandID;
    e3ac:	2300      	movs	r3, #0
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    e3ae:	69ba      	ldr	r2, [r7, #24]
		xMessage.xMessageID = xCommandID;
    e3b0:	9306      	str	r3, [sp, #24]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    e3b2:	9b03      	ldr	r3, [sp, #12]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    e3b4:	9708      	str	r7, [sp, #32]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    e3b6:	4413      	add	r3, r2
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    e3b8:	9307      	str	r3, [sp, #28]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    e3ba:	f7ff ff1d 	bl	e1f8 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    e3be:	2300      	movs	r3, #0
    e3c0:	6820      	ldr	r0, [r4, #0]
    e3c2:	461a      	mov	r2, r3
    e3c4:	a906      	add	r1, sp, #24
    e3c6:	f7fe fccd 	bl	cd64 <xQueueGenericSend>
							configASSERT( xResult );
    e3ca:	2800      	cmp	r0, #0
    e3cc:	d1a4      	bne.n	e318 <prvTimerTask+0x60>
    e3ce:	e7fe      	b.n	e3ce <prvTimerTask+0x116>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    e3d0:	9b03      	ldr	r3, [sp, #12]
    e3d2:	61bb      	str	r3, [r7, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    e3d4:	b153      	cbz	r3, e3ec <prvTimerTask+0x134>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    e3d6:	4443      	add	r3, r8
	if( xNextExpiryTime <= xTimeNow )
    e3d8:	4543      	cmp	r3, r8
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    e3da:	607b      	str	r3, [r7, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    e3dc:	613f      	str	r7, [r7, #16]
	if( xNextExpiryTime <= xTimeNow )
    e3de:	d831      	bhi.n	e444 <prvTimerTask+0x18c>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    e3e0:	4b3e      	ldr	r3, [pc, #248]	; (e4dc <prvTimerTask+0x224>)
    e3e2:	1d39      	adds	r1, r7, #4
    e3e4:	6818      	ldr	r0, [r3, #0]
    e3e6:	f7fe fc55 	bl	cc94 <vListInsert>
	return xProcessTimerNow;
    e3ea:	e795      	b.n	e318 <prvTimerTask+0x60>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    e3ec:	e7fe      	b.n	e3ec <prvTimerTask+0x134>
						vPortFree( pxTimer );
    e3ee:	4638      	mov	r0, r7
    e3f0:	f001 f906 	bl	f600 <vPortFree>
					break;
    e3f4:	e790      	b.n	e318 <prvTimerTask+0x60>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    e3f6:	9b03      	ldr	r3, [sp, #12]
    e3f8:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    e3fc:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    e3fe:	9b02      	ldr	r3, [sp, #8]
    e400:	2b00      	cmp	r3, #0
    e402:	db89      	blt.n	e318 <prvTimerTask+0x60>
    e404:	e792      	b.n	e32c <prvTimerTask+0x74>
	vTaskSuspendAll();
    e406:	f7ff fb81 	bl	db0c <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
    e40a:	f7ff fb87 	bl	db1c <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
    e40e:	682a      	ldr	r2, [r5, #0]
    e410:	4282      	cmp	r2, r0
	xTimeNow = xTaskGetTickCount();
    e412:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
    e414:	d808      	bhi.n	e428 <prvTimerTask+0x170>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    e416:	4b31      	ldr	r3, [pc, #196]	; (e4dc <prvTimerTask+0x224>)
	xLastTime = xTimeNow;
    e418:	f8c5 8000 	str.w	r8, [r5]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    e41c:	681a      	ldr	r2, [r3, #0]
    e41e:	6812      	ldr	r2, [r2, #0]
    e420:	fab2 f282 	clz	r2, r2
    e424:	0952      	lsrs	r2, r2, #5
    e426:	e767      	b.n	e2f8 <prvTimerTask+0x40>
		prvSwitchTimerLists();
    e428:	f7ff ff02 	bl	e230 <prvSwitchTimerLists>
	xLastTime = xTimeNow;
    e42c:	f8c5 8000 	str.w	r8, [r5]
			( void ) xTaskResumeAll();
    e430:	f7ff fcb4 	bl	dd9c <xTaskResumeAll>
    e434:	e770      	b.n	e318 <prvTimerTask+0x60>
		prvSwitchTimerLists();
    e436:	f7ff fefb 	bl	e230 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
    e43a:	e783      	b.n	e344 <prvTimerTask+0x8c>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    e43c:	4543      	cmp	r3, r8
    e43e:	d901      	bls.n	e444 <prvTimerTask+0x18c>
    e440:	2800      	cmp	r0, #0
    e442:	d0a9      	beq.n	e398 <prvTimerTask+0xe0>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    e444:	6830      	ldr	r0, [r6, #0]
    e446:	1d39      	adds	r1, r7, #4
    e448:	f7fe fc24 	bl	cc94 <vListInsert>
    e44c:	e764      	b.n	e318 <prvTimerTask+0x60>
				( void ) xTaskResumeAll();
    e44e:	f7ff fca5 	bl	dd9c <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    e452:	6832      	ldr	r2, [r6, #0]
    e454:	68d2      	ldr	r2, [r2, #12]
    e456:	f8d2 b00c 	ldr.w	fp, [r2, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    e45a:	f10b 0104 	add.w	r1, fp, #4
    e45e:	4608      	mov	r0, r1
    e460:	9101      	str	r1, [sp, #4]
    e462:	f7fe fc2f 	bl	ccc4 <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    e466:	f8db 001c 	ldr.w	r0, [fp, #28]
    e46a:	9901      	ldr	r1, [sp, #4]
    e46c:	2801      	cmp	r0, #1
    e46e:	d004      	beq.n	e47a <prvTimerTask+0x1c2>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    e470:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    e474:	4658      	mov	r0, fp
    e476:	4798      	blx	r3
}
    e478:	e74e      	b.n	e318 <prvTimerTask+0x60>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    e47a:	f8db 0018 	ldr.w	r0, [fp, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    e47e:	f8cb b010 	str.w	fp, [fp, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    e482:	eb0a 0300 	add.w	r3, sl, r0
	if( xNextExpiryTime <= xTimeNow )
    e486:	4598      	cmp	r8, r3
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    e488:	f8cb 3004 	str.w	r3, [fp, #4]
	if( xNextExpiryTime <= xTimeNow )
    e48c:	d203      	bcs.n	e496 <prvTimerTask+0x1de>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    e48e:	6830      	ldr	r0, [r6, #0]
    e490:	f7fe fc00 	bl	cc94 <vListInsert>
	return xProcessTimerNow;
    e494:	e7ec      	b.n	e470 <prvTimerTask+0x1b8>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    e496:	eba8 030a 	sub.w	r3, r8, sl
    e49a:	4298      	cmp	r0, r3
    e49c:	d813      	bhi.n	e4c6 <prvTimerTask+0x20e>
	if( xTimerQueue != NULL )
    e49e:	6823      	ldr	r3, [r4, #0]
    e4a0:	b17b      	cbz	r3, e4c2 <prvTimerTask+0x20a>
		xMessage.xMessageID = xCommandID;
    e4a2:	2300      	movs	r3, #0
    e4a4:	9306      	str	r3, [sp, #24]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    e4a6:	f8cd a01c 	str.w	sl, [sp, #28]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    e4aa:	f8cd b020 	str.w	fp, [sp, #32]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    e4ae:	f7ff fea3 	bl	e1f8 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    e4b2:	2300      	movs	r3, #0
    e4b4:	6820      	ldr	r0, [r4, #0]
    e4b6:	461a      	mov	r2, r3
    e4b8:	a906      	add	r1, sp, #24
    e4ba:	f7fe fc53 	bl	cd64 <xQueueGenericSend>
			configASSERT( xResult );
    e4be:	2800      	cmp	r0, #0
    e4c0:	d1d6      	bne.n	e470 <prvTimerTask+0x1b8>
    e4c2:	e7fe      	b.n	e4c2 <prvTimerTask+0x20a>
							configASSERT( xResult );
    e4c4:	e783      	b.n	e3ce <prvTimerTask+0x116>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    e4c6:	4b05      	ldr	r3, [pc, #20]	; (e4dc <prvTimerTask+0x224>)
    e4c8:	6818      	ldr	r0, [r3, #0]
    e4ca:	f7fe fbe3 	bl	cc94 <vListInsert>
	return xProcessTimerNow;
    e4ce:	e7cf      	b.n	e470 <prvTimerTask+0x1b8>
    e4d0:	10002438 	.word	0x10002438
    e4d4:	10002468 	.word	0x10002468
    e4d8:	1000246c 	.word	0x1000246c
    e4dc:	1000243c 	.word	0x1000243c

0000e4e0 <xTimerCreateTimerTask>:
{
    e4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
    e4e2:	4c16      	ldr	r4, [pc, #88]	; (e53c <xTimerCreateTimerTask+0x5c>)
{
    e4e4:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
    e4e6:	f7fe f8fd 	bl	c6e4 <vPortEnterCritical>
		if( xTimerQueue == NULL )
    e4ea:	6825      	ldr	r5, [r4, #0]
    e4ec:	b195      	cbz	r5, e514 <xTimerCreateTimerTask+0x34>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    e4ee:	f7fe f913 	bl	c718 <vPortExitCritical>
	if( xTimerQueue != NULL )
    e4f2:	6823      	ldr	r3, [r4, #0]
    e4f4:	b15b      	cbz	r3, e50e <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    e4f6:	4a12      	ldr	r2, [pc, #72]	; (e540 <xTimerCreateTimerTask+0x60>)
    e4f8:	4912      	ldr	r1, [pc, #72]	; (e544 <xTimerCreateTimerTask+0x64>)
    e4fa:	4813      	ldr	r0, [pc, #76]	; (e548 <xTimerCreateTimerTask+0x68>)
    e4fc:	2303      	movs	r3, #3
    e4fe:	e9cd 3200 	strd	r3, r2, [sp]
    e502:	2300      	movs	r3, #0
    e504:	f44f 7280 	mov.w	r2, #256	; 0x100
    e508:	f7ff f87a 	bl	d600 <xTaskCreate>
	configASSERT( xReturn );
    e50c:	b900      	cbnz	r0, e510 <xTimerCreateTimerTask+0x30>
    e50e:	e7fe      	b.n	e50e <xTimerCreateTimerTask+0x2e>
}
    e510:	b003      	add	sp, #12
    e512:	bdf0      	pop	{r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    e514:	4f0d      	ldr	r7, [pc, #52]	; (e54c <xTimerCreateTimerTask+0x6c>)
			vListInitialise( &xActiveTimerList2 );
    e516:	4e0e      	ldr	r6, [pc, #56]	; (e550 <xTimerCreateTimerTask+0x70>)
			vListInitialise( &xActiveTimerList1 );
    e518:	4638      	mov	r0, r7
    e51a:	f7fe fb9b 	bl	cc54 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    e51e:	4630      	mov	r0, r6
    e520:	f7fe fb98 	bl	cc54 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    e524:	4b0b      	ldr	r3, [pc, #44]	; (e554 <xTimerCreateTimerTask+0x74>)
    e526:	601f      	str	r7, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    e528:	4b0b      	ldr	r3, [pc, #44]	; (e558 <xTimerCreateTimerTask+0x78>)
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    e52a:	462a      	mov	r2, r5
    e52c:	2110      	movs	r1, #16
    e52e:	2005      	movs	r0, #5
			pxOverflowTimerList = &xActiveTimerList2;
    e530:	601e      	str	r6, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    e532:	f7fe fbdb 	bl	ccec <xQueueGenericCreate>
    e536:	6020      	str	r0, [r4, #0]
    e538:	e7d9      	b.n	e4ee <xTimerCreateTimerTask+0xe>
    e53a:	bf00      	nop
    e53c:	1000246c 	.word	0x1000246c
    e540:	10002470 	.word	0x10002470
    e544:	00010b98 	.word	0x00010b98
    e548:	0000e2b9 	.word	0x0000e2b9
    e54c:	10002440 	.word	0x10002440
    e550:	10002454 	.word	0x10002454
    e554:	10002438 	.word	0x10002438
    e558:	1000243c 	.word	0x1000243c

0000e55c <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    e55c:	b530      	push	{r4, r5, lr}
    e55e:	4614      	mov	r4, r2
    e560:	b085      	sub	sp, #20
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    e562:	461a      	mov	r2, r3
    e564:	4b06      	ldr	r3, [pc, #24]	; (e580 <xTimerPendFunctionCallFromISR+0x24>)
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    e566:	9001      	str	r0, [sp, #4]
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    e568:	9102      	str	r1, [sp, #8]
		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    e56a:	6818      	ldr	r0, [r3, #0]
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    e56c:	9403      	str	r4, [sp, #12]
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    e56e:	f06f 0501 	mvn.w	r5, #1
		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    e572:	2300      	movs	r3, #0
    e574:	4669      	mov	r1, sp
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    e576:	9500      	str	r5, [sp, #0]
		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    e578:	f7fe fd86 	bl	d088 <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    e57c:	b005      	add	sp, #20
    e57e:	bd30      	pop	{r4, r5, pc}
    e580:	1000246c 	.word	0x1000246c

0000e584 <am_util_delay_ms>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
    e584:	b510      	push	{r4, lr}
    e586:	b084      	sub	sp, #16
    e588:	4604      	mov	r4, r0
    am_hal_delay_us( ui32MilliSeconds * 1000);
#else // AM_PART_APOLLO4
    uint32_t ui32Loops, ui32HFRC;
#if AM_APOLLO3_CLKGEN
    am_hal_clkgen_status_t sClkgenStatus;
    am_hal_clkgen_status_get(&sClkgenStatus);
    e58a:	a801      	add	r0, sp, #4
    e58c:	f001 fbec 	bl	fd68 <am_hal_clkgen_status_get>
    ui32HFRC = sClkgenStatus.ui32SysclkFreq;
#else // AM_APOLLO3_CLKGEN
    ui32HFRC = am_hal_clkgen_sysclk_get();
#endif // AM_APOLLO3_CLKGEN
    ui32Loops = ui32MilliSeconds * (ui32HFRC / 3000);
    e590:	9b01      	ldr	r3, [sp, #4]
    e592:	4805      	ldr	r0, [pc, #20]	; (e5a8 <am_util_delay_ms+0x24>)
    e594:	fba0 2303 	umull	r2, r3, r0, r3
    e598:	099b      	lsrs	r3, r3, #6

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
    e59a:	fb04 f003 	mul.w	r0, r4, r3
    e59e:	f001 fc49 	bl	fe34 <am_hal_flash_delay>
#endif // AM_PART_APOLLO4
}
    e5a2:	b004      	add	sp, #16
    e5a4:	bd10      	pop	{r4, pc}
    e5a6:	bf00      	nop
    e5a8:	057619f1 	.word	0x057619f1

0000e5ac <HardFault_Handler>:
HardFault_Handler(void)
#else // AM_CMSIS_REGS
am_fault_isr(void)
#endif // AM_CMSIS_REGS
{
    __asm("    push    {r0,lr}");       // Always pushes to MSP stack
    e5ac:	b501      	push	{r0, lr}
    __asm("    tst     lr, #4");        // Check if we should use MSP or PSP
    e5ae:	f01e 0f04 	tst.w	lr, #4
    __asm("    itet    eq");            // Instrs executed when: eq,ne,eq
    e5b2:	bf0a      	itet	eq
    __asm("    mrseq   r0, msp");       //    bit2=0 indicating MSP stack
    e5b4:	f3ef 8008 	mrseq	r0, MSP
    __asm("    mrsne   r0, psp");       // e: bit2=1 indicating PSP stack
    e5b8:	f3ef 8009 	mrsne	r0, PSP
    __asm("    addseq  r0, r0, #8");    // t: bit2=0, adjust for pushes to MSP stack
    e5bc:	f110 0008 	addseq.w	r0, r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    e5c0:	f000 f806 	bl	e5d0 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");       // Restore from MSP stack
    e5c4:	bd01      	pop	{r0, pc}
    e5c6:	bf00      	nop

0000e5c8 <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    e5c8:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    e5ca:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    e5cc:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    e5ce:	4770      	bx	lr

0000e5d0 <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    e5d0:	b510      	push	{r4, lr}
    volatile am_fault_t sFaultData;
#if (defined(AM_PART_APOLLO4) || defined(AM_PART_APOLLO4B))
    am_hal_fault_status_t  sHalFaultData = {0};
#else
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    e5d2:	2300      	movs	r3, #0
{
    e5d4:	b092      	sub	sp, #72	; 0x48
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    e5d6:	e9cd 3300 	strd	r3, r3, [sp]
    e5da:	e9cd 3302 	strd	r3, r3, [sp, #8]
    e5de:	e9cd 3304 	strd	r3, r3, [sp, #16]
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    e5e2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    e5e6:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    e5e8:	f8d2 3d28 	ldr.w	r3, [r2, #3368]	; 0xd28
    e5ec:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    e5ee:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e5f0:	b2db      	uxtb	r3, r3
    e5f2:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    e5f6:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e5f8:	f3c3 2307 	ubfx	r3, r3, #8, #8
    e5fc:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    e600:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e602:	0c1b      	lsrs	r3, r3, #16
    e604:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    e608:	f8d2 3d38 	ldr.w	r3, [r2, #3384]	; 0xd38
    e60c:	930f      	str	r3, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    e60e:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e612:	079a      	lsls	r2, r3, #30
{
    e614:	4604      	mov	r4, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    e616:	f100 8180 	bmi.w	e91a <am_util_faultisr_collect_data+0x34a>
    e61a:	f04f 33ff 	mov.w	r3, #4294967295

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    e61e:	4621      	mov	r1, r4
    e620:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    e622:	930e      	str	r3, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    e624:	f7ff ffd0 	bl	e5c8 <getStackedReg>
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    e628:	4621      	mov	r1, r4
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    e62a:	4603      	mov	r3, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    e62c:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    e62e:	9306      	str	r3, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    e630:	f7ff ffca 	bl	e5c8 <getStackedReg>
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    e634:	4621      	mov	r1, r4
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    e636:	4603      	mov	r3, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    e638:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    e63a:	9307      	str	r3, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    e63c:	f7ff ffc4 	bl	e5c8 <getStackedReg>
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    e640:	4621      	mov	r1, r4
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    e642:	4603      	mov	r3, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    e644:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    e646:	9308      	str	r3, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    e648:	f7ff ffbe 	bl	e5c8 <getStackedReg>
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    e64c:	4621      	mov	r1, r4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    e64e:	4603      	mov	r3, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    e650:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    e652:	9309      	str	r3, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    e654:	f7ff ffb8 	bl	e5c8 <getStackedReg>
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    e658:	4621      	mov	r1, r4
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    e65a:	4603      	mov	r3, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    e65c:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    e65e:	930a      	str	r3, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    e660:	f7ff ffb2 	bl	e5c8 <getStackedReg>
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    e664:	4621      	mov	r1, r4
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    e666:	4603      	mov	r3, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    e668:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    e66a:	930b      	str	r3, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    e66c:	f7ff ffac 	bl	e5c8 <getStackedReg>
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    e670:	4621      	mov	r1, r4
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    e672:	4603      	mov	r3, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    e674:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    e676:	930c      	str	r3, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    e678:	f7ff ffa6 	bl	e5c8 <getStackedReg>
    //
#if (defined(AM_PART_APOLLO4) || defined(AM_PART_APOLLO4B))
    am_hal_fault_status_get(&sHalFaultData);
#else
#if AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    e67c:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    e67e:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    e680:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    e682:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    e684:	f001 ff4e 	bl	10524 <am_hal_mcuctrl_info_get>
#ifdef AM_UTIL_FAULTISR_PRINT
    //
    // If printf has previously been initialized in the application, we should
    // be able to print out the fault information.
    //
    am_util_stdio_printf("Hard Fault stacked data:\n");
    e688:	487f      	ldr	r0, [pc, #508]	; (e888 <am_util_faultisr_collect_data+0x2b8>)
    e68a:	f000 ff41 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    R0  = 0x%08X\n", sFaultData.u32R0);
    e68e:	9906      	ldr	r1, [sp, #24]
    e690:	487e      	ldr	r0, [pc, #504]	; (e88c <am_util_faultisr_collect_data+0x2bc>)
    e692:	f000 ff3d 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    R1  = 0x%08X\n", sFaultData.u32R1);
    e696:	9907      	ldr	r1, [sp, #28]
    e698:	487d      	ldr	r0, [pc, #500]	; (e890 <am_util_faultisr_collect_data+0x2c0>)
    e69a:	f000 ff39 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    R2  = 0x%08X\n", sFaultData.u32R2);
    e69e:	9908      	ldr	r1, [sp, #32]
    e6a0:	487c      	ldr	r0, [pc, #496]	; (e894 <am_util_faultisr_collect_data+0x2c4>)
    e6a2:	f000 ff35 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    R3  = 0x%08X\n", sFaultData.u32R3);
    e6a6:	9909      	ldr	r1, [sp, #36]	; 0x24
    e6a8:	487b      	ldr	r0, [pc, #492]	; (e898 <am_util_faultisr_collect_data+0x2c8>)
    e6aa:	f000 ff31 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    R12 = 0x%08X\n", sFaultData.u32R12);
    e6ae:	990a      	ldr	r1, [sp, #40]	; 0x28
    e6b0:	487a      	ldr	r0, [pc, #488]	; (e89c <am_util_faultisr_collect_data+0x2cc>)
    e6b2:	f000 ff2d 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    LR  = 0x%08X\n", sFaultData.u32LR);
    e6b6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    e6b8:	4879      	ldr	r0, [pc, #484]	; (e8a0 <am_util_faultisr_collect_data+0x2d0>)
    e6ba:	f000 ff29 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    PC  = 0x%08X\n", sFaultData.u32PC);
    e6be:	990c      	ldr	r1, [sp, #48]	; 0x30
    e6c0:	4878      	ldr	r0, [pc, #480]	; (e8a4 <am_util_faultisr_collect_data+0x2d4>)
    e6c2:	f000 ff25 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    PSR = 0x%08X\n", sFaultData.u32PSR);
    e6c6:	990d      	ldr	r1, [sp, #52]	; 0x34
    e6c8:	4877      	ldr	r0, [pc, #476]	; (e8a8 <am_util_faultisr_collect_data+0x2d8>)
    e6ca:	f000 ff21 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("Other Hard Fault data:\n");
    e6ce:	4877      	ldr	r0, [pc, #476]	; (e8ac <am_util_faultisr_collect_data+0x2dc>)
    e6d0:	f000 ff1e 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    Fault address = 0x%08X\n", sFaultData.u32FaultAddr);
    e6d4:	990e      	ldr	r1, [sp, #56]	; 0x38
    e6d6:	4876      	ldr	r0, [pc, #472]	; (e8b0 <am_util_faultisr_collect_data+0x2e0>)
    e6d8:	f000 ff1a 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    BFAR (Bus Fault Addr Reg) = 0x%08X\n", sFaultData.u32BFAR);
    e6dc:	990f      	ldr	r1, [sp, #60]	; 0x3c
    e6de:	4875      	ldr	r0, [pc, #468]	; (e8b4 <am_util_faultisr_collect_data+0x2e4>)
    e6e0:	f000 ff16 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    MMSR (Mem Mgmt Fault Status Reg) = 0x%02X\n", sFaultData.u8MMSR);
    e6e4:	f89d 1044 	ldrb.w	r1, [sp, #68]	; 0x44
    e6e8:	4873      	ldr	r0, [pc, #460]	; (e8b8 <am_util_faultisr_collect_data+0x2e8>)
    e6ea:	f000 ff11 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    BFSR (Bus Fault Status Reg) = 0x%02X\n", sFaultData.u8BFSR);
    e6ee:	f89d 1045 	ldrb.w	r1, [sp, #69]	; 0x45
    e6f2:	4872      	ldr	r0, [pc, #456]	; (e8bc <am_util_faultisr_collect_data+0x2ec>)
    e6f4:	f000 ff0c 	bl	f510 <am_util_stdio_printf>
    am_util_stdio_printf("    UFSR (Usage Fault Status Reg) = 0x%04X\n", sFaultData.u16UFSR);
    e6f8:	f8bd 1046 	ldrh.w	r1, [sp, #70]	; 0x46
    e6fc:	4870      	ldr	r0, [pc, #448]	; (e8c0 <am_util_faultisr_collect_data+0x2f0>)
    e6fe:	b289      	uxth	r1, r1
    e700:	f000 ff06 	bl	f510 <am_util_stdio_printf>
    // Print out any bits set in the BFSR.
    //
    u32Mask = 0x80;
    while (u32Mask)
    {
        switch (sFaultData.u8BFSR & u32Mask)
    e704:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e708:	f003 0380 	and.w	r3, r3, #128	; 0x80
    e70c:	2b20      	cmp	r3, #32
    e70e:	d825      	bhi.n	e75c <am_util_faultisr_collect_data+0x18c>
    e710:	b35b      	cbz	r3, e76a <am_util_faultisr_collect_data+0x19a>
    e712:	3b01      	subs	r3, #1
    e714:	2b1f      	cmp	r3, #31
    e716:	d828      	bhi.n	e76a <am_util_faultisr_collect_data+0x19a>
    e718:	e8df f013 	tbh	[pc, r3, lsl #1]
    e71c:	016b0167 	.word	0x016b0167
    e720:	016f0027 	.word	0x016f0027
    e724:	00270027 	.word	0x00270027
    e728:	01470027 	.word	0x01470027
    e72c:	00270027 	.word	0x00270027
    e730:	00270027 	.word	0x00270027
    e734:	00270027 	.word	0x00270027
    e738:	014b0027 	.word	0x014b0027
    e73c:	00270027 	.word	0x00270027
    e740:	00270027 	.word	0x00270027
    e744:	00270027 	.word	0x00270027
    e748:	00270027 	.word	0x00270027
    e74c:	00270027 	.word	0x00270027
    e750:	00270027 	.word	0x00270027
    e754:	00270027 	.word	0x00270027
    e758:	014f0027 	.word	0x014f0027
    e75c:	2b40      	cmp	r3, #64	; 0x40
    e75e:	f000 815c 	beq.w	ea1a <am_util_faultisr_collect_data+0x44a>
    e762:	b113      	cbz	r3, e76a <am_util_faultisr_collect_data+0x19a>
        {
            case 0x80:
                am_util_stdio_printf("        BFSR bit7: BFARVALID\n");
    e764:	4857      	ldr	r0, [pc, #348]	; (e8c4 <am_util_faultisr_collect_data+0x2f4>)
    e766:	f000 fed3 	bl	f510 <am_util_stdio_printf>
        switch (sFaultData.u8BFSR & u32Mask)
    e76a:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e76e:	f003 0340 	and.w	r3, r3, #64	; 0x40
    e772:	2b20      	cmp	r3, #32
    e774:	d825      	bhi.n	e7c2 <am_util_faultisr_collect_data+0x1f2>
    e776:	b33b      	cbz	r3, e7c8 <am_util_faultisr_collect_data+0x1f8>
    e778:	3b01      	subs	r3, #1
    e77a:	2b1f      	cmp	r3, #31
    e77c:	d824      	bhi.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
    e77e:	e8df f013 	tbh	[pc, r3, lsl #1]
    e782:	0120      	.short	0x0120
    e784:	00230124 	.word	0x00230124
    e788:	00230128 	.word	0x00230128
    e78c:	00230023 	.word	0x00230023
    e790:	0023012c 	.word	0x0023012c
    e794:	00230023 	.word	0x00230023
    e798:	00230023 	.word	0x00230023
    e79c:	00230023 	.word	0x00230023
    e7a0:	00230130 	.word	0x00230130
    e7a4:	00230023 	.word	0x00230023
    e7a8:	00230023 	.word	0x00230023
    e7ac:	00230023 	.word	0x00230023
    e7b0:	00230023 	.word	0x00230023
    e7b4:	00230023 	.word	0x00230023
    e7b8:	00230023 	.word	0x00230023
    e7bc:	00230023 	.word	0x00230023
    e7c0:	0140      	.short	0x0140
    e7c2:	2b00      	cmp	r3, #0
    e7c4:	f040 80b9 	bne.w	e93a <am_util_faultisr_collect_data+0x36a>
    e7c8:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e7cc:	f013 0320 	ands.w	r3, r3, #32
    e7d0:	d027      	beq.n	e822 <am_util_faultisr_collect_data+0x252>
    e7d2:	3b01      	subs	r3, #1
    e7d4:	2b1f      	cmp	r3, #31
    e7d6:	d824      	bhi.n	e822 <am_util_faultisr_collect_data+0x252>
    e7d8:	e8df f013 	tbh	[pc, r3, lsl #1]
    e7dc:	01170020 	.word	0x01170020
    e7e0:	00d70023 	.word	0x00d70023
    e7e4:	00230023 	.word	0x00230023
    e7e8:	00db0023 	.word	0x00db0023
    e7ec:	00230023 	.word	0x00230023
    e7f0:	00230023 	.word	0x00230023
    e7f4:	00230023 	.word	0x00230023
    e7f8:	00df0023 	.word	0x00df0023
    e7fc:	00230023 	.word	0x00230023
    e800:	00230023 	.word	0x00230023
    e804:	00230023 	.word	0x00230023
    e808:	00230023 	.word	0x00230023
    e80c:	00230023 	.word	0x00230023
    e810:	00230023 	.word	0x00230023
    e814:	00230023 	.word	0x00230023
    e818:	00e30023 	.word	0x00e30023
                break;
            case 0x02:
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
                break;
            case 0x01:
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e81c:	482a      	ldr	r0, [pc, #168]	; (e8c8 <am_util_faultisr_collect_data+0x2f8>)
    e81e:	f000 fe77 	bl	f510 <am_util_stdio_printf>
        switch (sFaultData.u8BFSR & u32Mask)
    e822:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e826:	f013 0310 	ands.w	r3, r3, #16
    e82a:	d00f      	beq.n	e84c <am_util_faultisr_collect_data+0x27c>
    e82c:	3b01      	subs	r3, #1
    e82e:	2b0f      	cmp	r3, #15
    e830:	d80c      	bhi.n	e84c <am_util_faultisr_collect_data+0x27c>
    e832:	e8df f003 	tbb	[pc, r3]
    e836:	8608      	.short	0x8608
    e838:	0b0b8a0b 	.word	0x0b0b8a0b
    e83c:	0b0b8e0b 	.word	0x0b0b8e0b
    e840:	0b0b0b0b 	.word	0x0b0b0b0b
    e844:	920b      	.short	0x920b
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e846:	4820      	ldr	r0, [pc, #128]	; (e8c8 <am_util_faultisr_collect_data+0x2f8>)
    e848:	f000 fe62 	bl	f510 <am_util_stdio_printf>
        switch (sFaultData.u8BFSR & u32Mask)
    e84c:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e850:	f013 0308 	ands.w	r3, r3, #8
    e854:	d00b      	beq.n	e86e <am_util_faultisr_collect_data+0x29e>
    e856:	3b01      	subs	r3, #1
    e858:	2b07      	cmp	r3, #7
    e85a:	d808      	bhi.n	e86e <am_util_faultisr_collect_data+0x29e>
    e85c:	e8df f003 	tbb	[pc, r3]
    e860:	85078104 	.word	0x85078104
    e864:	89070707 	.word	0x89070707
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e868:	4817      	ldr	r0, [pc, #92]	; (e8c8 <am_util_faultisr_collect_data+0x2f8>)
    e86a:	f000 fe51 	bl	f510 <am_util_stdio_printf>
        switch (sFaultData.u8BFSR & u32Mask)
    e86e:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e872:	f013 0304 	ands.w	r3, r3, #4
    e876:	d02c      	beq.n	e8d2 <am_util_faultisr_collect_data+0x302>
    e878:	3b01      	subs	r3, #1
    e87a:	2b03      	cmp	r3, #3
    e87c:	d829      	bhi.n	e8d2 <am_util_faultisr_collect_data+0x302>
    e87e:	e8df f003 	tbb	[pc, r3]
    e882:	7c25      	.short	0x7c25
    e884:	8028      	.short	0x8028
    e886:	bf00      	nop
    e888:	00010ba0 	.word	0x00010ba0
    e88c:	00010bbc 	.word	0x00010bbc
    e890:	00010bd0 	.word	0x00010bd0
    e894:	00010be4 	.word	0x00010be4
    e898:	00010bf8 	.word	0x00010bf8
    e89c:	00010c0c 	.word	0x00010c0c
    e8a0:	00010c20 	.word	0x00010c20
    e8a4:	00010c34 	.word	0x00010c34
    e8a8:	00010c48 	.word	0x00010c48
    e8ac:	00010c5c 	.word	0x00010c5c
    e8b0:	00010c74 	.word	0x00010c74
    e8b4:	00010c90 	.word	0x00010c90
    e8b8:	00010cb8 	.word	0x00010cb8
    e8bc:	00010ce8 	.word	0x00010ce8
    e8c0:	00010d14 	.word	0x00010d14
    e8c4:	00010e14 	.word	0x00010e14
    e8c8:	00010d40 	.word	0x00010d40
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e8cc:	4855      	ldr	r0, [pc, #340]	; (ea24 <am_util_faultisr_collect_data+0x454>)
    e8ce:	f000 fe1f 	bl	f510 <am_util_stdio_printf>
        switch (sFaultData.u8BFSR & u32Mask)
    e8d2:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e8d6:	f013 0302 	ands.w	r3, r3, #2
    e8da:	d005      	beq.n	e8e8 <am_util_faultisr_collect_data+0x318>
    e8dc:	2b00      	cmp	r3, #0
    e8de:	f000 8098 	beq.w	ea12 <am_util_faultisr_collect_data+0x442>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    e8e2:	4851      	ldr	r0, [pc, #324]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    e8e4:	f000 fe14 	bl	f510 <am_util_stdio_printf>
        switch (sFaultData.u8BFSR & u32Mask)
    e8e8:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    e8ec:	07db      	lsls	r3, r3, #31
    e8ee:	d502      	bpl.n	e8f6 <am_util_faultisr_collect_data+0x326>
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e8f0:	484c      	ldr	r0, [pc, #304]	; (ea24 <am_util_faultisr_collect_data+0x454>)
    e8f2:	f000 fe0d 	bl	f510 <am_util_stdio_printf>
    }

    //
    // Print out any Apollo* Internal fault information.
    //
    am_util_stdio_printf("MCU Fault data:\n");
    e8f6:	484d      	ldr	r0, [pc, #308]	; (ea2c <am_util_faultisr_collect_data+0x45c>)
    e8f8:	f000 fe0a 	bl	f510 <am_util_stdio_printf>
    if (sHalFaultData.bICODE)
    e8fc:	f89d 3000 	ldrb.w	r3, [sp]
    e900:	b9b3      	cbnz	r3, e930 <am_util_faultisr_collect_data+0x360>
    {
      am_util_stdio_printf("   ICODE Fault Address: 0x%08X\n", sHalFaultData.ui32ICODE);
    }
    if (sHalFaultData.bDCODE)
    e902:	f89d 3008 	ldrb.w	r3, [sp, #8]
    e906:	b973      	cbnz	r3, e926 <am_util_faultisr_collect_data+0x356>
    {
      am_util_stdio_printf("   DCODE Fault Address: 0x%08X\n", sHalFaultData.ui32DCODE);
    }
    if (sHalFaultData.bSYS)
    e908:	f89d 3010 	ldrb.w	r3, [sp, #16]
    e90c:	b903      	cbnz	r3, e910 <am_util_faultisr_collect_data+0x340>
    //
    // Spin in an infinite loop.
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
    e90e:	e7fe      	b.n	e90e <am_util_faultisr_collect_data+0x33e>
      am_util_stdio_printf("   SYS Fault Address: 0x%08X\n", sHalFaultData.ui32SYS);
    e910:	9905      	ldr	r1, [sp, #20]
    e912:	4847      	ldr	r0, [pc, #284]	; (ea30 <am_util_faultisr_collect_data+0x460>)
    e914:	f000 fdfc 	bl	f510 <am_util_stdio_printf>
    e918:	e7f9      	b.n	e90e <am_util_faultisr_collect_data+0x33e>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    e91a:	4601      	mov	r1, r0
    e91c:	2006      	movs	r0, #6
    e91e:	f7ff fe53 	bl	e5c8 <getStackedReg>
    e922:	4603      	mov	r3, r0
    e924:	e67b      	b.n	e61e <am_util_faultisr_collect_data+0x4e>
      am_util_stdio_printf("   DCODE Fault Address: 0x%08X\n", sHalFaultData.ui32DCODE);
    e926:	9903      	ldr	r1, [sp, #12]
    e928:	4842      	ldr	r0, [pc, #264]	; (ea34 <am_util_faultisr_collect_data+0x464>)
    e92a:	f000 fdf1 	bl	f510 <am_util_stdio_printf>
    e92e:	e7eb      	b.n	e908 <am_util_faultisr_collect_data+0x338>
      am_util_stdio_printf("   ICODE Fault Address: 0x%08X\n", sHalFaultData.ui32ICODE);
    e930:	9901      	ldr	r1, [sp, #4]
    e932:	4841      	ldr	r0, [pc, #260]	; (ea38 <am_util_faultisr_collect_data+0x468>)
    e934:	f000 fdec 	bl	f510 <am_util_stdio_printf>
    e938:	e7e3      	b.n	e902 <am_util_faultisr_collect_data+0x332>
                am_util_stdio_printf("        BFSR bit6: RESERVED\n");
    e93a:	4840      	ldr	r0, [pc, #256]	; (ea3c <am_util_faultisr_collect_data+0x46c>)
    e93c:	f000 fde8 	bl	f510 <am_util_stdio_printf>
                break;
    e940:	e742      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    e942:	4839      	ldr	r0, [pc, #228]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    e944:	f000 fde4 	bl	f510 <am_util_stdio_printf>
                break;
    e948:	e780      	b.n	e84c <am_util_faultisr_collect_data+0x27c>
                am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    e94a:	483d      	ldr	r0, [pc, #244]	; (ea40 <am_util_faultisr_collect_data+0x470>)
    e94c:	f000 fde0 	bl	f510 <am_util_stdio_printf>
                break;
    e950:	e77c      	b.n	e84c <am_util_faultisr_collect_data+0x27c>
                am_util_stdio_printf("        BFSR bit3: UNSTKERR\n");
    e952:	483c      	ldr	r0, [pc, #240]	; (ea44 <am_util_faultisr_collect_data+0x474>)
    e954:	f000 fddc 	bl	f510 <am_util_stdio_printf>
                break;
    e958:	e778      	b.n	e84c <am_util_faultisr_collect_data+0x27c>
                am_util_stdio_printf("        BFSR bit4: STKERR\n");
    e95a:	483b      	ldr	r0, [pc, #236]	; (ea48 <am_util_faultisr_collect_data+0x478>)
    e95c:	f000 fdd8 	bl	f510 <am_util_stdio_printf>
                break;
    e960:	e774      	b.n	e84c <am_util_faultisr_collect_data+0x27c>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    e962:	4831      	ldr	r0, [pc, #196]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    e964:	f000 fdd4 	bl	f510 <am_util_stdio_printf>
                break;
    e968:	e781      	b.n	e86e <am_util_faultisr_collect_data+0x29e>
                am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    e96a:	4835      	ldr	r0, [pc, #212]	; (ea40 <am_util_faultisr_collect_data+0x470>)
    e96c:	f000 fdd0 	bl	f510 <am_util_stdio_printf>
                break;
    e970:	e77d      	b.n	e86e <am_util_faultisr_collect_data+0x29e>
                am_util_stdio_printf("        BFSR bit3: UNSTKERR\n");
    e972:	4834      	ldr	r0, [pc, #208]	; (ea44 <am_util_faultisr_collect_data+0x474>)
    e974:	f000 fdcc 	bl	f510 <am_util_stdio_printf>
                break;
    e978:	e779      	b.n	e86e <am_util_faultisr_collect_data+0x29e>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    e97a:	482b      	ldr	r0, [pc, #172]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    e97c:	f000 fdc8 	bl	f510 <am_util_stdio_printf>
                break;
    e980:	e7a7      	b.n	e8d2 <am_util_faultisr_collect_data+0x302>
                am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    e982:	482f      	ldr	r0, [pc, #188]	; (ea40 <am_util_faultisr_collect_data+0x470>)
    e984:	f000 fdc4 	bl	f510 <am_util_stdio_printf>
                break;
    e988:	e7a3      	b.n	e8d2 <am_util_faultisr_collect_data+0x302>
                am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    e98a:	482d      	ldr	r0, [pc, #180]	; (ea40 <am_util_faultisr_collect_data+0x470>)
    e98c:	f000 fdc0 	bl	f510 <am_util_stdio_printf>
                break;
    e990:	e747      	b.n	e822 <am_util_faultisr_collect_data+0x252>
                am_util_stdio_printf("        BFSR bit3: UNSTKERR\n");
    e992:	482c      	ldr	r0, [pc, #176]	; (ea44 <am_util_faultisr_collect_data+0x474>)
    e994:	f000 fdbc 	bl	f510 <am_util_stdio_printf>
                break;
    e998:	e743      	b.n	e822 <am_util_faultisr_collect_data+0x252>
                am_util_stdio_printf("        BFSR bit4: STKERR\n");
    e99a:	482b      	ldr	r0, [pc, #172]	; (ea48 <am_util_faultisr_collect_data+0x478>)
    e99c:	f000 fdb8 	bl	f510 <am_util_stdio_printf>
                break;
    e9a0:	e73f      	b.n	e822 <am_util_faultisr_collect_data+0x252>
                am_util_stdio_printf("        BFSR bit5: LSPERR\n");
    e9a2:	482a      	ldr	r0, [pc, #168]	; (ea4c <am_util_faultisr_collect_data+0x47c>)
    e9a4:	f000 fdb4 	bl	f510 <am_util_stdio_printf>
                break;
    e9a8:	e73b      	b.n	e822 <am_util_faultisr_collect_data+0x252>
                am_util_stdio_printf("        BFSR bit3: UNSTKERR\n");
    e9aa:	4826      	ldr	r0, [pc, #152]	; (ea44 <am_util_faultisr_collect_data+0x474>)
    e9ac:	f000 fdb0 	bl	f510 <am_util_stdio_printf>
                break;
    e9b0:	e6db      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
                am_util_stdio_printf("        BFSR bit4: STKERR\n");
    e9b2:	4825      	ldr	r0, [pc, #148]	; (ea48 <am_util_faultisr_collect_data+0x478>)
    e9b4:	f000 fdac 	bl	f510 <am_util_stdio_printf>
                break;
    e9b8:	e6d7      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
                am_util_stdio_printf("        BFSR bit5: LSPERR\n");
    e9ba:	4824      	ldr	r0, [pc, #144]	; (ea4c <am_util_faultisr_collect_data+0x47c>)
    e9bc:	f000 fda8 	bl	f510 <am_util_stdio_printf>
                break;
    e9c0:	e6d3      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e9c2:	4818      	ldr	r0, [pc, #96]	; (ea24 <am_util_faultisr_collect_data+0x454>)
    e9c4:	f000 fda4 	bl	f510 <am_util_stdio_printf>
                break;
    e9c8:	e6fe      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    e9ca:	4817      	ldr	r0, [pc, #92]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    e9cc:	f000 fda0 	bl	f510 <am_util_stdio_printf>
                break;
    e9d0:	e6fa      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    e9d2:	481b      	ldr	r0, [pc, #108]	; (ea40 <am_util_faultisr_collect_data+0x470>)
    e9d4:	f000 fd9c 	bl	f510 <am_util_stdio_printf>
                break;
    e9d8:	e6f6      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit3: UNSTKERR\n");
    e9da:	481a      	ldr	r0, [pc, #104]	; (ea44 <am_util_faultisr_collect_data+0x474>)
    e9dc:	f000 fd98 	bl	f510 <am_util_stdio_printf>
                break;
    e9e0:	e6f2      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit4: STKERR\n");
    e9e2:	4819      	ldr	r0, [pc, #100]	; (ea48 <am_util_faultisr_collect_data+0x478>)
    e9e4:	f000 fd94 	bl	f510 <am_util_stdio_printf>
                break;
    e9e8:	e6ee      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    e9ea:	480e      	ldr	r0, [pc, #56]	; (ea24 <am_util_faultisr_collect_data+0x454>)
    e9ec:	f000 fd90 	bl	f510 <am_util_stdio_printf>
                break;
    e9f0:	e6bb      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    e9f2:	480d      	ldr	r0, [pc, #52]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    e9f4:	f000 fd8c 	bl	f510 <am_util_stdio_printf>
                break;
    e9f8:	e6b7      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
                am_util_stdio_printf("        BFSR bit2: IMPRECISERR\n");
    e9fa:	4811      	ldr	r0, [pc, #68]	; (ea40 <am_util_faultisr_collect_data+0x470>)
    e9fc:	f000 fd88 	bl	f510 <am_util_stdio_printf>
                break;
    ea00:	e6b3      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
                am_util_stdio_printf("        BFSR bit5: LSPERR\n");
    ea02:	4812      	ldr	r0, [pc, #72]	; (ea4c <am_util_faultisr_collect_data+0x47c>)
    ea04:	f000 fd84 	bl	f510 <am_util_stdio_printf>
                break;
    ea08:	e6de      	b.n	e7c8 <am_util_faultisr_collect_data+0x1f8>
                am_util_stdio_printf("        BFSR bit1: PRECISEERR\n");
    ea0a:	4807      	ldr	r0, [pc, #28]	; (ea28 <am_util_faultisr_collect_data+0x458>)
    ea0c:	f000 fd80 	bl	f510 <am_util_stdio_printf>
                break;
    ea10:	e707      	b.n	e822 <am_util_faultisr_collect_data+0x252>
                am_util_stdio_printf("        BFSR bit0: IBUSERR\n");
    ea12:	4804      	ldr	r0, [pc, #16]	; (ea24 <am_util_faultisr_collect_data+0x454>)
    ea14:	f000 fd7c 	bl	f510 <am_util_stdio_printf>
                break;
    ea18:	e766      	b.n	e8e8 <am_util_faultisr_collect_data+0x318>
                am_util_stdio_printf("        BFSR bit6: RESERVED\n");
    ea1a:	4808      	ldr	r0, [pc, #32]	; (ea3c <am_util_faultisr_collect_data+0x46c>)
    ea1c:	f000 fd78 	bl	f510 <am_util_stdio_printf>
                break;
    ea20:	e6a3      	b.n	e76a <am_util_faultisr_collect_data+0x19a>
    ea22:	bf00      	nop
    ea24:	00010d40 	.word	0x00010d40
    ea28:	00010d5c 	.word	0x00010d5c
    ea2c:	00010e34 	.word	0x00010e34
    ea30:	00010e88 	.word	0x00010e88
    ea34:	00010e68 	.word	0x00010e68
    ea38:	00010e48 	.word	0x00010e48
    ea3c:	00010df4 	.word	0x00010df4
    ea40:	00010d7c 	.word	0x00010d7c
    ea44:	00010d9c 	.word	0x00010d9c
    ea48:	00010dbc 	.word	0x00010dbc
    ea4c:	00010dd8 	.word	0x00010dd8

0000ea50 <divu64_10>:
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
    ea50:	2900      	cmp	r1, #0
    ea52:	d047      	beq.n	eae4 <divu64_10+0x94>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ea54:	0843      	lsrs	r3, r0, #1
    ea56:	0882      	lsrs	r2, r0, #2
    ea58:	ea42 7281 	orr.w	r2, r2, r1, lsl #30
    ea5c:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
    ea60:	189b      	adds	r3, r3, r2
    ea62:	ea4f 0291 	mov.w	r2, r1, lsr #2
    ea66:	eb42 0251 	adc.w	r2, r2, r1, lsr #1
        q64 += (q64 >> 4);
    ea6a:	ea4f 1c13 	mov.w	ip, r3, lsr #4
    ea6e:	ea4c 7c02 	orr.w	ip, ip, r2, lsl #28
    ea72:	eb13 030c 	adds.w	r3, r3, ip
    ea76:	eb42 1212 	adc.w	r2, r2, r2, lsr #4
        q64 += (q64 >> 8);
    ea7a:	ea4f 2c13 	mov.w	ip, r3, lsr #8
    ea7e:	ea4c 6c02 	orr.w	ip, ip, r2, lsl #24
    ea82:	eb13 030c 	adds.w	r3, r3, ip
    ea86:	eb42 2212 	adc.w	r2, r2, r2, lsr #8
        q64 += (q64 >> 16);
    ea8a:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    ea8e:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
    ea92:	eb13 030c 	adds.w	r3, r3, ip
    ea96:	eb42 4212 	adc.w	r2, r2, r2, lsr #16
        q64 += (q64 >> 32);
    ea9a:	189b      	adds	r3, r3, r2
    ea9c:	f142 0200 	adc.w	r2, r2, #0
        q64 >>= 3;
    eaa0:	08db      	lsrs	r3, r3, #3
    eaa2:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
    eaa6:	08d2      	lsrs	r2, r2, #3
        r64 = ui64Val - q64*10;
        return q64 + ((r64 + 6) >> 4);
    eaa8:	3006      	adds	r0, #6
{
    eaaa:	b500      	push	{lr}
        r64 = ui64Val - q64*10;
    eaac:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    eab0:	ea4f 0e82 	mov.w	lr, r2, lsl #2
        return q64 + ((r64 + 6) >> 4);
    eab4:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    eab8:	ea4e 7e93 	orr.w	lr, lr, r3, lsr #30
    eabc:	eb1c 0c03 	adds.w	ip, ip, r3
    eac0:	eb42 0e0e 	adc.w	lr, r2, lr
    eac4:	eb1c 0c0c 	adds.w	ip, ip, ip
    eac8:	eb4e 0e0e 	adc.w	lr, lr, lr
        return q64 + ((r64 + 6) >> 4);
    eacc:	ebb0 000c 	subs.w	r0, r0, ip
    ead0:	eb61 010e 	sbc.w	r1, r1, lr
    ead4:	0900      	lsrs	r0, r0, #4
    ead6:	ea40 7001 	orr.w	r0, r0, r1, lsl #28
    eada:	18c0      	adds	r0, r0, r3
    eadc:	eb42 1111 	adc.w	r1, r2, r1, lsr #4
        q32 += (q32 >> 16);
        q32 >>= 3;
        r32 = ui32Val - q32*10;
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    }
}
    eae0:	f85d fb04 	ldr.w	pc, [sp], #4
        q32 = (ui32Val>>1) + (ui32Val>>2);
    eae4:	0883      	lsrs	r3, r0, #2
    eae6:	eb03 0350 	add.w	r3, r3, r0, lsr #1
        q32 += (q32 >> 4);
    eaea:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    eaee:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q32 += (q32 >> 16);
    eaf2:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    eaf6:	08db      	lsrs	r3, r3, #3
        r32 = ui32Val - q32*10;
    eaf8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    eafc:	3006      	adds	r0, #6
    eafe:	eba0 0042 	sub.w	r0, r0, r2, lsl #1
    eb02:	eb03 1010 	add.w	r0, r3, r0, lsr #4
}
    eb06:	4770      	bx	lr

0000eb08 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    eb08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    eb0c:	b089      	sub	sp, #36	; 0x24
    eb0e:	ad01      	add	r5, sp, #4
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    eb10:	46ae      	mov	lr, r5
    eb12:	2401      	movs	r4, #1
    eb14:	e042      	b.n	eb9c <uint64_to_str+0x94>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    eb16:	19db      	adds	r3, r3, r7
    eb18:	eb46 0651 	adc.w	r6, r6, r1, lsr #1
        q64 += (q64 >> 4);
    eb1c:	091f      	lsrs	r7, r3, #4
    eb1e:	ea47 7706 	orr.w	r7, r7, r6, lsl #28
    eb22:	19db      	adds	r3, r3, r7
    eb24:	eb46 1616 	adc.w	r6, r6, r6, lsr #4
        q64 += (q64 >> 8);
    eb28:	0a1f      	lsrs	r7, r3, #8
    eb2a:	ea47 6706 	orr.w	r7, r7, r6, lsl #24
    eb2e:	19db      	adds	r3, r3, r7
    eb30:	eb46 2616 	adc.w	r6, r6, r6, lsr #8
        q64 += (q64 >> 16);
    eb34:	0c1f      	lsrs	r7, r3, #16
    eb36:	ea47 4706 	orr.w	r7, r7, r6, lsl #16
    eb3a:	19db      	adds	r3, r3, r7
    eb3c:	eb46 4616 	adc.w	r6, r6, r6, lsr #16
        q64 += (q64 >> 32);
    eb40:	199b      	adds	r3, r3, r6
    eb42:	f146 0600 	adc.w	r6, r6, #0
        q64 >>= 3;
    eb46:	08db      	lsrs	r3, r3, #3
    eb48:	ea43 7346 	orr.w	r3, r3, r6, lsl #29
    eb4c:	08f6      	lsrs	r6, r6, #3
        return q64 + ((r64 + 6) >> 4);
    eb4e:	1d87      	adds	r7, r0, #6
        r64 = ui64Val - q64*10;
    eb50:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    eb54:	ea4f 0886 	mov.w	r8, r6, lsl #2
        return q64 + ((r64 + 6) >> 4);
    eb58:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    eb5c:	ea48 7893 	orr.w	r8, r8, r3, lsr #30
    eb60:	eb1c 0c03 	adds.w	ip, ip, r3
    eb64:	eb46 0808 	adc.w	r8, r6, r8
    eb68:	eb1c 0c0c 	adds.w	ip, ip, ip
    eb6c:	eb48 0808 	adc.w	r8, r8, r8
        return q64 + ((r64 + 6) >> 4);
    eb70:	ebb7 070c 	subs.w	r7, r7, ip
    eb74:	eb61 0108 	sbc.w	r1, r1, r8
    eb78:	093f      	lsrs	r7, r7, #4
    eb7a:	ea47 7701 	orr.w	r7, r7, r1, lsl #28
    eb7e:	18fb      	adds	r3, r7, r3
        uMod = ui64Val - (u64Tmp * 10);
    eb80:	eb03 0783 	add.w	r7, r3, r3, lsl #2
    eb84:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
        tbuf[ix++] = uMod + '0';
    eb88:	f100 0030 	add.w	r0, r0, #48	; 0x30
    eb8c:	f88e 0000 	strb.w	r0, [lr]
    eb90:	eb46 1111 	adc.w	r1, r6, r1, lsr #4
    eb94:	4618      	mov	r0, r3
    eb96:	3401      	adds	r4, #1
    eb98:	f10e 0e01 	add.w	lr, lr, #1
        q32 = (ui32Val>>1) + (ui32Val>>2);
    eb9c:	ea4f 0c90 	mov.w	ip, r0, lsr #2
    eba0:	eb0c 0c50 	add.w	ip, ip, r0, lsr #1
        q32 += (q32 >> 4);
    eba4:	eb0c 1c1c 	add.w	ip, ip, ip, lsr #4
        q32 += (q32 >> 8);
    eba8:	eb0c 2c1c 	add.w	ip, ip, ip, lsr #8
        q32 += (q32 >> 16);
    ebac:	eb0c 4c1c 	add.w	ip, ip, ip, lsr #16
        q32 >>= 3;
    ebb0:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
        r32 = ui32Val - q32*10;
    ebb4:	eb0c 098c 	add.w	r9, ip, ip, lsl #2
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ebb8:	0843      	lsrs	r3, r0, #1
    ebba:	0887      	lsrs	r7, r0, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ebbc:	f100 0806 	add.w	r8, r0, #6
    ebc0:	eba8 0849 	sub.w	r8, r8, r9, lsl #1
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ebc4:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
    ebc8:	ea47 7781 	orr.w	r7, r7, r1, lsl #30
    ebcc:	088e      	lsrs	r6, r1, #2
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    ebce:	4681      	mov	r9, r0
    if ( ui64Val >> 32 )
    ebd0:	2900      	cmp	r1, #0
    ebd2:	d1a0      	bne.n	eb16 <uint64_to_str+0xe>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ebd4:	eb0c 1018 	add.w	r0, ip, r8, lsr #4
        uMod = ui64Val - (u64Tmp * 10);
    ebd8:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    ebdc:	eba9 0943 	sub.w	r9, r9, r3, lsl #1
        tbuf[ix++] = uMod + '0';
    ebe0:	f109 0930 	add.w	r9, r9, #48	; 0x30
    ebe4:	f88e 9000 	strb.w	r9, [lr]
        ui64Val = u64Tmp;
    } while ( ui64Val );
    ebe8:	2800      	cmp	r0, #0
    ebea:	d1d4      	bne.n	eb96 <uint64_to_str+0x8e>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    ebec:	b14a      	cbz	r2, ec02 <uint64_to_str+0xfa>
    {
        while ( ix-- )
    ebee:	192b      	adds	r3, r5, r4
    ebf0:	1e51      	subs	r1, r2, #1
        {
            *pcBuf++ = tbuf[ix];
    ebf2:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    ebf6:	f801 0f01 	strb.w	r0, [r1, #1]!
        while ( ix-- )
    ebfa:	429d      	cmp	r5, r3
    ebfc:	d1f9      	bne.n	ebf2 <uint64_to_str+0xea>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    ebfe:	2300      	movs	r3, #0
    ec00:	5513      	strb	r3, [r2, r4]
    }

    return iNumDig;
}
    ec02:	4620      	mov	r0, r4
    ec04:	b009      	add	sp, #36	; 0x24
    ec06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ec0a:	bf00      	nop

0000ec0c <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    ec0c:	4b01      	ldr	r3, [pc, #4]	; (ec14 <am_util_stdio_printf_init+0x8>)
    ec0e:	6018      	str	r0, [r3, #0]
}
    ec10:	4770      	bx	lr
    ec12:	bf00      	nop
    ec14:	10002478 	.word	0x10002478

0000ec18 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    ec18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    ec1c:	780b      	ldrb	r3, [r1, #0]
{
    ec1e:	b089      	sub	sp, #36	; 0x24
    ec20:	4605      	mov	r5, r0
    while ( *pcFmt != 0x0 )
    ec22:	2b00      	cmp	r3, #0
    ec24:	f000 8097 	beq.w	ed56 <am_util_stdio_vsprintf+0x13e>
    ec28:	4617      	mov	r7, r2
    uint32_t ui32NumChars, ui32CharCnt = 0;
    ec2a:	2600      	movs	r6, #0
    ec2c:	e00b      	b.n	ec46 <am_util_stdio_vsprintf+0x2e>
        if ( *pcFmt != '%' )
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    ec2e:	b125      	cbz	r5, ec3a <am_util_stdio_vsprintf+0x22>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    ec30:	2b0a      	cmp	r3, #10
    ec32:	f000 8085 	beq.w	ed40 <am_util_stdio_vsprintf+0x128>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    ec36:	f805 3b01 	strb.w	r3, [r5], #1
            }

            ++pcFmt;
    ec3a:	3101      	adds	r1, #1
            ++ui32CharCnt;
    ec3c:	3601      	adds	r6, #1
    while ( *pcFmt != 0x0 )
    ec3e:	780b      	ldrb	r3, [r1, #0]
    ec40:	2b00      	cmp	r3, #0
    ec42:	f000 8089 	beq.w	ed58 <am_util_stdio_vsprintf+0x140>
        if ( *pcFmt != '%' )
    ec46:	2b25      	cmp	r3, #37	; 0x25
    ec48:	d1f1      	bne.n	ec2e <am_util_stdio_vsprintf+0x16>
        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';

        if ( *pcFmt == '0' )
    ec4a:	784b      	ldrb	r3, [r1, #1]
    ec4c:	2b30      	cmp	r3, #48	; 0x30
    ec4e:	f000 8098 	beq.w	ed82 <am_util_stdio_vsprintf+0x16a>
        ++pcFmt;
    ec52:	f101 0e01 	add.w	lr, r1, #1
        ui8PadChar = ' ';
    ec56:	2220      	movs	r2, #32
    if ( *pcStr == '-')
    ec58:	2b2d      	cmp	r3, #45	; 0x2d
    ec5a:	f000 8084 	beq.w	ed66 <am_util_stdio_vsprintf+0x14e>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ec5e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    uint32_t ui32Val = 0, uCnt = 0;
    ec62:	f04f 0c00 	mov.w	ip, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ec66:	2909      	cmp	r1, #9
    ec68:	4674      	mov	r4, lr
    bool bNeg = false;
    ec6a:	46e0      	mov	r8, ip
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ec6c:	f200 8087 	bhi.w	ed7e <am_util_stdio_vsprintf+0x166>
    ec70:	f10c 0c01 	add.w	ip, ip, #1
    ec74:	ebac 0c04 	sub.w	ip, ip, r4
    ec78:	2100      	movs	r1, #0
        ui32Val *= 10;
    ec7a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
        ui32Val += (*pcStr - '0');
    ec7e:	eb03 0141 	add.w	r1, r3, r1, lsl #1
    ec82:	eb04 090c 	add.w	r9, r4, ip
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ec86:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    ec8a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    ec8e:	2809      	cmp	r0, #9
        ui32Val += (*pcStr - '0');
    ec90:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ec94:	d9f1      	bls.n	ec7a <am_util_stdio_vsprintf+0x62>
        pcFmt += ui32NumChars;

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ec96:	f81e 3009 	ldrb.w	r3, [lr, r9]
        pcFmt += ui32NumChars;
    ec9a:	eb0e 0409 	add.w	r4, lr, r9
    return bNeg ? -ui32Val : ui32Val;
    ec9e:	f1b8 0f00 	cmp.w	r8, #0
    eca2:	d000      	beq.n	eca6 <am_util_stdio_vsprintf+0x8e>
    eca4:	4249      	negs	r1, r1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    eca6:	2b73      	cmp	r3, #115	; 0x73
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    eca8:	4608      	mov	r0, r1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ecaa:	f000 8125 	beq.w	eef8 <am_util_stdio_vsprintf+0x2e0>
    ecae:	ea81 78e1 	eor.w	r8, r1, r1, asr #31
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
    ecb2:	2b2e      	cmp	r3, #46	; 0x2e
    ecb4:	eba8 78e1 	sub.w	r8, r8, r1, asr #31
    ecb8:	f000 80f2 	beq.w	eea0 <am_util_stdio_vsprintf+0x288>
        iPrecision = 6;             // printf() default precision for %f is 6
    ecbc:	f04f 0906 	mov.w	r9, #6
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
    ecc0:	2b6c      	cmp	r3, #108	; 0x6c
    ecc2:	d104      	bne.n	ecce <am_util_stdio_vsprintf+0xb6>
        {
            pcFmt++;
            if ( *pcFmt == 'l' )    // "ll" (long long)
    ecc4:	7863      	ldrb	r3, [r4, #1]
    ecc6:	2b6c      	cmp	r3, #108	; 0x6c
    ecc8:	f000 8163 	beq.w	ef92 <am_util_stdio_vsprintf+0x37a>
            pcFmt++;
    eccc:	3401      	adds	r4, #1
                pcFmt++;
                bLongLong = true;
            }
        }

        switch ( *pcFmt )
    ecce:	f1a3 0046 	sub.w	r0, r3, #70	; 0x46
    ecd2:	2832      	cmp	r0, #50	; 0x32
    ecd4:	d85a      	bhi.n	ed8c <am_util_stdio_vsprintf+0x174>
    ecd6:	e8df f010 	tbh	[pc, r0, lsl #1]
    ecda:	005f      	.short	0x005f
    ecdc:	00590059 	.word	0x00590059
    ece0:	00590059 	.word	0x00590059
    ece4:	00590059 	.word	0x00590059
    ece8:	00590059 	.word	0x00590059
    ecec:	00590059 	.word	0x00590059
    ecf0:	00590059 	.word	0x00590059
    ecf4:	00590059 	.word	0x00590059
    ecf8:	00590059 	.word	0x00590059
    ecfc:	01dc0059 	.word	0x01dc0059
    ed00:	00590059 	.word	0x00590059
    ed04:	00590059 	.word	0x00590059
    ed08:	00590059 	.word	0x00590059
    ed0c:	00590059 	.word	0x00590059
    ed10:	00590059 	.word	0x00590059
    ed14:	00b400c9 	.word	0x00b400c9
    ed18:	005f0059 	.word	0x005f0059
    ed1c:	00590059 	.word	0x00590059
    ed20:	005900b4 	.word	0x005900b4
    ed24:	00590059 	.word	0x00590059
    ed28:	00590059 	.word	0x00590059
    ed2c:	00590059 	.word	0x00590059
    ed30:	00590059 	.word	0x00590059
    ed34:	0059010e 	.word	0x0059010e
    ed38:	005900d2 	.word	0x005900d2
    ed3c:	02fb0059 	.word	0x02fb0059
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    ed40:	4acc      	ldr	r2, [pc, #816]	; (f074 <am_util_stdio_vsprintf+0x45c>)
    ed42:	7812      	ldrb	r2, [r2, #0]
    ed44:	2a00      	cmp	r2, #0
    ed46:	f43f af76 	beq.w	ec36 <am_util_stdio_vsprintf+0x1e>
                    *pcBuf++ = '\r';
    ed4a:	230d      	movs	r3, #13
    ed4c:	f805 3b01 	strb.w	r3, [r5], #1
                    ++ui32CharCnt;
    ed50:	3601      	adds	r6, #1
                *pcBuf++ = *pcFmt;
    ed52:	780b      	ldrb	r3, [r1, #0]
    ed54:	e76f      	b.n	ec36 <am_util_stdio_vsprintf+0x1e>
    uint32_t ui32NumChars, ui32CharCnt = 0;
    ed56:	461e      	mov	r6, r3
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    ed58:	b10d      	cbz	r5, ed5e <am_util_stdio_vsprintf+0x146>
    {
        *pcBuf = 0x0;
    ed5a:	2300      	movs	r3, #0
    ed5c:	702b      	strb	r3, [r5, #0]
    }

    return (ui32CharCnt);
}
    ed5e:	4630      	mov	r0, r6
    ed60:	b009      	add	sp, #36	; 0x24
    ed62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ed66:	f89e 3001 	ldrb.w	r3, [lr, #1]
    ed6a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
        uCnt++;
    ed6e:	f04f 0c01 	mov.w	ip, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ed72:	2909      	cmp	r1, #9
        pcStr++;
    ed74:	eb0e 040c 	add.w	r4, lr, ip
        bNeg = true;
    ed78:	46e0      	mov	r8, ip
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ed7a:	f67f af79 	bls.w	ec70 <am_util_stdio_vsprintf+0x58>
    ed7e:	2100      	movs	r1, #0
    ed80:	e78d      	b.n	ec9e <am_util_stdio_vsprintf+0x86>
            ui8PadChar = '0';
    ed82:	461a      	mov	r2, r3
            ++pcFmt;
    ed84:	f101 0e02 	add.w	lr, r1, #2
    if ( *pcStr == '-')
    ed88:	788b      	ldrb	r3, [r1, #2]
    ed8a:	e765      	b.n	ec58 <am_util_stdio_vsprintf+0x40>
                if ( pcBuf )
    ed8c:	b10d      	cbz	r5, ed92 <am_util_stdio_vsprintf+0x17a>
                    *pcBuf++ = *pcFmt;
    ed8e:	f805 3b01 	strb.w	r3, [r5], #1
                ++ui32CharCnt;
    ed92:	3601      	adds	r6, #1
        ++pcFmt;
    ed94:	1c61      	adds	r1, r4, #1
    ed96:	e752      	b.n	ec3e <am_util_stdio_vsprintf+0x26>
                if ( pcBuf )
    ed98:	2d00      	cmp	r5, #0
    ed9a:	d0fb      	beq.n	ed94 <am_util_stdio_vsprintf+0x17c>
                    float fValue = va_arg(pArgs, double);
    ed9c:	3707      	adds	r7, #7
    ed9e:	f027 0707 	bic.w	r7, r7, #7
    eda2:	e8f7 0102 	ldrd	r0, r1, [r7], #8
    eda6:	f7fd fa45 	bl	c234 <__aeabi_d2f>
    edaa:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    edae:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    edb2:	2314      	movs	r3, #20
    if (fValue == 0.0f)
    edb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    *(uint32_t*)pcBuf = 20;
    edb8:	602b      	str	r3, [r5, #0]
    if (fValue == 0.0f)
    edba:	f000 835d 	beq.w	f478 <am_util_stdio_vsprintf+0x860>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    edbe:	f3c0 51c7 	ubfx	r1, r0, #23, #8
    edc2:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
    unFloatValue.F = fValue;
    edc6:	4603      	mov	r3, r0
    if (iExp2 >= 31)
    edc8:	2a1e      	cmp	r2, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    edca:	f3c0 0016 	ubfx	r0, r0, #0, #23
    edce:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    if (iExp2 >= 31)
    edd2:	f300 837c 	bgt.w	f4ce <am_util_stdio_vsprintf+0x8b6>
    else if (iExp2 < -23)
    edd6:	f112 0f17 	cmn.w	r2, #23
    edda:	f2c0 8374 	blt.w	f4c6 <am_util_stdio_vsprintf+0x8ae>
    else if (iExp2 >= 23)
    edde:	2a16      	cmp	r2, #22
    ede0:	f340 8246 	ble.w	f270 <am_util_stdio_vsprintf+0x658>
        i32IntPart = i32Significand << (iExp2 - 23);
    ede4:	3996      	subs	r1, #150	; 0x96
    if (unFloatValue.I32 < 0)
    ede6:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand << (iExp2 - 23);
    ede8:	fa00 f001 	lsl.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
    edec:	f2c0 8287 	blt.w	f2fe <am_util_stdio_vsprintf+0x6e6>
    edf0:	462b      	mov	r3, r5
    i32FracPart = 0;
    edf2:	f04f 0800 	mov.w	r8, #0
    if (i32IntPart == 0)
    edf6:	2800      	cmp	r0, #0
    edf8:	f000 827c 	beq.w	f2f4 <am_util_stdio_vsprintf+0x6dc>
            *pcBuf++ = '-';
    edfc:	461a      	mov	r2, r3
    edfe:	bfde      	ittt	le
    ee00:	232d      	movle	r3, #45	; 0x2d
    ee02:	f802 3b01 	strble.w	r3, [r2], #1
            uint64_to_str(-i32IntPart, pcBuf);
    ee06:	4240      	negle	r0, r0
    ee08:	17c1      	asrs	r1, r0, #31
    ee0a:	f7ff fe7d 	bl	eb08 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
    ee0e:	7813      	ldrb	r3, [r2, #0]
    ee10:	b11b      	cbz	r3, ee1a <am_util_stdio_vsprintf+0x202>
    ee12:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    ee16:	2b00      	cmp	r3, #0
    ee18:	d1fb      	bne.n	ee12 <am_util_stdio_vsprintf+0x1fa>
    *pcBuf++ = '.';
    ee1a:	232e      	movs	r3, #46	; 0x2e
    ee1c:	7013      	strb	r3, [r2, #0]
    if (i32FracPart == 0)
    ee1e:	f1b8 0f00 	cmp.w	r8, #0
    ee22:	f040 8291 	bne.w	f348 <am_util_stdio_vsprintf+0x730>
        *pcBuf++ = '0';
    ee26:	1c90      	adds	r0, r2, #2
    ee28:	2330      	movs	r3, #48	; 0x30
    ee2a:	7053      	strb	r3, [r2, #1]
    return (pcBuf - pcBufInitial);
    ee2c:	1b41      	subs	r1, r0, r5
    *pcBuf = 0x00;
    ee2e:	2300      	movs	r3, #0
                    if ( iVal < 0 )
    ee30:	4299      	cmp	r1, r3
    *pcBuf = 0x00;
    ee32:	7003      	strb	r3, [r0, #0]
                    if ( iVal < 0 )
    ee34:	f2c0 82c3 	blt.w	f3be <am_util_stdio_vsprintf+0x7a6>
                    ui32CharCnt += iVal;
    ee38:	460b      	mov	r3, r1
    ee3a:	441e      	add	r6, r3
                    pcBuf += iVal;
    ee3c:	441d      	add	r5, r3
        ++pcFmt;
    ee3e:	1c61      	adds	r1, r4, #1
    ee40:	e6fd      	b.n	ec3e <am_util_stdio_vsprintf+0x26>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    ee42:	f857 9b04 	ldr.w	r9, [r7], #4
    ee46:	ea4f 7ae9 	mov.w	sl, r9, asr #31
                if ( i64Val < 0 )
    ee4a:	f1ba 0f00 	cmp.w	sl, #0
    ee4e:	f2c0 8113 	blt.w	f078 <am_util_stdio_vsprintf+0x460>
                if ( iWidth )
    ee52:	2900      	cmp	r1, #0
    ee54:	f040 82bd 	bne.w	f3d2 <am_util_stdio_vsprintf+0x7ba>
                iVal = uint64_to_str(ui64Val, pcBuf);
    ee58:	4648      	mov	r0, r9
    ee5a:	4651      	mov	r1, sl
    ee5c:	462a      	mov	r2, r5
    ee5e:	f7ff fe53 	bl	eb08 <uint64_to_str>
                if ( pcBuf )
    ee62:	b9d5      	cbnz	r5, ee9a <am_util_stdio_vsprintf+0x282>
                ui32CharCnt += iVal;
    ee64:	2500      	movs	r5, #0
    ee66:	4406      	add	r6, r0
        ++pcFmt;
    ee68:	1c61      	adds	r1, r4, #1
    ee6a:	e6e8      	b.n	ec3e <am_util_stdio_vsprintf+0x26>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    ee6c:	1d3b      	adds	r3, r7, #4
                if ( pcBuf )
    ee6e:	b115      	cbz	r5, ee76 <am_util_stdio_vsprintf+0x25e>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    ee70:	683a      	ldr	r2, [r7, #0]
    ee72:	f805 2b01 	strb.w	r2, [r5], #1
                ++ui32CharCnt;
    ee76:	3601      	adds	r6, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    ee78:	461f      	mov	r7, r3
        ++pcFmt;
    ee7a:	1c61      	adds	r1, r4, #1
    ee7c:	e6df      	b.n	ec3e <am_util_stdio_vsprintf+0x26>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    ee7e:	f857 ab04 	ldr.w	sl, [r7], #4
    ee82:	f04f 0900 	mov.w	r9, #0
                if ( iWidth )
    ee86:	2900      	cmp	r1, #0
    ee88:	f040 81b0 	bne.w	f1ec <am_util_stdio_vsprintf+0x5d4>
                iVal = uint64_to_str(ui64Val, pcBuf);
    ee8c:	4650      	mov	r0, sl
    ee8e:	4649      	mov	r1, r9
    ee90:	462a      	mov	r2, r5
    ee92:	f7ff fe39 	bl	eb08 <uint64_to_str>
                if ( pcBuf )
    ee96:	2d00      	cmp	r5, #0
    ee98:	d0e4      	beq.n	ee64 <am_util_stdio_vsprintf+0x24c>
                    pcBuf += iVal;
    ee9a:	4405      	add	r5, r0
                ui32CharCnt += iVal;
    ee9c:	4406      	add	r6, r0
                break;
    ee9e:	e7e3      	b.n	ee68 <am_util_stdio_vsprintf+0x250>
    if ( *pcStr == '-')
    eea0:	7860      	ldrb	r0, [r4, #1]
    eea2:	282d      	cmp	r0, #45	; 0x2d
            ++pcFmt;
    eea4:	f104 0c01 	add.w	ip, r4, #1
    if ( *pcStr == '-')
    eea8:	f000 8195 	beq.w	f1d6 <am_util_stdio_vsprintf+0x5be>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    eeac:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    eeb0:	2b09      	cmp	r3, #9
    eeb2:	f200 82ea 	bhi.w	f48a <am_util_stdio_vsprintf+0x872>
    uint32_t ui32Val = 0, uCnt = 0;
    eeb6:	2300      	movs	r3, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    eeb8:	4664      	mov	r4, ip
    bool bNeg = false;
    eeba:	4699      	mov	r9, r3
    eebc:	3301      	adds	r3, #1
    eebe:	eba3 0e04 	sub.w	lr, r3, r4
    eec2:	2300      	movs	r3, #0
        ui32Val *= 10;
    eec4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
        ui32Val += (*pcStr - '0');
    eec8:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    eecc:	eb04 0a0e 	add.w	sl, r4, lr
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    eed0:	f814 0f01 	ldrb.w	r0, [r4, #1]!
    eed4:	f1a0 0b30 	sub.w	fp, r0, #48	; 0x30
    eed8:	f1bb 0f09 	cmp.w	fp, #9
        ui32Val += (*pcStr - '0');
    eedc:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    eee0:	d9f0      	bls.n	eec4 <am_util_stdio_vsprintf+0x2ac>
    return bNeg ? -ui32Val : ui32Val;
    eee2:	f1b9 0f00 	cmp.w	r9, #0
    eee6:	d000      	beq.n	eeea <am_util_stdio_vsprintf+0x2d2>
    eee8:	425b      	negs	r3, r3
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    eeea:	4699      	mov	r9, r3
            pcFmt += ui32NumChars;
    eeec:	eb0c 040a 	add.w	r4, ip, sl
        if ( *pcFmt == 'l' )
    eef0:	f81c 300a 	ldrb.w	r3, [ip, sl]
    eef4:	e6e4      	b.n	ecc0 <am_util_stdio_vsprintf+0xa8>
        switch ( *pcFmt )
    eef6:	4640      	mov	r0, r8
                pcStr = va_arg(pArgs, char *);
    eef8:	46b9      	mov	r9, r7
    eefa:	f859 3b04 	ldr.w	r3, [r9], #4
    if ( !pcBuf )
    eefe:	2b00      	cmp	r3, #0
    ef00:	f000 81c6 	beq.w	f290 <am_util_stdio_vsprintf+0x678>
    while ( *pcBuf++ )
    ef04:	469c      	mov	ip, r3
    ef06:	f81c 1b01 	ldrb.w	r1, [ip], #1
    ef0a:	2900      	cmp	r1, #0
    ef0c:	f000 82c1 	beq.w	f492 <am_util_stdio_vsprintf+0x87a>
    uint32_t ui32RetVal = 0;
    ef10:	f04f 0e00 	mov.w	lr, #0
    while ( *pcBuf++ )
    ef14:	f81c 7b01 	ldrb.w	r7, [ip], #1
        ui32RetVal++;
    ef18:	f10e 0e01 	add.w	lr, lr, #1
    while ( *pcBuf++ )
    ef1c:	2f00      	cmp	r7, #0
    ef1e:	d1f9      	bne.n	ef14 <am_util_stdio_vsprintf+0x2fc>
                if ( iWidth > 0 )
    ef20:	2800      	cmp	r0, #0
    ef22:	dd02      	ble.n	ef2a <am_util_stdio_vsprintf+0x312>
                    if ( ui32strlen < iWidth )
    ef24:	4570      	cmp	r0, lr
    ef26:	f200 81d6 	bhi.w	f2d6 <am_util_stdio_vsprintf+0x6be>
    ef2a:	f1c3 0801 	rsb	r8, r3, #1
                while (*pcStr != 0x0)
    ef2e:	46b2      	mov	sl, r6
    ef30:	462f      	mov	r7, r5
    ef32:	eb08 0c06 	add.w	ip, r8, r6
    ef36:	e000      	b.n	ef3a <am_util_stdio_vsprintf+0x322>
                        *pcBuf++ = *pcStr;
    ef38:	462f      	mov	r7, r5
    ef3a:	eb0c 0603 	add.w	r6, ip, r3
                    if ( pcBuf )
    ef3e:	2d00      	cmp	r5, #0
    ef40:	f000 8131 	beq.w	f1a6 <am_util_stdio_vsprintf+0x58e>
                        *pcBuf++ = *pcStr;
    ef44:	7039      	strb	r1, [r7, #0]
                while (*pcStr != 0x0)
    ef46:	f813 1f01 	ldrb.w	r1, [r3, #1]!
                        *pcBuf++ = *pcStr;
    ef4a:	3501      	adds	r5, #1
                while (*pcStr != 0x0)
    ef4c:	2900      	cmp	r1, #0
    ef4e:	d1f3      	bne.n	ef38 <am_util_stdio_vsprintf+0x320>
                if ( iWidth )
    ef50:	b1e0      	cbz	r0, ef8c <am_util_stdio_vsprintf+0x374>
                    iWidth = -iWidth;
    ef52:	f1c0 0800 	rsb	r8, r0, #0
                    if ( ui32strlen < iWidth )
    ef56:	45f0      	cmp	r8, lr
    ef58:	d918      	bls.n	ef8c <am_util_stdio_vsprintf+0x374>
                        iWidth -= ui32strlen;
    ef5a:	eba8 030e 	sub.w	r3, r8, lr
    if ( i32NumChars <= 0 )
    ef5e:	2b00      	cmp	r3, #0
    ef60:	f340 82b3 	ble.w	f4ca <am_util_stdio_vsprintf+0x8b2>
    while ( i32NumChars-- )
    ef64:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    ef66:	4694      	mov	ip, r2
    ef68:	2000      	movs	r0, #0
    ef6a:	461a      	mov	r2, r3
    ef6c:	462b      	mov	r3, r5
            *pcBuf++ = cPadChar;
    ef6e:	4619      	mov	r1, r3
        if ( pcBuf )
    ef70:	2b00      	cmp	r3, #0
    ef72:	f000 8129 	beq.w	f1c8 <am_util_stdio_vsprintf+0x5b0>
            *pcBuf++ = cPadChar;
    ef76:	f801 cb01 	strb.w	ip, [r1], #1
    ef7a:	4617      	mov	r7, r2
    ef7c:	460b      	mov	r3, r1
        i32Cnt++;
    ef7e:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    ef80:	1e7a      	subs	r2, r7, #1
    ef82:	2f00      	cmp	r7, #0
    ef84:	d1f3      	bne.n	ef6e <am_util_stdio_vsprintf+0x356>
                        ui32CharCnt += iWidth;
    ef86:	4406      	add	r6, r0
                        pcBuf += pcBuf ? iWidth : 0;
    ef88:	b105      	cbz	r5, ef8c <am_util_stdio_vsprintf+0x374>
    ef8a:	4405      	add	r5, r0
                pcStr = va_arg(pArgs, char *);
    ef8c:	464f      	mov	r7, r9
        ++pcFmt;
    ef8e:	1c61      	adds	r1, r4, #1
    ef90:	e655      	b.n	ec3e <am_util_stdio_vsprintf+0x26>
        switch ( *pcFmt )
    ef92:	78a3      	ldrb	r3, [r4, #2]
    ef94:	f1a3 0046 	sub.w	r0, r3, #70	; 0x46
                pcFmt++;
    ef98:	3402      	adds	r4, #2
        switch ( *pcFmt )
    ef9a:	2832      	cmp	r0, #50	; 0x32
    ef9c:	f63f aef6 	bhi.w	ed8c <am_util_stdio_vsprintf+0x174>
    efa0:	f20f 0c04 	addw	ip, pc, #4
    efa4:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
    efa8:	0000ed99 	.word	0x0000ed99
    efac:	0000ed8d 	.word	0x0000ed8d
    efb0:	0000ed8d 	.word	0x0000ed8d
    efb4:	0000ed8d 	.word	0x0000ed8d
    efb8:	0000ed8d 	.word	0x0000ed8d
    efbc:	0000ed8d 	.word	0x0000ed8d
    efc0:	0000ed8d 	.word	0x0000ed8d
    efc4:	0000ed8d 	.word	0x0000ed8d
    efc8:	0000ed8d 	.word	0x0000ed8d
    efcc:	0000ed8d 	.word	0x0000ed8d
    efd0:	0000ed8d 	.word	0x0000ed8d
    efd4:	0000ed8d 	.word	0x0000ed8d
    efd8:	0000ed8d 	.word	0x0000ed8d
    efdc:	0000ed8d 	.word	0x0000ed8d
    efe0:	0000ed8d 	.word	0x0000ed8d
    efe4:	0000ed8d 	.word	0x0000ed8d
    efe8:	0000ed8d 	.word	0x0000ed8d
    efec:	0000ed8d 	.word	0x0000ed8d
    eff0:	0000f321 	.word	0x0000f321
    eff4:	0000ed8d 	.word	0x0000ed8d
    eff8:	0000ed8d 	.word	0x0000ed8d
    effc:	0000ed8d 	.word	0x0000ed8d
    f000:	0000ed8d 	.word	0x0000ed8d
    f004:	0000ed8d 	.word	0x0000ed8d
    f008:	0000ed8d 	.word	0x0000ed8d
    f00c:	0000ed8d 	.word	0x0000ed8d
    f010:	0000ed8d 	.word	0x0000ed8d
    f014:	0000ed8d 	.word	0x0000ed8d
    f018:	0000ed8d 	.word	0x0000ed8d
    f01c:	0000ee6d 	.word	0x0000ee6d
    f020:	0000f0c1 	.word	0x0000f0c1
    f024:	0000ed8d 	.word	0x0000ed8d
    f028:	0000ed99 	.word	0x0000ed99
    f02c:	0000ed8d 	.word	0x0000ed8d
    f030:	0000ed8d 	.word	0x0000ed8d
    f034:	0000f0c1 	.word	0x0000f0c1
    f038:	0000ed8d 	.word	0x0000ed8d
    f03c:	0000ed8d 	.word	0x0000ed8d
    f040:	0000ed8d 	.word	0x0000ed8d
    f044:	0000ed8d 	.word	0x0000ed8d
    f048:	0000ed8d 	.word	0x0000ed8d
    f04c:	0000ed8d 	.word	0x0000ed8d
    f050:	0000ed8d 	.word	0x0000ed8d
    f054:	0000ed8d 	.word	0x0000ed8d
    f058:	0000ed8d 	.word	0x0000ed8d
    f05c:	0000eef7 	.word	0x0000eef7
    f060:	0000ed8d 	.word	0x0000ed8d
    f064:	0000f0d1 	.word	0x0000f0d1
    f068:	0000ed8d 	.word	0x0000ed8d
    f06c:	0000ed8d 	.word	0x0000ed8d
    f070:	0000f335 	.word	0x0000f335
    f074:	10002474 	.word	0x10002474
                    ui64Val = -i64Val;          // Get absolute value
    f078:	f1d9 0900 	rsbs	r9, r9, #0
    f07c:	eb6a 0a4a 	sbc.w	sl, sl, sl, lsl #1
                if ( iWidth )
    f080:	2900      	cmp	r1, #0
    f082:	f040 81fd 	bne.w	f480 <am_util_stdio_vsprintf+0x868>
                        if ( pcBuf )
    f086:	b115      	cbz	r5, f08e <am_util_stdio_vsprintf+0x476>
                            *pcBuf++ = '-';
    f088:	232d      	movs	r3, #45	; 0x2d
    f08a:	f805 3b01 	strb.w	r3, [r5], #1
                        ++ui32CharCnt;
    f08e:	3601      	adds	r6, #1
    f090:	e6e2      	b.n	ee58 <am_util_stdio_vsprintf+0x240>
        bLower = bLongLong = false;
    f092:	f04f 0e00 	mov.w	lr, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f096:	f857 0b04 	ldr.w	r0, [r7], #4
    f09a:	f04f 0c00 	mov.w	ip, #0
                if ( iWidth )
    f09e:	b9f9      	cbnz	r1, f0e0 <am_util_stdio_vsprintf+0x4c8>
    if ( ui64Val == 0 )
    f0a0:	ea50 030c 	orrs.w	r3, r0, ip
    f0a4:	d14d      	bne.n	f142 <am_util_stdio_vsprintf+0x52a>
    if (pcBuf)
    f0a6:	2d00      	cmp	r5, #0
    f0a8:	d079      	beq.n	f19e <am_util_stdio_vsprintf+0x586>
            *pcBuf++ = tbuf[ix];
    f0aa:	462b      	mov	r3, r5
    f0ac:	2230      	movs	r2, #48	; 0x30
    f0ae:	f803 2b01 	strb.w	r2, [r3], #1
    f0b2:	2201      	movs	r2, #1
    f0b4:	461d      	mov	r5, r3
        *pcBuf = 0;
    f0b6:	2100      	movs	r1, #0
    f0b8:	7019      	strb	r1, [r3, #0]
                ui32CharCnt += iVal;
    f0ba:	4416      	add	r6, r2
        ++pcFmt;
    f0bc:	1c61      	adds	r1, r4, #1
    f0be:	e5be      	b.n	ec3e <am_util_stdio_vsprintf+0x26>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f0c0:	3707      	adds	r7, #7
    f0c2:	f027 0707 	bic.w	r7, r7, #7
    f0c6:	f8d7 a004 	ldr.w	sl, [r7, #4]
    f0ca:	f857 9b08 	ldr.w	r9, [r7], #8
    f0ce:	e6bc      	b.n	ee4a <am_util_stdio_vsprintf+0x232>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f0d0:	3707      	adds	r7, #7
    f0d2:	f027 0707 	bic.w	r7, r7, #7
    f0d6:	f8d7 9004 	ldr.w	r9, [r7, #4]
    f0da:	f857 ab08 	ldr.w	sl, [r7], #8
    f0de:	e6d2      	b.n	ee86 <am_util_stdio_vsprintf+0x26e>
    int iDigits = ui64Val ? 0 : 1;
    f0e0:	ea50 030c 	orrs.w	r3, r0, ip
    f0e4:	bf0c      	ite	eq
    f0e6:	2101      	moveq	r1, #1
    f0e8:	2100      	movne	r1, #0
    while ( ui64Val )
    f0ea:	d00b      	beq.n	f104 <am_util_stdio_vsprintf+0x4ec>
    f0ec:	4603      	mov	r3, r0
    f0ee:	46e1      	mov	r9, ip
        ui64Val >>= 4;
    f0f0:	091b      	lsrs	r3, r3, #4
    f0f2:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
    f0f6:	ea4f 1919 	mov.w	r9, r9, lsr #4
    while ( ui64Val )
    f0fa:	ea53 0a09 	orrs.w	sl, r3, r9
        ++iDigits;
    f0fe:	f101 0101 	add.w	r1, r1, #1
    while ( ui64Val )
    f102:	d1f5      	bne.n	f0f0 <am_util_stdio_vsprintf+0x4d8>
                    iWidth -= ndigits_in_hex(ui64Val);
    f104:	eba8 0301 	sub.w	r3, r8, r1
    if ( i32NumChars <= 0 )
    f108:	2b00      	cmp	r3, #0
    f10a:	f340 81b2 	ble.w	f472 <am_util_stdio_vsprintf+0x85a>
    while ( i32NumChars-- )
    f10e:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f110:	4691      	mov	r9, r2
    f112:	4682      	mov	sl, r0
    f114:	f04f 0800 	mov.w	r8, #0
    f118:	462a      	mov	r2, r5
    f11a:	4618      	mov	r0, r3
            *pcBuf++ = cPadChar;
    f11c:	4611      	mov	r1, r2
        if ( pcBuf )
    f11e:	2a00      	cmp	r2, #0
    f120:	d04c      	beq.n	f1bc <am_util_stdio_vsprintf+0x5a4>
            *pcBuf++ = cPadChar;
    f122:	f801 9b01 	strb.w	r9, [r1], #1
    f126:	4603      	mov	r3, r0
    f128:	460a      	mov	r2, r1
        i32Cnt++;
    f12a:	f108 0801 	add.w	r8, r8, #1
    while ( i32NumChars-- )
    f12e:	1e58      	subs	r0, r3, #1
    f130:	2b00      	cmp	r3, #0
    f132:	d1f3      	bne.n	f11c <am_util_stdio_vsprintf+0x504>
                    ui32CharCnt += iWidth;
    f134:	4650      	mov	r0, sl
    f136:	4446      	add	r6, r8
                    pcBuf += pcBuf ? iWidth : 0;
    f138:	b375      	cbz	r5, f198 <am_util_stdio_vsprintf+0x580>
    if ( ui64Val == 0 )
    f13a:	ea50 030c 	orrs.w	r3, r0, ip
                    pcBuf += pcBuf ? iWidth : 0;
    f13e:	4445      	add	r5, r8
    if ( ui64Val == 0 )
    f140:	d0b3      	beq.n	f0aa <am_util_stdio_vsprintf+0x492>
    f142:	f1be 0f00 	cmp.w	lr, #0
    f146:	f10d 080c 	add.w	r8, sp, #12
    f14a:	bf14      	ite	ne
    f14c:	f04f 0927 	movne.w	r9, #39	; 0x27
    f150:	f04f 0907 	moveq.w	r9, #7
    f154:	4641      	mov	r1, r8
    int iNumDig, ix = 0;
    f156:	2200      	movs	r2, #0
        cCh = ui64Val & 0xf;
    f158:	f000 030f 	and.w	r3, r0, #15
        if ( cCh > 9 )
    f15c:	2b09      	cmp	r3, #9
            cCh += bLower ? 0x27 : 0x7;
    f15e:	bf88      	it	hi
    f160:	444b      	addhi	r3, r9
        ui64Val >>= 4;
    f162:	ea4f 1e10 	mov.w	lr, r0, lsr #4
    f166:	ea4e 700c 	orr.w	r0, lr, ip, lsl #28
        tbuf[ix++] = cCh + '0';
    f16a:	3330      	adds	r3, #48	; 0x30
        ui64Val >>= 4;
    f16c:	ea4f 1c1c 	mov.w	ip, ip, lsr #4
        tbuf[ix++] = cCh + '0';
    f170:	f801 3b01 	strb.w	r3, [r1], #1
    while ( ui64Val )
    f174:	ea50 030c 	orrs.w	r3, r0, ip
        tbuf[ix++] = cCh + '0';
    f178:	f102 0201 	add.w	r2, r2, #1
    while ( ui64Val )
    f17c:	d1ec      	bne.n	f158 <am_util_stdio_vsprintf+0x540>
    if (pcBuf)
    f17e:	b17d      	cbz	r5, f1a0 <am_util_stdio_vsprintf+0x588>
    f180:	eb08 0302 	add.w	r3, r8, r2
    f184:	1e69      	subs	r1, r5, #1
            *pcBuf++ = tbuf[ix];
    f186:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    f18a:	f801 0f01 	strb.w	r0, [r1, #1]!
        while (ix--)
    f18e:	4543      	cmp	r3, r8
    f190:	d1f9      	bne.n	f186 <am_util_stdio_vsprintf+0x56e>
            *pcBuf++ = tbuf[ix];
    f192:	18ab      	adds	r3, r5, r2
                    pcBuf += iVal;
    f194:	461d      	mov	r5, r3
    f196:	e78e      	b.n	f0b6 <am_util_stdio_vsprintf+0x49e>
    if ( ui64Val == 0 )
    f198:	ea50 030c 	orrs.w	r3, r0, ip
    f19c:	d1d1      	bne.n	f142 <am_util_stdio_vsprintf+0x52a>
    f19e:	2201      	movs	r2, #1
                if ( pcBuf )
    f1a0:	2500      	movs	r5, #0
                ui32CharCnt += iVal;
    f1a2:	4416      	add	r6, r2
                break;
    f1a4:	e78a      	b.n	f0bc <am_util_stdio_vsprintf+0x4a4>
    f1a6:	eb08 010a 	add.w	r1, r8, sl
                    ++ui32CharCnt;
    f1aa:	18ce      	adds	r6, r1, r3
                while (*pcStr != 0x0)
    f1ac:	f813 7f01 	ldrb.w	r7, [r3, #1]!
    f1b0:	2f00      	cmp	r7, #0
    f1b2:	d1fa      	bne.n	f1aa <am_util_stdio_vsprintf+0x592>
                if ( iWidth )
    f1b4:	2800      	cmp	r0, #0
    f1b6:	f43f aee9 	beq.w	ef8c <am_util_stdio_vsprintf+0x374>
    f1ba:	e6ca      	b.n	ef52 <am_util_stdio_vsprintf+0x33a>
    while ( i32NumChars-- )
    f1bc:	1e43      	subs	r3, r0, #1
        i32Cnt++;
    f1be:	f108 0801 	add.w	r8, r8, #1
    while ( i32NumChars-- )
    f1c2:	2800      	cmp	r0, #0
    f1c4:	d1b1      	bne.n	f12a <am_util_stdio_vsprintf+0x512>
    f1c6:	e7b5      	b.n	f134 <am_util_stdio_vsprintf+0x51c>
    f1c8:	1e57      	subs	r7, r2, #1
        i32Cnt++;
    f1ca:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f1cc:	2a00      	cmp	r2, #0
    f1ce:	f47f aed6 	bne.w	ef7e <am_util_stdio_vsprintf+0x366>
                        ui32CharCnt += iWidth;
    f1d2:	4406      	add	r6, r0
    f1d4:	e6d8      	b.n	ef88 <am_util_stdio_vsprintf+0x370>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f1d6:	78a0      	ldrb	r0, [r4, #2]
    f1d8:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    f1dc:	2b09      	cmp	r3, #9
        pcStr++;
    f1de:	f104 0402 	add.w	r4, r4, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f1e2:	f200 8176 	bhi.w	f4d2 <am_util_stdio_vsprintf+0x8ba>
        uCnt++;
    f1e6:	2301      	movs	r3, #1
        bNeg = true;
    f1e8:	4699      	mov	r9, r3
    f1ea:	e667      	b.n	eebc <am_util_stdio_vsprintf+0x2a4>
    int iNDigits = ui64Val ? 0 : 1;
    f1ec:	ea5a 0309 	orrs.w	r3, sl, r9
    f1f0:	bf0c      	ite	eq
    f1f2:	f04f 0b01 	moveq.w	fp, #1
    f1f6:	f04f 0b00 	movne.w	fp, #0
    while ( ui64Val )
    f1fa:	d012      	beq.n	f222 <am_util_stdio_vsprintf+0x60a>
    f1fc:	4649      	mov	r1, r9
    f1fe:	9400      	str	r4, [sp, #0]
    f200:	4650      	mov	r0, sl
    f202:	465c      	mov	r4, fp
    f204:	46cb      	mov	fp, r9
    f206:	46a9      	mov	r9, r5
    f208:	4615      	mov	r5, r2
        ui64Val = divu64_10(ui64Val);
    f20a:	f7ff fc21 	bl	ea50 <divu64_10>
    while ( ui64Val )
    f20e:	ea50 0301 	orrs.w	r3, r0, r1
        ++iNDigits;
    f212:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    f216:	d1f8      	bne.n	f20a <am_util_stdio_vsprintf+0x5f2>
    f218:	462a      	mov	r2, r5
    f21a:	464d      	mov	r5, r9
    f21c:	46d9      	mov	r9, fp
    f21e:	46a3      	mov	fp, r4
    f220:	9c00      	ldr	r4, [sp, #0]
                    iWidth -= ndigits_in_u64(ui64Val);
    f222:	eba8 030b 	sub.w	r3, r8, fp
    if ( i32NumChars <= 0 )
    f226:	2b00      	cmp	r3, #0
    f228:	f340 8149 	ble.w	f4be <am_util_stdio_vsprintf+0x8a6>
    while ( i32NumChars-- )
    f22c:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f22e:	4694      	mov	ip, r2
    f230:	46a6      	mov	lr, r4
    f232:	2000      	movs	r0, #0
    f234:	462a      	mov	r2, r5
    f236:	461c      	mov	r4, r3
            *pcBuf++ = cPadChar;
    f238:	4611      	mov	r1, r2
        if ( pcBuf )
    f23a:	b1a2      	cbz	r2, f266 <am_util_stdio_vsprintf+0x64e>
            *pcBuf++ = cPadChar;
    f23c:	f801 cb01 	strb.w	ip, [r1], #1
    f240:	4623      	mov	r3, r4
    f242:	460a      	mov	r2, r1
        i32Cnt++;
    f244:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f246:	1e5c      	subs	r4, r3, #1
    f248:	2b00      	cmp	r3, #0
    f24a:	d1f5      	bne.n	f238 <am_util_stdio_vsprintf+0x620>
                    ui32CharCnt += iWidth;
    f24c:	4674      	mov	r4, lr
    f24e:	4406      	add	r6, r0
                    pcBuf += pcBuf ? iWidth : 0;
    f250:	2d00      	cmp	r5, #0
    f252:	f000 8123 	beq.w	f49c <am_util_stdio_vsprintf+0x884>
    f256:	4405      	add	r5, r0
                iVal = uint64_to_str(ui64Val, pcBuf);
    f258:	462a      	mov	r2, r5
    f25a:	4650      	mov	r0, sl
    f25c:	4649      	mov	r1, r9
    f25e:	f7ff fc53 	bl	eb08 <uint64_to_str>
                    pcBuf += iVal;
    f262:	4405      	add	r5, r0
    f264:	e61a      	b.n	ee9c <am_util_stdio_vsprintf+0x284>
    while ( i32NumChars-- )
    f266:	1e63      	subs	r3, r4, #1
        i32Cnt++;
    f268:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f26a:	2c00      	cmp	r4, #0
    f26c:	d1ea      	bne.n	f244 <am_util_stdio_vsprintf+0x62c>
    f26e:	e7ed      	b.n	f24c <am_util_stdio_vsprintf+0x634>
    else if (iExp2 >= 0)
    f270:	2a00      	cmp	r2, #0
    f272:	db36      	blt.n	f2e2 <am_util_stdio_vsprintf+0x6ca>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f274:	f1a1 087e 	sub.w	r8, r1, #126	; 0x7e
    f278:	fa00 f808 	lsl.w	r8, r0, r8
        i32IntPart = i32Significand >> (23 - iExp2);
    f27c:	f1c2 0217 	rsb	r2, r2, #23
    if (unFloatValue.I32 < 0)
    f280:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand >> (23 - iExp2);
    f282:	fa40 f002 	asr.w	r0, r0, r2
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f286:	f028 487f 	bic.w	r8, r8, #4278190080	; 0xff000000
    if (unFloatValue.I32 < 0)
    f28a:	db3a      	blt.n	f302 <am_util_stdio_vsprintf+0x6ea>
    f28c:	462a      	mov	r2, r5
    f28e:	e5bb      	b.n	ee08 <am_util_stdio_vsprintf+0x1f0>
                if ( iWidth > 0 )
    f290:	2800      	cmp	r0, #0
    f292:	dd3b      	ble.n	f30c <am_util_stdio_vsprintf+0x6f4>
        return ui32RetVal;
    f294:	469e      	mov	lr, r3
    int32_t i32Cnt = 0;
    f296:	469c      	mov	ip, r3
    while ( i32NumChars-- )
    f298:	f100 38ff 	add.w	r8, r0, #4294967295
    int32_t i32Cnt = 0;
    f29c:	2100      	movs	r1, #0
    f29e:	462b      	mov	r3, r5
            *pcBuf++ = cPadChar;
    f2a0:	4618      	mov	r0, r3
        if ( pcBuf )
    f2a2:	2b00      	cmp	r3, #0
    f2a4:	d049      	beq.n	f33a <am_util_stdio_vsprintf+0x722>
            *pcBuf++ = cPadChar;
    f2a6:	f800 2b01 	strb.w	r2, [r0], #1
    f2aa:	4647      	mov	r7, r8
    f2ac:	4603      	mov	r3, r0
        i32Cnt++;
    f2ae:	3101      	adds	r1, #1
    while ( i32NumChars-- )
    f2b0:	f107 38ff 	add.w	r8, r7, #4294967295
    f2b4:	2f00      	cmp	r7, #0
    f2b6:	d1f3      	bne.n	f2a0 <am_util_stdio_vsprintf+0x688>
                        ui32CharCnt += iWidth;
    f2b8:	4608      	mov	r0, r1
    f2ba:	440e      	add	r6, r1
                while (*pcStr != 0x0)
    f2bc:	f89c 1000 	ldrb.w	r1, [ip]
                        ui32CharCnt += iWidth;
    f2c0:	4663      	mov	r3, ip
                        pcBuf += pcBuf ? iWidth : 0;
    f2c2:	b105      	cbz	r5, f2c6 <am_util_stdio_vsprintf+0x6ae>
    f2c4:	4405      	add	r5, r0
                while (*pcStr != 0x0)
    f2c6:	2900      	cmp	r1, #0
    f2c8:	f43f ae60 	beq.w	ef8c <am_util_stdio_vsprintf+0x374>
                        iWidth = 0;
    f2cc:	2000      	movs	r0, #0
    f2ce:	e62c      	b.n	ef2a <am_util_stdio_vsprintf+0x312>
        switch ( *pcFmt )
    f2d0:	f04f 0e01 	mov.w	lr, #1
    f2d4:	e6df      	b.n	f096 <am_util_stdio_vsprintf+0x47e>
                        iWidth -= ui32strlen;
    f2d6:	eba0 000e 	sub.w	r0, r0, lr
    if ( i32NumChars <= 0 )
    f2da:	2800      	cmp	r0, #0
    f2dc:	dcdb      	bgt.n	f296 <am_util_stdio_vsprintf+0x67e>
    f2de:	4638      	mov	r0, r7
    f2e0:	e7ef      	b.n	f2c2 <am_util_stdio_vsprintf+0x6aa>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f2e2:	43d2      	mvns	r2, r2
    if (unFloatValue.I32 < 0)
    f2e4:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f2e6:	fa40 f802 	asr.w	r8, r0, r2
        *pcBuf++ = '-';
    f2ea:	462b      	mov	r3, r5
    if (unFloatValue.I32 < 0)
    f2ec:	da02      	bge.n	f2f4 <am_util_stdio_vsprintf+0x6dc>
        *pcBuf++ = '-';
    f2ee:	222d      	movs	r2, #45	; 0x2d
    f2f0:	f803 2b01 	strb.w	r2, [r3], #1
        *pcBuf++ = '0';
    f2f4:	461a      	mov	r2, r3
    f2f6:	2330      	movs	r3, #48	; 0x30
    f2f8:	f802 3b01 	strb.w	r3, [r2], #1
    f2fc:	e58d      	b.n	ee1a <am_util_stdio_vsprintf+0x202>
    i32FracPart = 0;
    f2fe:	f04f 0800 	mov.w	r8, #0
        *pcBuf++ = '-';
    f302:	462b      	mov	r3, r5
    f304:	222d      	movs	r2, #45	; 0x2d
    f306:	f803 2b01 	strb.w	r2, [r3], #1
    f30a:	e574      	b.n	edf6 <am_util_stdio_vsprintf+0x1de>
    while ( *pcBuf++ )
    f30c:	7819      	ldrb	r1, [r3, #0]
                while (*pcStr != 0x0)
    f30e:	469e      	mov	lr, r3
    f310:	2900      	cmp	r1, #0
    f312:	f47f ae0a 	bne.w	ef2a <am_util_stdio_vsprintf+0x312>
    f316:	468e      	mov	lr, r1
                if ( iWidth )
    f318:	2800      	cmp	r0, #0
    f31a:	f43f ae37 	beq.w	ef8c <am_util_stdio_vsprintf+0x374>
    f31e:	e618      	b.n	ef52 <am_util_stdio_vsprintf+0x33a>
        bLower = bLongLong = false;
    f320:	f04f 0e00 	mov.w	lr, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f324:	3707      	adds	r7, #7
    f326:	f027 0707 	bic.w	r7, r7, #7
    f32a:	f8d7 c004 	ldr.w	ip, [r7, #4]
    f32e:	f857 0b08 	ldr.w	r0, [r7], #8
    f332:	e6b4      	b.n	f09e <am_util_stdio_vsprintf+0x486>
        switch ( *pcFmt )
    f334:	f04f 0e01 	mov.w	lr, #1
    f338:	e7f4      	b.n	f324 <am_util_stdio_vsprintf+0x70c>
    while ( i32NumChars-- )
    f33a:	f108 37ff 	add.w	r7, r8, #4294967295
        i32Cnt++;
    f33e:	3101      	adds	r1, #1
    while ( i32NumChars-- )
    f340:	f1b8 0f00 	cmp.w	r8, #0
    f344:	d1b3      	bne.n	f2ae <am_util_stdio_vsprintf+0x696>
    f346:	e7b7      	b.n	f2b8 <am_util_stdio_vsprintf+0x6a0>
    *pcBuf++ = '.';
    f348:	f102 0c01 	add.w	ip, r2, #1
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    f34c:	ebac 0105 	sub.w	r1, ip, r5
    f350:	f1c1 0313 	rsb	r3, r1, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    f354:	454b      	cmp	r3, r9
    f356:	bfa8      	it	ge
    f358:	464b      	movge	r3, r9
        for (jx = 0; jx < iMax; jx++)
    f35a:	2b00      	cmp	r3, #0
    f35c:	f340 80ca 	ble.w	f4f4 <am_util_stdio_vsprintf+0x8dc>
    f360:	1c58      	adds	r0, r3, #1
    f362:	4410      	add	r0, r2
            i32FracPart *= 10;
    f364:	eb08 0888 	add.w	r8, r8, r8, lsl #2
            *pcBuf++ = (i32FracPart >> 24) + '0';
    f368:	ea4f 51e8 	mov.w	r1, r8, asr #23
    f36c:	3130      	adds	r1, #48	; 0x30
    f36e:	f80c 1b01 	strb.w	r1, [ip], #1
            i32FracPart *= 10;
    f372:	ea4f 0848 	mov.w	r8, r8, lsl #1
        for (jx = 0; jx < iMax; jx++)
    f376:	4560      	cmp	r0, ip
            i32FracPart &= 0x00FFFFFF;
    f378:	f028 487f 	bic.w	r8, r8, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    f37c:	d1f2      	bne.n	f364 <am_util_stdio_vsprintf+0x74c>
    f37e:	441a      	add	r2, r3
    return (pcBuf - pcBufInitial);
    f380:	1b41      	subs	r1, r0, r5
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    f382:	eb08 0888 	add.w	r8, r8, r8, lsl #2
    f386:	f348 53c7 	sbfx	r3, r8, #23, #8
    f38a:	2b04      	cmp	r3, #4
    f38c:	f77f ad4f 	ble.w	ee2e <am_util_stdio_vsprintf+0x216>
            while ( pcBuftmp >= pcBufInitial )
    f390:	4295      	cmp	r5, r2
    f392:	f63f ad4c 	bhi.w	ee2e <am_util_stdio_vsprintf+0x216>
    f396:	4613      	mov	r3, r2
                    *pcBuftmp = '0';
    f398:	f04f 0e30 	mov.w	lr, #48	; 0x30
    f39c:	e004      	b.n	f3a8 <am_util_stdio_vsprintf+0x790>
    f39e:	f883 e001 	strb.w	lr, [r3, #1]
            while ( pcBuftmp >= pcBufInitial )
    f3a2:	429d      	cmp	r5, r3
    f3a4:	f63f ad43 	bhi.w	ee2e <am_util_stdio_vsprintf+0x216>
                    *pcBuftmp = '0';
    f3a8:	469c      	mov	ip, r3
                if ( *pcBuftmp == '.' )
    f3aa:	f813 2901 	ldrb.w	r2, [r3], #-1
    f3ae:	2a2e      	cmp	r2, #46	; 0x2e
    f3b0:	d0f7      	beq.n	f3a2 <am_util_stdio_vsprintf+0x78a>
                else if ( *pcBuftmp == '9' )
    f3b2:	2a39      	cmp	r2, #57	; 0x39
    f3b4:	d0f3      	beq.n	f39e <am_util_stdio_vsprintf+0x786>
                    *pcBuftmp += 1;
    f3b6:	3201      	adds	r2, #1
    f3b8:	f88c 2000 	strb.w	r2, [ip]
                    break;
    f3bc:	e537      	b.n	ee2e <am_util_stdio_vsprintf+0x216>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    f3be:	1c4b      	adds	r3, r1, #1
    f3c0:	f000 8081 	beq.w	f4c6 <am_util_stdio_vsprintf+0x8ae>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    f3c4:	3102      	adds	r1, #2
    f3c6:	f000 8082 	beq.w	f4ce <am_util_stdio_vsprintf+0x8b6>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    f3ca:	4b4e      	ldr	r3, [pc, #312]	; (f504 <am_util_stdio_vsprintf+0x8ec>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    f3cc:	602b      	str	r3, [r5, #0]
    f3ce:	2303      	movs	r3, #3
    f3d0:	e533      	b.n	ee3a <am_util_stdio_vsprintf+0x222>
    int iNDigits = ui64Val ? 0 : 1;
    f3d2:	ea59 010a 	orrs.w	r1, r9, sl
    f3d6:	bf0c      	ite	eq
    f3d8:	f04f 0b01 	moveq.w	fp, #1
    f3dc:	f04f 0b00 	movne.w	fp, #0
    while ( ui64Val )
    f3e0:	f000 808a 	beq.w	f4f8 <am_util_stdio_vsprintf+0x8e0>
                    bNeg = false;
    f3e4:	2300      	movs	r3, #0
    f3e6:	9300      	str	r3, [sp, #0]
    f3e8:	4648      	mov	r0, r9
    f3ea:	4651      	mov	r1, sl
    f3ec:	9401      	str	r4, [sp, #4]
    f3ee:	465c      	mov	r4, fp
    f3f0:	46d3      	mov	fp, sl
    f3f2:	46ca      	mov	sl, r9
    f3f4:	46a9      	mov	r9, r5
    f3f6:	4615      	mov	r5, r2
        ui64Val = divu64_10(ui64Val);
    f3f8:	f7ff fb2a 	bl	ea50 <divu64_10>
    while ( ui64Val )
    f3fc:	ea50 0301 	orrs.w	r3, r0, r1
        ++iNDigits;
    f400:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    f404:	d1f8      	bne.n	f3f8 <am_util_stdio_vsprintf+0x7e0>
                    if ( bNeg )
    f406:	9900      	ldr	r1, [sp, #0]
                    iWidth -= ndigits_in_i64(ui64Val);
    f408:	462a      	mov	r2, r5
    f40a:	464d      	mov	r5, r9
    f40c:	46d1      	mov	r9, sl
    f40e:	46da      	mov	sl, fp
    f410:	46a3      	mov	fp, r4
    f412:	eba8 030b 	sub.w	r3, r8, fp
    f416:	9c01      	ldr	r4, [sp, #4]
                    if ( bNeg )
    f418:	b119      	cbz	r1, f422 <am_util_stdio_vsprintf+0x80a>
                        if ( ui8PadChar == '0' )
    f41a:	2a30      	cmp	r2, #48	; 0x30
                        --iWidth;
    f41c:	f103 33ff 	add.w	r3, r3, #4294967295
                        if ( ui8PadChar == '0' )
    f420:	d062      	beq.n	f4e8 <am_util_stdio_vsprintf+0x8d0>
    if ( i32NumChars <= 0 )
    f422:	2b00      	cmp	r3, #0
    f424:	dd4d      	ble.n	f4c2 <am_util_stdio_vsprintf+0x8aa>
    while ( i32NumChars-- )
    f426:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f428:	4694      	mov	ip, r2
    f42a:	46a6      	mov	lr, r4
    f42c:	2000      	movs	r0, #0
    f42e:	462a      	mov	r2, r5
    f430:	461c      	mov	r4, r3
            *pcBuf++ = cPadChar;
    f432:	4611      	mov	r1, r2
        if ( pcBuf )
    f434:	b1c2      	cbz	r2, f468 <am_util_stdio_vsprintf+0x850>
            *pcBuf++ = cPadChar;
    f436:	f801 cb01 	strb.w	ip, [r1], #1
    f43a:	4623      	mov	r3, r4
    f43c:	460a      	mov	r2, r1
        i32Cnt++;
    f43e:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f440:	1e5c      	subs	r4, r3, #1
    f442:	2b00      	cmp	r3, #0
    f444:	d1f5      	bne.n	f432 <am_util_stdio_vsprintf+0x81a>
    f446:	4674      	mov	r4, lr
    f448:	4662      	mov	r2, ip
                    ui32CharCnt += iWidth;
    f44a:	4406      	add	r6, r0
                    pcBuf += pcBuf ? iWidth : 0;
    f44c:	b365      	cbz	r5, f4a8 <am_util_stdio_vsprintf+0x890>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f44e:	9b00      	ldr	r3, [sp, #0]
                    pcBuf += pcBuf ? iWidth : 0;
    f450:	4405      	add	r5, r0
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f452:	b113      	cbz	r3, f45a <am_util_stdio_vsprintf+0x842>
    f454:	2a20      	cmp	r2, #32
    f456:	f43f ae17 	beq.w	f088 <am_util_stdio_vsprintf+0x470>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f45a:	462a      	mov	r2, r5
    f45c:	4648      	mov	r0, r9
    f45e:	4651      	mov	r1, sl
    f460:	f7ff fb52 	bl	eb08 <uint64_to_str>
                    pcBuf += iVal;
    f464:	4405      	add	r5, r0
    f466:	e519      	b.n	ee9c <am_util_stdio_vsprintf+0x284>
    while ( i32NumChars-- )
    f468:	1e63      	subs	r3, r4, #1
        i32Cnt++;
    f46a:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f46c:	2c00      	cmp	r4, #0
    f46e:	d1e6      	bne.n	f43e <am_util_stdio_vsprintf+0x826>
    f470:	e7e9      	b.n	f446 <am_util_stdio_vsprintf+0x82e>
    f472:	f04f 0800 	mov.w	r8, #0
    f476:	e65f      	b.n	f138 <am_util_stdio_vsprintf+0x520>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    f478:	4b23      	ldr	r3, [pc, #140]	; (f508 <am_util_stdio_vsprintf+0x8f0>)
    f47a:	602b      	str	r3, [r5, #0]
    f47c:	2303      	movs	r3, #3
    f47e:	e4dc      	b.n	ee3a <am_util_stdio_vsprintf+0x222>
                    bNeg = true;
    f480:	2301      	movs	r3, #1
    f482:	9300      	str	r3, [sp, #0]
    int iNDigits = ui64Val ? 0 : 1;
    f484:	f04f 0b00 	mov.w	fp, #0
    f488:	e7ae      	b.n	f3e8 <am_util_stdio_vsprintf+0x7d0>
    uint32_t ui32Val = 0, uCnt = 0;
    f48a:	f04f 0a00 	mov.w	sl, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f48e:	4653      	mov	r3, sl
    f490:	e52b      	b.n	eeea <am_util_stdio_vsprintf+0x2d2>
                if ( iWidth > 0 )
    f492:	2800      	cmp	r0, #0
    f494:	f77f af3f 	ble.w	f316 <am_util_stdio_vsprintf+0x6fe>
    uint32_t ui32RetVal = 0;
    f498:	468e      	mov	lr, r1
    f49a:	e6fc      	b.n	f296 <am_util_stdio_vsprintf+0x67e>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f49c:	462a      	mov	r2, r5
    f49e:	4650      	mov	r0, sl
    f4a0:	4649      	mov	r1, r9
    f4a2:	f7ff fb31 	bl	eb08 <uint64_to_str>
                if ( pcBuf )
    f4a6:	e4dd      	b.n	ee64 <am_util_stdio_vsprintf+0x24c>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f4a8:	9b00      	ldr	r3, [sp, #0]
    f4aa:	b1b3      	cbz	r3, f4da <am_util_stdio_vsprintf+0x8c2>
    f4ac:	2a20      	cmp	r2, #32
    f4ae:	f43f adee 	beq.w	f08e <am_util_stdio_vsprintf+0x476>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f4b2:	462a      	mov	r2, r5
    f4b4:	4648      	mov	r0, r9
    f4b6:	4651      	mov	r1, sl
    f4b8:	f7ff fb26 	bl	eb08 <uint64_to_str>
                if ( pcBuf )
    f4bc:	e4d2      	b.n	ee64 <am_util_stdio_vsprintf+0x24c>
    f4be:	2000      	movs	r0, #0
    f4c0:	e6c6      	b.n	f250 <am_util_stdio_vsprintf+0x638>
    f4c2:	2000      	movs	r0, #0
    f4c4:	e7c2      	b.n	f44c <am_util_stdio_vsprintf+0x834>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    f4c6:	4b10      	ldr	r3, [pc, #64]	; (f508 <am_util_stdio_vsprintf+0x8f0>)
    f4c8:	e780      	b.n	f3cc <am_util_stdio_vsprintf+0x7b4>
    f4ca:	2000      	movs	r0, #0
    f4cc:	e55c      	b.n	ef88 <am_util_stdio_vsprintf+0x370>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    f4ce:	4b0f      	ldr	r3, [pc, #60]	; (f50c <am_util_stdio_vsprintf+0x8f4>)
    f4d0:	e77c      	b.n	f3cc <am_util_stdio_vsprintf+0x7b4>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f4d2:	2300      	movs	r3, #0
        uCnt++;
    f4d4:	f04f 0a01 	mov.w	sl, #1
    f4d8:	e506      	b.n	eee8 <am_util_stdio_vsprintf+0x2d0>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f4da:	4648      	mov	r0, r9
    f4dc:	4651      	mov	r1, sl
    f4de:	462a      	mov	r2, r5
    f4e0:	f7ff fb12 	bl	eb08 <uint64_to_str>
                ui32CharCnt += iVal;
    f4e4:	4406      	add	r6, r0
                break;
    f4e6:	e4bf      	b.n	ee68 <am_util_stdio_vsprintf+0x250>
                            if ( pcBuf )
    f4e8:	b115      	cbz	r5, f4f0 <am_util_stdio_vsprintf+0x8d8>
                                *pcBuf++ = '-';
    f4ea:	212d      	movs	r1, #45	; 0x2d
    f4ec:	f805 1b01 	strb.w	r1, [r5], #1
                            ++ui32CharCnt;
    f4f0:	3601      	adds	r6, #1
    f4f2:	e796      	b.n	f422 <am_util_stdio_vsprintf+0x80a>
    *pcBuf++ = '.';
    f4f4:	4660      	mov	r0, ip
    f4f6:	e744      	b.n	f382 <am_util_stdio_vsprintf+0x76a>
                    iWidth -= ndigits_in_i64(ui64Val);
    f4f8:	eba8 030b 	sub.w	r3, r8, fp
                    bNeg = false;
    f4fc:	468a      	mov	sl, r1
    f4fe:	9100      	str	r1, [sp, #0]
                    ui64Val = i64Val;
    f500:	4689      	mov	r9, r1
    f502:	e78e      	b.n	f422 <am_util_stdio_vsprintf+0x80a>
    f504:	003f2e3f 	.word	0x003f2e3f
    f508:	00302e30 	.word	0x00302e30
    f50c:	00232e23 	.word	0x00232e23

0000f510 <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    f510:	b40f      	push	{r0, r1, r2, r3}
    f512:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;

    if (!g_pfnCharPrint)
    f514:	4d09      	ldr	r5, [pc, #36]	; (f53c <am_util_stdio_printf+0x2c>)
    f516:	682c      	ldr	r4, [r5, #0]
{
    f518:	b083      	sub	sp, #12
    if (!g_pfnCharPrint)
    f51a:	b14c      	cbz	r4, f530 <am_util_stdio_printf+0x20>

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    f51c:	aa07      	add	r2, sp, #28
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f51e:	9906      	ldr	r1, [sp, #24]
    f520:	4807      	ldr	r0, [pc, #28]	; (f540 <am_util_stdio_printf+0x30>)
    va_start(pArgs, pcFmt);
    f522:	9201      	str	r2, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f524:	f7ff fb78 	bl	ec18 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    f528:	682b      	ldr	r3, [r5, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f52a:	4604      	mov	r4, r0
    g_pfnCharPrint(g_prfbuf);
    f52c:	4804      	ldr	r0, [pc, #16]	; (f540 <am_util_stdio_printf+0x30>)
    f52e:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
    f530:	4620      	mov	r0, r4
    f532:	b003      	add	sp, #12
    f534:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    f538:	b004      	add	sp, #16
    f53a:	4770      	bx	lr
    f53c:	10002478 	.word	0x10002478
    f540:	1000247c 	.word	0x1000247c

0000f544 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    f544:	b570      	push	{r4, r5, r6, lr}
    f546:	4605      	mov	r5, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    f548:	f7fe fae0 	bl	db0c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    f54c:	4927      	ldr	r1, [pc, #156]	; (f5ec <pvPortMalloc+0xa8>)
    f54e:	680a      	ldr	r2, [r1, #0]
    f550:	b972      	cbnz	r2, f570 <pvPortMalloc+0x2c>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    f552:	4b27      	ldr	r3, [pc, #156]	; (f5f0 <pvPortMalloc+0xac>)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    f554:	4827      	ldr	r0, [pc, #156]	; (f5f4 <pvPortMalloc+0xb0>)
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    f556:	f023 0307 	bic.w	r3, r3, #7
	xStart.xBlockSize = ( size_t ) 0;
    f55a:	e9c0 3200 	strd	r3, r2, [r0]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    f55e:	4826      	ldr	r0, [pc, #152]	; (f5f8 <pvPortMalloc+0xb4>)

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    f560:	6018      	str	r0, [r3, #0]
	xEnd.pxNextFreeBlock = NULL;
    f562:	6002      	str	r2, [r0, #0]
			xHeapHasBeenInitialised = pdTRUE;
    f564:	2201      	movs	r2, #1
    f566:	600a      	str	r2, [r1, #0]
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    f568:	f643 72f8 	movw	r2, #16376	; 0x3ff8
    f56c:	6042      	str	r2, [r0, #4]
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    f56e:	605a      	str	r2, [r3, #4]
		if( xWantedSize > 0 )
    f570:	b935      	cbnz	r5, f580 <pvPortMalloc+0x3c>
			vApplicationMallocFailedHook();
    f572:	2500      	movs	r5, #0
	( void ) xTaskResumeAll();
    f574:	f7fe fc12 	bl	dd9c <xTaskResumeAll>
			vApplicationMallocFailedHook();
    f578:	f7fd f83a 	bl	c5f0 <vApplicationMallocFailedHook>
}
    f57c:	4628      	mov	r0, r5
    f57e:	bd70      	pop	{r4, r5, r6, pc}
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
    f580:	076b      	lsls	r3, r5, #29
			xWantedSize += heapSTRUCT_SIZE;
    f582:	f105 0408 	add.w	r4, r5, #8
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    f586:	bf1c      	itt	ne
    f588:	f024 0407 	bicne.w	r4, r4, #7
    f58c:	3408      	addne	r4, #8
		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    f58e:	1e62      	subs	r2, r4, #1
    f590:	f643 73f6 	movw	r3, #16374	; 0x3ff6
    f594:	429a      	cmp	r2, r3
    f596:	d8ec      	bhi.n	f572 <pvPortMalloc+0x2e>
			pxBlock = xStart.pxNextFreeBlock;
    f598:	4816      	ldr	r0, [pc, #88]	; (f5f4 <pvPortMalloc+0xb0>)
    f59a:	6803      	ldr	r3, [r0, #0]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    f59c:	e003      	b.n	f5a6 <pvPortMalloc+0x62>
    f59e:	681a      	ldr	r2, [r3, #0]
    f5a0:	b122      	cbz	r2, f5ac <pvPortMalloc+0x68>
    f5a2:	4618      	mov	r0, r3
    f5a4:	4613      	mov	r3, r2
    f5a6:	6859      	ldr	r1, [r3, #4]
    f5a8:	42a1      	cmp	r1, r4
    f5aa:	d3f8      	bcc.n	f59e <pvPortMalloc+0x5a>
			if( pxBlock != &xEnd )
    f5ac:	4a12      	ldr	r2, [pc, #72]	; (f5f8 <pvPortMalloc+0xb4>)
    f5ae:	4293      	cmp	r3, r2
    f5b0:	d0df      	beq.n	f572 <pvPortMalloc+0x2e>
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    f5b2:	461d      	mov	r5, r3
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    f5b4:	1b0a      	subs	r2, r1, r4
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    f5b6:	f855 6b08 	ldr.w	r6, [r5], #8
    f5ba:	6006      	str	r6, [r0, #0]
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    f5bc:	2a10      	cmp	r2, #16
    f5be:	d90c      	bls.n	f5da <pvPortMalloc+0x96>
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    f5c0:	191e      	adds	r6, r3, r4
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    f5c2:	6072      	str	r2, [r6, #4]
					pxBlock->xBlockSize = xWantedSize;
    f5c4:	605c      	str	r4, [r3, #4]
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    f5c6:	6871      	ldr	r1, [r6, #4]
    f5c8:	4b0a      	ldr	r3, [pc, #40]	; (f5f4 <pvPortMalloc+0xb0>)
    f5ca:	4618      	mov	r0, r3
    f5cc:	681b      	ldr	r3, [r3, #0]
    f5ce:	685a      	ldr	r2, [r3, #4]
    f5d0:	428a      	cmp	r2, r1
    f5d2:	d3fa      	bcc.n	f5ca <pvPortMalloc+0x86>
    f5d4:	6033      	str	r3, [r6, #0]
    f5d6:	4621      	mov	r1, r4
    f5d8:	6006      	str	r6, [r0, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    f5da:	4a08      	ldr	r2, [pc, #32]	; (f5fc <pvPortMalloc+0xb8>)
    f5dc:	6813      	ldr	r3, [r2, #0]
    f5de:	1a5b      	subs	r3, r3, r1
    f5e0:	6013      	str	r3, [r2, #0]
	( void ) xTaskResumeAll();
    f5e2:	f7fe fbdb 	bl	dd9c <xTaskResumeAll>
}
    f5e6:	4628      	mov	r0, r5
    f5e8:	bd70      	pop	{r4, r5, r6, pc}
    f5ea:	bf00      	nop
    f5ec:	10006584 	.word	0x10006584
    f5f0:	10002584 	.word	0x10002584
    f5f4:	10006588 	.word	0x10006588
    f5f8:	1000657c 	.word	0x1000657c
    f5fc:	10002304 	.word	0x10002304

0000f600 <vPortFree>:
	if( pv != NULL )
    f600:	b1c0      	cbz	r0, f634 <vPortFree+0x34>
{
    f602:	b538      	push	{r3, r4, r5, lr}
    f604:	4604      	mov	r4, r0
		vTaskSuspendAll();
    f606:	f7fe fa81 	bl	db0c <vTaskSuspendAll>
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    f60a:	f854 1c04 	ldr.w	r1, [r4, #-4]
    f60e:	4b0a      	ldr	r3, [pc, #40]	; (f638 <vPortFree+0x38>)
		puc -= heapSTRUCT_SIZE;
    f610:	f1a4 0508 	sub.w	r5, r4, #8
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    f614:	4618      	mov	r0, r3
    f616:	681b      	ldr	r3, [r3, #0]
    f618:	685a      	ldr	r2, [r3, #4]
    f61a:	428a      	cmp	r2, r1
    f61c:	d3fa      	bcc.n	f614 <vPortFree+0x14>
			xFreeBytesRemaining += pxLink->xBlockSize;
    f61e:	4a07      	ldr	r2, [pc, #28]	; (f63c <vPortFree+0x3c>)
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    f620:	f844 3c08 	str.w	r3, [r4, #-8]
			xFreeBytesRemaining += pxLink->xBlockSize;
    f624:	6813      	ldr	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    f626:	6005      	str	r5, [r0, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    f628:	440b      	add	r3, r1
    f62a:	6013      	str	r3, [r2, #0]
}
    f62c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		( void ) xTaskResumeAll();
    f630:	f7fe bbb4 	b.w	dd9c <xTaskResumeAll>
    f634:	4770      	bx	lr
    f636:	bf00      	nop
    f638:	10006588 	.word	0x10006588
    f63c:	10002304 	.word	0x10002304

0000f640 <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    f640:	b358      	cbz	r0, f69a <am_devices_led_array_init+0x5a>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    f642:	1e4b      	subs	r3, r1, #1
    f644:	2b1e      	cmp	r3, #30
    f646:	d828      	bhi.n	f69a <am_devices_led_array_init+0x5a>
{
    f648:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f64c:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    f650:	f8df 804c 	ldr.w	r8, [pc, #76]	; f6a0 <am_devices_led_array_init+0x60>
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    f654:	4f11      	ldr	r7, [pc, #68]	; (f69c <am_devices_led_array_init+0x5c>)
    f656:	4605      	mov	r5, r0
    f658:	1d04      	adds	r4, r0, #4
    f65a:	1d0e      	adds	r6, r1, #4
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    f65c:	f854 0c04 	ldr.w	r0, [r4, #-4]
    if ( (psLED == NULL)    ||
    f660:	2831      	cmp	r0, #49	; 0x31
    f662:	d813      	bhi.n	f68c <am_devices_led_array_init+0x4c>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    f664:	686b      	ldr	r3, [r5, #4]
    f666:	079b      	lsls	r3, r3, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    f668:	bf4c      	ite	mi
    f66a:	6839      	ldrmi	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    f66c:	f8d8 1000 	ldrpl.w	r1, [r8]
    f670:	f000 fc3e 	bl	fef0 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    f674:	2103      	movs	r1, #3
    f676:	f854 0c04 	ldr.w	r0, [r4, #-4]
    f67a:	f000 fda5 	bl	101c8 <am_hal_gpio_state_write>
                                AM_HAL_GPIO_OUTPUT_SET : AM_HAL_GPIO_OUTPUT_CLEAR);
    f67e:	6869      	ldr	r1, [r5, #4]
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    f680:	f854 0c04 	ldr.w	r0, [r4, #-4]
    f684:	f001 0101 	and.w	r1, r1, #1
    f688:	f000 fd9e 	bl	101c8 <am_hal_gpio_state_write>
    for ( i = 0; i < ui32NumLEDs; i++ )
    f68c:	3408      	adds	r4, #8
    f68e:	42b4      	cmp	r4, r6
    f690:	f105 0508 	add.w	r5, r5, #8
    f694:	d1e2      	bne.n	f65c <am_devices_led_array_init+0x1c>
    {
        am_devices_led_init(psLEDs + i);
    }
}
    f696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f69a:	4770      	bx	lr
    f69c:	00010ec0 	.word	0x00010ec0
    f6a0:	00010ec4 	.word	0x00010ec4

0000f6a4 <am_devices_led_off>:
//
//*****************************************************************************
void
am_devices_led_off(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    f6a4:	b180      	cbz	r0, f6c8 <am_devices_led_off+0x24>
    f6a6:	291e      	cmp	r1, #30
    f6a8:	d80e      	bhi.n	f6c8 <am_devices_led_off+0x24>
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    f6aa:	f850 3031 	ldr.w	r3, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    f6ae:	2b31      	cmp	r3, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    f6b0:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    f6b4:	d808      	bhi.n	f6c8 <am_devices_led_off+0x24>
#else
#if (1 == AM_APOLLO3_GPIO)
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    f6b6:	6849      	ldr	r1, [r1, #4]
    f6b8:	078a      	lsls	r2, r1, #30
    f6ba:	d506      	bpl.n	f6ca <am_devices_led_off+0x26>
    {
        //
        // Set the output to the correct state for the LED.
        //
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f6bc:	43c9      	mvns	r1, r1
    f6be:	f001 0101 	and.w	r1, r1, #1
    f6c2:	4618      	mov	r0, r3
    f6c4:	f000 bd80 	b.w	101c8 <am_hal_gpio_state_write>
        //
        am_hal_gpio_out_enable_bit_clear(psLEDs[ui32LEDNum].ui32GPIONumber);
    }
#endif // AM_APOLLO3_GPIO
#endif
}
    f6c8:	4770      	bx	lr
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f6ca:	2103      	movs	r1, #3
    f6cc:	4618      	mov	r0, r3
    f6ce:	f000 bd7b 	b.w	101c8 <am_hal_gpio_state_write>
    f6d2:	bf00      	nop

0000f6d4 <am_devices_led_toggle>:
//
//*****************************************************************************
void
am_devices_led_toggle(am_devices_led_t *psLEDs, uint32_t ui32LEDNum)
{
    if ( (psLEDs == NULL)                       ||
    f6d4:	b310      	cbz	r0, f71c <am_devices_led_toggle+0x48>
{
    f6d6:	b530      	push	{r4, r5, lr}
    if ( (psLEDs == NULL)                       ||
    f6d8:	291e      	cmp	r1, #30
{
    f6da:	b083      	sub	sp, #12
    f6dc:	460d      	mov	r5, r1
    if ( (psLEDs == NULL)                       ||
    f6de:	d815      	bhi.n	f70c <am_devices_led_toggle+0x38>
    f6e0:	4604      	mov	r4, r0
         (ui32LEDNum >= MAX_LEDS)               ||
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    f6e2:	f850 0031 	ldr.w	r0, [r0, r1, lsl #3]
         (ui32LEDNum >= MAX_LEDS)               ||
    f6e6:	2831      	cmp	r0, #49	; 0x31
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    f6e8:	eb04 03c1 	add.w	r3, r4, r1, lsl #3
         (ui32LEDNum >= MAX_LEDS)               ||
    f6ec:	d80e      	bhi.n	f70c <am_devices_led_toggle+0x38>
#else
#if (1 == AM_APOLLO3_GPIO)
    //
    // Handle Direct Drive Versus 3-State (with pull-up or no buffer).
    //
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    f6ee:	685b      	ldr	r3, [r3, #4]
    f6f0:	079b      	lsls	r3, r3, #30
    f6f2:	d40d      	bmi.n	f710 <am_devices_led_toggle+0x3c>
        uint32_t ui32Ret, ui32Value;

        //
        // Check to see if the LED pin is enabled.
        //
        ui32Ret = am_hal_gpio_state_read(psLEDs[ui32LEDNum].ui32GPIONumber,
    f6f4:	aa01      	add	r2, sp, #4
    f6f6:	2102      	movs	r1, #2
    f6f8:	f000 fd30 	bl	1015c <am_hal_gpio_state_read>
                                         AM_HAL_GPIO_ENABLE_READ, &ui32Value);

        if ( ui32Ret == AM_HAL_STATUS_SUCCESS )
    f6fc:	b930      	cbnz	r0, f70c <am_devices_led_toggle+0x38>
        {
            if ( ui32Value )
    f6fe:	9b01      	ldr	r3, [sp, #4]
            {
                //
                // If it was enabled, turn if off.
                //
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f700:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
            if ( ui32Value )
    f704:	b15b      	cbz	r3, f71e <am_devices_led_toggle+0x4a>
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f706:	2103      	movs	r1, #3
    f708:	f000 fd5e 	bl	101c8 <am_hal_gpio_state_write>
            am_hal_gpio_out_enable_bit_set(psLEDs[ui32LEDNum].ui32GPIONumber);
        }
    }
#endif // AM_APOLLO3_GPIO
#endif
}
    f70c:	b003      	add	sp, #12
    f70e:	bd30      	pop	{r4, r5, pc}
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f710:	2102      	movs	r1, #2
}
    f712:	b003      	add	sp, #12
    f714:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f718:	f000 bd56 	b.w	101c8 <am_hal_gpio_state_write>
    f71c:	4770      	bx	lr
                am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    f71e:	2104      	movs	r1, #4
    f720:	f000 fd52 	bl	101c8 <am_hal_gpio_state_write>
    f724:	e7f2      	b.n	f70c <am_devices_led_toggle+0x38>
    f726:	bf00      	nop

0000f728 <NMI_Handler>:
NMI_Handler(void)
{
    //
    // Go into an infinite loop.
    //
    while(1)
    f728:	e7fe      	b.n	f728 <NMI_Handler>
    f72a:	bf00      	nop

0000f72c <BusFault_Handler>:
HardFault_Handler(void)
{
    //
    // Go into an infinite loop.
    //
    while(1)
    f72c:	e7fe      	b.n	f72c <BusFault_Handler>
    f72e:	bf00      	nop

0000f730 <DebugMon_Handler>:
am_default_isr(void)
{
    //
    // Go into an infinite loop.
    //
    while(1)
    f730:	e7fe      	b.n	f730 <DebugMon_Handler>
    f732:	bf00      	nop

0000f734 <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
    f734:	4811      	ldr	r0, [pc, #68]	; (f77c <zero_loop+0x12>)
    f736:	4912      	ldr	r1, [pc, #72]	; (f780 <zero_loop+0x16>)
    f738:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
    f73a:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
    f73e:	4811      	ldr	r0, [pc, #68]	; (f784 <zero_loop+0x1a>)
    f740:	6801      	ldr	r1, [r0, #0]
    f742:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    f746:	6001      	str	r1, [r0, #0]
    f748:	f3bf 8f4f 	dsb	sy
    f74c:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
    f750:	480d      	ldr	r0, [pc, #52]	; (f788 <zero_loop+0x1e>)
    f752:	490e      	ldr	r1, [pc, #56]	; (f78c <zero_loop+0x22>)
    f754:	4a0e      	ldr	r2, [pc, #56]	; (f790 <zero_loop+0x26>)

0000f756 <copy_loop>:
    f756:	f850 3b04 	ldr.w	r3, [r0], #4
    f75a:	f841 3b04 	str.w	r3, [r1], #4
    f75e:	4291      	cmp	r1, r2
    f760:	dbf9      	blt.n	f756 <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
    f762:	480c      	ldr	r0, [pc, #48]	; (f794 <zero_loop+0x2a>)
    f764:	490c      	ldr	r1, [pc, #48]	; (f798 <zero_loop+0x2e>)
    f766:	f04f 0200 	mov.w	r2, #0

0000f76a <zero_loop>:
    f76a:	4288      	cmp	r0, r1
    f76c:	bfb8      	it	lt
    f76e:	f840 2b04 	strlt.w	r2, [r0], #4
    f772:	dbfa      	blt.n	f76a <zero_loop>
    main();
    f774:	f7fc fdb0 	bl	c2d8 <main>
    __asm("    bkpt     ");
    f778:	be00      	bkpt	0x0000
}
    f77a:	0000      	.short	0x0000
    f77c:	e000ed08 	.word	0xe000ed08
    f780:	0000c000 	.word	0x0000c000
    f784:	e000ed88 	.word	0xe000ed88
    f788:	0001125c 	.word	0x0001125c
    f78c:	10002300 	.word	0x10002300
    f790:	1000233c 	.word	0x1000233c
    f794:	1000233c 	.word	0x1000233c
    f798:	100067ac 	.word	0x100067ac

0000f79c <memset>:
    f79c:	0783      	lsls	r3, r0, #30
    f79e:	b530      	push	{r4, r5, lr}
    f7a0:	d048      	beq.n	f834 <memset+0x98>
    f7a2:	1e54      	subs	r4, r2, #1
    f7a4:	2a00      	cmp	r2, #0
    f7a6:	d03f      	beq.n	f828 <memset+0x8c>
    f7a8:	b2ca      	uxtb	r2, r1
    f7aa:	4603      	mov	r3, r0
    f7ac:	e001      	b.n	f7b2 <memset+0x16>
    f7ae:	3c01      	subs	r4, #1
    f7b0:	d33a      	bcc.n	f828 <memset+0x8c>
    f7b2:	f803 2b01 	strb.w	r2, [r3], #1
    f7b6:	079d      	lsls	r5, r3, #30
    f7b8:	d1f9      	bne.n	f7ae <memset+0x12>
    f7ba:	2c03      	cmp	r4, #3
    f7bc:	d92d      	bls.n	f81a <memset+0x7e>
    f7be:	b2cd      	uxtb	r5, r1
    f7c0:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    f7c4:	2c0f      	cmp	r4, #15
    f7c6:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    f7ca:	d936      	bls.n	f83a <memset+0x9e>
    f7cc:	f1a4 0210 	sub.w	r2, r4, #16
    f7d0:	f022 0c0f 	bic.w	ip, r2, #15
    f7d4:	f103 0e20 	add.w	lr, r3, #32
    f7d8:	44e6      	add	lr, ip
    f7da:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    f7de:	f103 0210 	add.w	r2, r3, #16
    f7e2:	e942 5504 	strd	r5, r5, [r2, #-16]
    f7e6:	e942 5502 	strd	r5, r5, [r2, #-8]
    f7ea:	3210      	adds	r2, #16
    f7ec:	4572      	cmp	r2, lr
    f7ee:	d1f8      	bne.n	f7e2 <memset+0x46>
    f7f0:	f10c 0201 	add.w	r2, ip, #1
    f7f4:	f014 0f0c 	tst.w	r4, #12
    f7f8:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    f7fc:	f004 0c0f 	and.w	ip, r4, #15
    f800:	d013      	beq.n	f82a <memset+0x8e>
    f802:	f1ac 0304 	sub.w	r3, ip, #4
    f806:	f023 0303 	bic.w	r3, r3, #3
    f80a:	3304      	adds	r3, #4
    f80c:	4413      	add	r3, r2
    f80e:	f842 5b04 	str.w	r5, [r2], #4
    f812:	4293      	cmp	r3, r2
    f814:	d1fb      	bne.n	f80e <memset+0x72>
    f816:	f00c 0403 	and.w	r4, ip, #3
    f81a:	b12c      	cbz	r4, f828 <memset+0x8c>
    f81c:	b2ca      	uxtb	r2, r1
    f81e:	441c      	add	r4, r3
    f820:	f803 2b01 	strb.w	r2, [r3], #1
    f824:	429c      	cmp	r4, r3
    f826:	d1fb      	bne.n	f820 <memset+0x84>
    f828:	bd30      	pop	{r4, r5, pc}
    f82a:	4664      	mov	r4, ip
    f82c:	4613      	mov	r3, r2
    f82e:	2c00      	cmp	r4, #0
    f830:	d1f4      	bne.n	f81c <memset+0x80>
    f832:	e7f9      	b.n	f828 <memset+0x8c>
    f834:	4603      	mov	r3, r0
    f836:	4614      	mov	r4, r2
    f838:	e7bf      	b.n	f7ba <memset+0x1e>
    f83a:	461a      	mov	r2, r3
    f83c:	46a4      	mov	ip, r4
    f83e:	e7e0      	b.n	f802 <memset+0x66>

0000f840 <am_bsp_low_power_init>:
    f840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f842:	f000 ff57 	bl	106f4 <am_hal_pwrctrl_low_power_init>
    f846:	f001 f833 	bl	108b0 <am_hal_rtc_osc_disable>
    f84a:	4b0b      	ldr	r3, [pc, #44]	; (f878 <am_bsp_low_power_init+0x38>)
    f84c:	4f0b      	ldr	r7, [pc, #44]	; (f87c <am_bsp_low_power_init+0x3c>)
    f84e:	681e      	ldr	r6, [r3, #0]
    f850:	2400      	movs	r4, #0
    f852:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
    f856:	4631      	mov	r1, r6
    f858:	4628      	mov	r0, r5
    f85a:	f000 fb49 	bl	fef0 <am_hal_gpio_pinconfig>
    f85e:	2103      	movs	r1, #3
    f860:	4628      	mov	r0, r5
    f862:	f000 fcb1 	bl	101c8 <am_hal_gpio_state_write>
    f866:	3401      	adds	r4, #1
    f868:	2100      	movs	r1, #0
    f86a:	4628      	mov	r0, r5
    f86c:	f000 fcac 	bl	101c8 <am_hal_gpio_state_write>
    f870:	2c05      	cmp	r4, #5
    f872:	d1ee      	bne.n	f852 <am_bsp_low_power_init+0x12>
    f874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f876:	bf00      	nop
    f878:	00010ec0 	.word	0x00010ec0
    f87c:	10002308 	.word	0x10002308

0000f880 <am_bsp_itm_printf_enable>:
    f880:	b500      	push	{lr}
    f882:	4b0b      	ldr	r3, [pc, #44]	; (f8b0 <am_bsp_itm_printf_enable+0x30>)
    f884:	b087      	sub	sp, #28
    f886:	2201      	movs	r2, #1
    f888:	601a      	str	r2, [r3, #0]
    f88a:	f000 fdb5 	bl	103f8 <am_hal_itm_enable>
    f88e:	4b09      	ldr	r3, [pc, #36]	; (f8b4 <am_bsp_itm_printf_enable+0x34>)
    f890:	9301      	str	r3, [sp, #4]
    f892:	a801      	add	r0, sp, #4
    f894:	f001 f902 	bl	10a9c <am_hal_tpiu_enable>
    f898:	4b07      	ldr	r3, [pc, #28]	; (f8b8 <am_bsp_itm_printf_enable+0x38>)
    f89a:	2029      	movs	r0, #41	; 0x29
    f89c:	6819      	ldr	r1, [r3, #0]
    f89e:	f000 fb27 	bl	fef0 <am_hal_gpio_pinconfig>
    f8a2:	4806      	ldr	r0, [pc, #24]	; (f8bc <am_bsp_itm_printf_enable+0x3c>)
    f8a4:	f7ff f9b2 	bl	ec0c <am_util_stdio_printf_init>
    f8a8:	b007      	add	sp, #28
    f8aa:	f85d fb04 	ldr.w	pc, [sp], #4
    f8ae:	bf00      	nop
    f8b0:	10006590 	.word	0x10006590
    f8b4:	000f4240 	.word	0x000f4240
    f8b8:	00010eb4 	.word	0x00010eb4
    f8bc:	000104f5 	.word	0x000104f5

0000f8c0 <am_bsp_itm_printf_disable>:
    f8c0:	b508      	push	{r3, lr}
    f8c2:	f000 fdbd 	bl	10440 <am_hal_itm_disable>
    f8c6:	2000      	movs	r0, #0
    f8c8:	f7ff f9a0 	bl	ec0c <am_util_stdio_printf_init>
    f8cc:	4b03      	ldr	r3, [pc, #12]	; (f8dc <am_bsp_itm_printf_disable+0x1c>)
    f8ce:	2029      	movs	r0, #41	; 0x29
    f8d0:	6819      	ldr	r1, [r3, #0]
    f8d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    f8d6:	f000 bb0b 	b.w	fef0 <am_hal_gpio_pinconfig>
    f8da:	bf00      	nop
    f8dc:	00010ebc 	.word	0x00010ebc

0000f8e0 <am_hal_cachectrl_config>:
    f8e0:	b530      	push	{r4, r5, lr}
    f8e2:	b083      	sub	sp, #12
    f8e4:	4604      	mov	r4, r0
    f8e6:	f000 fd7f 	bl	103e8 <am_hal_interrupt_master_disable>
    f8ea:	4d0e      	ldr	r5, [pc, #56]	; (f924 <am_hal_cachectrl_config+0x44>)
    f8ec:	9001      	str	r0, [sp, #4]
    f8ee:	682b      	ldr	r3, [r5, #0]
    f8f0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    f8f4:	602b      	str	r3, [r5, #0]
    f8f6:	9801      	ldr	r0, [sp, #4]
    f8f8:	f000 fd7a 	bl	103f0 <am_hal_interrupt_master_set>
    f8fc:	7863      	ldrb	r3, [r4, #1]
    f8fe:	7822      	ldrb	r2, [r4, #0]
    f900:	78a1      	ldrb	r1, [r4, #2]
    f902:	021b      	lsls	r3, r3, #8
    f904:	f403 7340 	and.w	r3, r3, #768	; 0x300
    f908:	0112      	lsls	r2, r2, #4
    f90a:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    f90e:	b2d2      	uxtb	r2, r2
    f910:	4313      	orrs	r3, r2
    f912:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    f916:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    f91a:	2000      	movs	r0, #0
    f91c:	602b      	str	r3, [r5, #0]
    f91e:	b003      	add	sp, #12
    f920:	bd30      	pop	{r4, r5, pc}
    f922:	bf00      	nop
    f924:	40018000 	.word	0x40018000

0000f928 <am_hal_cachectrl_enable>:
    f928:	4a03      	ldr	r2, [pc, #12]	; (f938 <am_hal_cachectrl_enable+0x10>)
    f92a:	6813      	ldr	r3, [r2, #0]
    f92c:	f043 0301 	orr.w	r3, r3, #1
    f930:	2000      	movs	r0, #0
    f932:	6013      	str	r3, [r2, #0]
    f934:	4770      	bx	lr
    f936:	bf00      	nop
    f938:	40018000 	.word	0x40018000

0000f93c <am_hal_cachectrl_control>:
    f93c:	b510      	push	{r4, lr}
    f93e:	3801      	subs	r0, #1
    f940:	b08e      	sub	sp, #56	; 0x38
    f942:	2810      	cmp	r0, #16
    f944:	f200 815e 	bhi.w	fc04 <am_hal_cachectrl_control+0x2c8>
    f948:	e8df f010 	tbh	[pc, r0, lsl #1]
    f94c:	00360018 	.word	0x00360018
    f950:	0040003d 	.word	0x0040003d
    f954:	00450043 	.word	0x00450043
    f958:	0011001a 	.word	0x0011001a
    f95c:	00540047 	.word	0x00540047
    f960:	009a0061 	.word	0x009a0061
    f964:	010c00d3 	.word	0x010c00d3
    f968:	013f0126 	.word	0x013f0126
    f96c:	001d      	.short	0x001d
    f96e:	f44f 7300 	mov.w	r3, #512	; 0x200
    f972:	4aac      	ldr	r2, [pc, #688]	; (fc24 <am_hal_cachectrl_control+0x2e8>)
    f974:	2000      	movs	r0, #0
    f976:	6093      	str	r3, [r2, #8]
    f978:	b00e      	add	sp, #56	; 0x38
    f97a:	bd10      	pop	{r4, pc}
    f97c:	2301      	movs	r3, #1
    f97e:	e7f8      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f980:	f44f 6380 	mov.w	r3, #1024	; 0x400
    f984:	e7f5      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f986:	2900      	cmp	r1, #0
    f988:	f000 813c 	beq.w	fc04 <am_hal_cachectrl_control+0x2c8>
    f98c:	684a      	ldr	r2, [r1, #4]
    f98e:	48a6      	ldr	r0, [pc, #664]	; (fc28 <am_hal_cachectrl_control+0x2ec>)
    f990:	4202      	tst	r2, r0
    f992:	f040 8137 	bne.w	fc04 <am_hal_cachectrl_control+0x2c8>
    f996:	688b      	ldr	r3, [r1, #8]
    f998:	4018      	ands	r0, r3
    f99a:	f040 8133 	bne.w	fc04 <am_hal_cachectrl_control+0x2c8>
    f99e:	780c      	ldrb	r4, [r1, #0]
    f9a0:	2c00      	cmp	r4, #0
    f9a2:	f040 8133 	bne.w	fc0c <am_hal_cachectrl_control+0x2d0>
    f9a6:	4c9f      	ldr	r4, [pc, #636]	; (fc24 <am_hal_cachectrl_control+0x2e8>)
    f9a8:	7849      	ldrb	r1, [r1, #1]
    f9aa:	6122      	str	r2, [r4, #16]
    f9ac:	6163      	str	r3, [r4, #20]
    f9ae:	6823      	ldr	r3, [r4, #0]
    f9b0:	f361 0382 	bfi	r3, r1, #2, #1
    f9b4:	6023      	str	r3, [r4, #0]
    f9b6:	e7df      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    f9b8:	4b9a      	ldr	r3, [pc, #616]	; (fc24 <am_hal_cachectrl_control+0x2e8>)
    f9ba:	681b      	ldr	r3, [r3, #0]
    f9bc:	01db      	lsls	r3, r3, #7
    f9be:	f140 811f 	bpl.w	fc00 <am_hal_cachectrl_control+0x2c4>
    f9c2:	2302      	movs	r3, #2
    f9c4:	e7d5      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f9c6:	f44f 6388 	mov.w	r3, #1088	; 0x440
    f9ca:	e7d2      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f9cc:	f44f 7308 	mov.w	r3, #544	; 0x220
    f9d0:	e7cf      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f9d2:	2340      	movs	r3, #64	; 0x40
    f9d4:	e7cd      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f9d6:	2320      	movs	r3, #32
    f9d8:	e7cb      	b.n	f972 <am_hal_cachectrl_control+0x36>
    f9da:	f000 fd05 	bl	103e8 <am_hal_interrupt_master_disable>
    f9de:	4a91      	ldr	r2, [pc, #580]	; (fc24 <am_hal_cachectrl_control+0x2e8>)
    f9e0:	9000      	str	r0, [sp, #0]
    f9e2:	6813      	ldr	r3, [r2, #0]
    f9e4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    f9e8:	6013      	str	r3, [r2, #0]
    f9ea:	9800      	ldr	r0, [sp, #0]
    f9ec:	f000 fd00 	bl	103f0 <am_hal_interrupt_master_set>
    f9f0:	2000      	movs	r0, #0
    f9f2:	e7c1      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    f9f4:	f000 fcf8 	bl	103e8 <am_hal_interrupt_master_disable>
    f9f8:	4a8a      	ldr	r2, [pc, #552]	; (fc24 <am_hal_cachectrl_control+0x2e8>)
    f9fa:	9001      	str	r0, [sp, #4]
    f9fc:	6813      	ldr	r3, [r2, #0]
    f9fe:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    fa02:	6013      	str	r3, [r2, #0]
    fa04:	9801      	ldr	r0, [sp, #4]
    fa06:	f000 fcf3 	bl	103f0 <am_hal_interrupt_master_set>
    fa0a:	2000      	movs	r0, #0
    fa0c:	e7b4      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fa0e:	f000 fceb 	bl	103e8 <am_hal_interrupt_master_disable>
    fa12:	4603      	mov	r3, r0
    fa14:	4885      	ldr	r0, [pc, #532]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa16:	9302      	str	r3, [sp, #8]
    fa18:	f000 fa52 	bl	fec0 <am_hal_flash_load_ui32>
    fa1c:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fa20:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fa24:	4881      	ldr	r0, [pc, #516]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa26:	f000 fa4f 	bl	fec8 <am_hal_flash_store_ui32>
    fa2a:	9802      	ldr	r0, [sp, #8]
    fa2c:	f000 fce0 	bl	103f0 <am_hal_interrupt_master_set>
    fa30:	f000 fcda 	bl	103e8 <am_hal_interrupt_master_disable>
    fa34:	4603      	mov	r3, r0
    fa36:	487d      	ldr	r0, [pc, #500]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa38:	9303      	str	r3, [sp, #12]
    fa3a:	f000 fa41 	bl	fec0 <am_hal_flash_load_ui32>
    fa3e:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fa42:	f440 61ee 	orr.w	r1, r0, #1904	; 0x770
    fa46:	4879      	ldr	r0, [pc, #484]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa48:	f000 fa3e 	bl	fec8 <am_hal_flash_store_ui32>
    fa4c:	9803      	ldr	r0, [sp, #12]
    fa4e:	f000 fccf 	bl	103f0 <am_hal_interrupt_master_set>
    fa52:	f000 fcc9 	bl	103e8 <am_hal_interrupt_master_disable>
    fa56:	4603      	mov	r3, r0
    fa58:	4874      	ldr	r0, [pc, #464]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa5a:	9304      	str	r3, [sp, #16]
    fa5c:	f000 fa30 	bl	fec0 <am_hal_flash_load_ui32>
    fa60:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fa64:	f020 000f 	bic.w	r0, r0, #15
    fa68:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fa6c:	f041 0103 	orr.w	r1, r1, #3
    fa70:	486e      	ldr	r0, [pc, #440]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa72:	f000 fa29 	bl	fec8 <am_hal_flash_store_ui32>
    fa76:	9804      	ldr	r0, [sp, #16]
    fa78:	f000 fcba 	bl	103f0 <am_hal_interrupt_master_set>
    fa7c:	2000      	movs	r0, #0
    fa7e:	e77b      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fa80:	f000 fcb2 	bl	103e8 <am_hal_interrupt_master_disable>
    fa84:	4603      	mov	r3, r0
    fa86:	4869      	ldr	r0, [pc, #420]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa88:	9305      	str	r3, [sp, #20]
    fa8a:	f000 fa19 	bl	fec0 <am_hal_flash_load_ui32>
    fa8e:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fa92:	f440 51b8 	orr.w	r1, r0, #5888	; 0x1700
    fa96:	4865      	ldr	r0, [pc, #404]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fa98:	f000 fa16 	bl	fec8 <am_hal_flash_store_ui32>
    fa9c:	9805      	ldr	r0, [sp, #20]
    fa9e:	f000 fca7 	bl	103f0 <am_hal_interrupt_master_set>
    faa2:	f000 fca1 	bl	103e8 <am_hal_interrupt_master_disable>
    faa6:	4603      	mov	r3, r0
    faa8:	4860      	ldr	r0, [pc, #384]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    faaa:	9306      	str	r3, [sp, #24]
    faac:	f000 fa08 	bl	fec0 <am_hal_flash_load_ui32>
    fab0:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fab4:	f440 61ea 	orr.w	r1, r0, #1872	; 0x750
    fab8:	485c      	ldr	r0, [pc, #368]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    faba:	f000 fa05 	bl	fec8 <am_hal_flash_store_ui32>
    fabe:	9806      	ldr	r0, [sp, #24]
    fac0:	f000 fc96 	bl	103f0 <am_hal_interrupt_master_set>
    fac4:	f000 fc90 	bl	103e8 <am_hal_interrupt_master_disable>
    fac8:	4603      	mov	r3, r0
    faca:	4858      	ldr	r0, [pc, #352]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    facc:	9307      	str	r3, [sp, #28]
    face:	f000 f9f7 	bl	fec0 <am_hal_flash_load_ui32>
    fad2:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fad6:	f020 000f 	bic.w	r0, r0, #15
    fada:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fade:	f041 0101 	orr.w	r1, r1, #1
    fae2:	4852      	ldr	r0, [pc, #328]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fae4:	f000 f9f0 	bl	fec8 <am_hal_flash_store_ui32>
    fae8:	9807      	ldr	r0, [sp, #28]
    faea:	f000 fc81 	bl	103f0 <am_hal_interrupt_master_set>
    faee:	2000      	movs	r0, #0
    faf0:	e742      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    faf2:	f000 fc79 	bl	103e8 <am_hal_interrupt_master_disable>
    faf6:	4603      	mov	r3, r0
    faf8:	484c      	ldr	r0, [pc, #304]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fafa:	9308      	str	r3, [sp, #32]
    fafc:	f000 f9e0 	bl	fec0 <am_hal_flash_load_ui32>
    fb00:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fb04:	f440 51b8 	orr.w	r1, r0, #5888	; 0x1700
    fb08:	4848      	ldr	r0, [pc, #288]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb0a:	f000 f9dd 	bl	fec8 <am_hal_flash_store_ui32>
    fb0e:	9808      	ldr	r0, [sp, #32]
    fb10:	f000 fc6e 	bl	103f0 <am_hal_interrupt_master_set>
    fb14:	f000 fc68 	bl	103e8 <am_hal_interrupt_master_disable>
    fb18:	4603      	mov	r3, r0
    fb1a:	4844      	ldr	r0, [pc, #272]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb1c:	9309      	str	r3, [sp, #36]	; 0x24
    fb1e:	f000 f9cf 	bl	fec0 <am_hal_flash_load_ui32>
    fb22:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fb26:	f440 61ec 	orr.w	r1, r0, #1888	; 0x760
    fb2a:	4840      	ldr	r0, [pc, #256]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb2c:	f000 f9cc 	bl	fec8 <am_hal_flash_store_ui32>
    fb30:	9809      	ldr	r0, [sp, #36]	; 0x24
    fb32:	f000 fc5d 	bl	103f0 <am_hal_interrupt_master_set>
    fb36:	f000 fc57 	bl	103e8 <am_hal_interrupt_master_disable>
    fb3a:	4603      	mov	r3, r0
    fb3c:	483b      	ldr	r0, [pc, #236]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb3e:	930a      	str	r3, [sp, #40]	; 0x28
    fb40:	f000 f9be 	bl	fec0 <am_hal_flash_load_ui32>
    fb44:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fb48:	f020 000f 	bic.w	r0, r0, #15
    fb4c:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fb50:	f041 0101 	orr.w	r1, r1, #1
    fb54:	4835      	ldr	r0, [pc, #212]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb56:	f000 f9b7 	bl	fec8 <am_hal_flash_store_ui32>
    fb5a:	980a      	ldr	r0, [sp, #40]	; 0x28
    fb5c:	f000 fc48 	bl	103f0 <am_hal_interrupt_master_set>
    fb60:	2000      	movs	r0, #0
    fb62:	e709      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fb64:	2900      	cmp	r1, #0
    fb66:	d04d      	beq.n	fc04 <am_hal_cachectrl_control+0x2c8>
    fb68:	680c      	ldr	r4, [r1, #0]
    fb6a:	2c03      	cmp	r4, #3
    fb6c:	d84c      	bhi.n	fc08 <am_hal_cachectrl_control+0x2cc>
    fb6e:	f000 fc3b 	bl	103e8 <am_hal_interrupt_master_disable>
    fb72:	4603      	mov	r3, r0
    fb74:	482d      	ldr	r0, [pc, #180]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb76:	930b      	str	r3, [sp, #44]	; 0x2c
    fb78:	f000 f9a2 	bl	fec0 <am_hal_flash_load_ui32>
    fb7c:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fb80:	ea40 3104 	orr.w	r1, r0, r4, lsl #12
    fb84:	f441 61e0 	orr.w	r1, r1, #1792	; 0x700
    fb88:	4828      	ldr	r0, [pc, #160]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fb8a:	f000 f99d 	bl	fec8 <am_hal_flash_store_ui32>
    fb8e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    fb90:	f000 fc2e 	bl	103f0 <am_hal_interrupt_master_set>
    fb94:	2000      	movs	r0, #0
    fb96:	e6ef      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fb98:	b3a1      	cbz	r1, fc04 <am_hal_cachectrl_control+0x2c8>
    fb9a:	680c      	ldr	r4, [r1, #0]
    fb9c:	2c07      	cmp	r4, #7
    fb9e:	d833      	bhi.n	fc08 <am_hal_cachectrl_control+0x2cc>
    fba0:	f000 fc22 	bl	103e8 <am_hal_interrupt_master_disable>
    fba4:	4603      	mov	r3, r0
    fba6:	4821      	ldr	r0, [pc, #132]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fba8:	930c      	str	r3, [sp, #48]	; 0x30
    fbaa:	f000 f989 	bl	fec0 <am_hal_flash_load_ui32>
    fbae:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fbb2:	ea40 1104 	orr.w	r1, r0, r4, lsl #4
    fbb6:	f441 61e0 	orr.w	r1, r1, #1792	; 0x700
    fbba:	481c      	ldr	r0, [pc, #112]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fbbc:	f000 f984 	bl	fec8 <am_hal_flash_store_ui32>
    fbc0:	980c      	ldr	r0, [sp, #48]	; 0x30
    fbc2:	f000 fc15 	bl	103f0 <am_hal_interrupt_master_set>
    fbc6:	2000      	movs	r0, #0
    fbc8:	e6d6      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fbca:	b1d9      	cbz	r1, fc04 <am_hal_cachectrl_control+0x2c8>
    fbcc:	680c      	ldr	r4, [r1, #0]
    fbce:	2c0f      	cmp	r4, #15
    fbd0:	d81a      	bhi.n	fc08 <am_hal_cachectrl_control+0x2cc>
    fbd2:	f000 fc09 	bl	103e8 <am_hal_interrupt_master_disable>
    fbd6:	4603      	mov	r3, r0
    fbd8:	4814      	ldr	r0, [pc, #80]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fbda:	930d      	str	r3, [sp, #52]	; 0x34
    fbdc:	f000 f970 	bl	fec0 <am_hal_flash_load_ui32>
    fbe0:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fbe4:	f020 000f 	bic.w	r0, r0, #15
    fbe8:	ea40 0104 	orr.w	r1, r0, r4
    fbec:	f441 61e0 	orr.w	r1, r1, #1792	; 0x700
    fbf0:	480e      	ldr	r0, [pc, #56]	; (fc2c <am_hal_cachectrl_control+0x2f0>)
    fbf2:	f000 f969 	bl	fec8 <am_hal_flash_store_ui32>
    fbf6:	980d      	ldr	r0, [sp, #52]	; 0x34
    fbf8:	f000 fbfa 	bl	103f0 <am_hal_interrupt_master_set>
    fbfc:	2000      	movs	r0, #0
    fbfe:	e6bb      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fc00:	2007      	movs	r0, #7
    fc02:	e6b9      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fc04:	2006      	movs	r0, #6
    fc06:	e6b7      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fc08:	2001      	movs	r0, #1
    fc0a:	e6b5      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fc0c:	2c01      	cmp	r4, #1
    fc0e:	d1f9      	bne.n	fc04 <am_hal_cachectrl_control+0x2c8>
    fc10:	4c04      	ldr	r4, [pc, #16]	; (fc24 <am_hal_cachectrl_control+0x2e8>)
    fc12:	7849      	ldrb	r1, [r1, #1]
    fc14:	61a2      	str	r2, [r4, #24]
    fc16:	61e3      	str	r3, [r4, #28]
    fc18:	6823      	ldr	r3, [r4, #0]
    fc1a:	f361 03c3 	bfi	r3, r1, #3, #1
    fc1e:	6023      	str	r3, [r4, #0]
    fc20:	e6aa      	b.n	f978 <am_hal_cachectrl_control+0x3c>
    fc22:	bf00      	nop
    fc24:	40018000 	.word	0x40018000
    fc28:	f800000f 	.word	0xf800000f
    fc2c:	40018004 	.word	0x40018004

0000fc30 <am_hal_clkgen_control>:
    fc30:	4b49      	ldr	r3, [pc, #292]	; (fd58 <am_hal_clkgen_control+0x128>)
    fc32:	681a      	ldr	r2, [r3, #0]
    fc34:	b912      	cbnz	r2, fc3c <am_hal_clkgen_control+0xc>
    fc36:	4a49      	ldr	r2, [pc, #292]	; (fd5c <am_hal_clkgen_control+0x12c>)
    fc38:	6812      	ldr	r2, [r2, #0]
    fc3a:	601a      	str	r2, [r3, #0]
    fc3c:	2809      	cmp	r0, #9
    fc3e:	f200 8089 	bhi.w	fd54 <am_hal_clkgen_control+0x124>
    fc42:	e8df f000 	tbb	[pc, r0]
    fc46:	160d      	.short	0x160d
    fc48:	423a261e 	.word	0x423a261e
    fc4c:	055c544c 	.word	0x055c544c
    fc50:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fc54:	2000      	movs	r0, #0
    fc56:	6a1a      	ldr	r2, [r3, #32]
    fc58:	f36f 0200 	bfc	r2, #0, #1
    fc5c:	621a      	str	r2, [r3, #32]
    fc5e:	4770      	bx	lr
    fc60:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fc64:	2200      	movs	r2, #0
    fc66:	2147      	movs	r1, #71	; 0x47
    fc68:	6159      	str	r1, [r3, #20]
    fc6a:	4610      	mov	r0, r2
    fc6c:	619a      	str	r2, [r3, #24]
    fc6e:	615a      	str	r2, [r3, #20]
    fc70:	4770      	bx	lr
    fc72:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fc76:	2000      	movs	r0, #0
    fc78:	899a      	ldrh	r2, [r3, #12]
    fc7a:	f36f 0200 	bfc	r2, #0, #1
    fc7e:	819a      	strh	r2, [r3, #12]
    fc80:	4770      	bx	lr
    fc82:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fc86:	2000      	movs	r0, #0
    fc88:	899a      	ldrh	r2, [r3, #12]
    fc8a:	f36f 0241 	bfc	r2, #1, #1
    fc8e:	819a      	strh	r2, [r3, #12]
    fc90:	4770      	bx	lr
    fc92:	4a33      	ldr	r2, [pc, #204]	; (fd60 <am_hal_clkgen_control+0x130>)
    fc94:	68d3      	ldr	r3, [r2, #12]
    fc96:	b2db      	uxtb	r3, r3
    fc98:	2b21      	cmp	r3, #33	; 0x21
    fc9a:	d106      	bne.n	fcaa <am_hal_clkgen_control+0x7a>
    fc9c:	f8b2 3120 	ldrh.w	r3, [r2, #288]	; 0x120
    fca0:	2101      	movs	r1, #1
    fca2:	f361 2309 	bfi	r3, r1, #8, #2
    fca6:	f8a2 3120 	strh.w	r3, [r2, #288]	; 0x120
    fcaa:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fcae:	2000      	movs	r0, #0
    fcb0:	8993      	ldrh	r3, [r2, #12]
    fcb2:	f043 0301 	orr.w	r3, r3, #1
    fcb6:	8193      	strh	r3, [r2, #12]
    fcb8:	4770      	bx	lr
    fcba:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fcbe:	2000      	movs	r0, #0
    fcc0:	8993      	ldrh	r3, [r2, #12]
    fcc2:	f043 0302 	orr.w	r3, r3, #2
    fcc6:	8193      	strh	r3, [r2, #12]
    fcc8:	4770      	bx	lr
    fcca:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fcce:	2200      	movs	r2, #0
    fcd0:	2047      	movs	r0, #71	; 0x47
    fcd2:	2101      	movs	r1, #1
    fcd4:	6158      	str	r0, [r3, #20]
    fcd6:	6199      	str	r1, [r3, #24]
    fcd8:	4610      	mov	r0, r2
    fcda:	615a      	str	r2, [r3, #20]
    fcdc:	4770      	bx	lr
    fcde:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fce2:	2000      	movs	r0, #0
    fce4:	899a      	ldrh	r2, [r3, #12]
    fce6:	f36f 12c7 	bfc	r2, #7, #1
    fcea:	819a      	strh	r2, [r3, #12]
    fcec:	4770      	bx	lr
    fcee:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fcf2:	2000      	movs	r0, #0
    fcf4:	8993      	ldrh	r3, [r2, #12]
    fcf6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fcfa:	8193      	strh	r3, [r2, #12]
    fcfc:	4770      	bx	lr
    fcfe:	4a18      	ldr	r2, [pc, #96]	; (fd60 <am_hal_clkgen_control+0x130>)
    fd00:	68d3      	ldr	r3, [r2, #12]
    fd02:	b2db      	uxtb	r3, r3
    fd04:	2b21      	cmp	r3, #33	; 0x21
    fd06:	d00a      	beq.n	fd1e <am_hal_clkgen_control+0xee>
    fd08:	b139      	cbz	r1, fd1a <am_hal_clkgen_control+0xea>
    fd0a:	680b      	ldr	r3, [r1, #0]
    fd0c:	f043 0301 	orr.w	r3, r3, #1
    fd10:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fd14:	2000      	movs	r0, #0
    fd16:	6213      	str	r3, [r2, #32]
    fd18:	4770      	bx	lr
    fd1a:	4b12      	ldr	r3, [pc, #72]	; (fd64 <am_hal_clkgen_control+0x134>)
    fd1c:	e7f8      	b.n	fd10 <am_hal_clkgen_control+0xe0>
    fd1e:	b500      	push	{lr}
    fd20:	b083      	sub	sp, #12
    fd22:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
    fd26:	9101      	str	r1, [sp, #4]
    fd28:	f8b2 3120 	ldrh.w	r3, [r2, #288]	; 0x120
    fd2c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    fd30:	f8a2 3120 	strh.w	r3, [r2, #288]	; 0x120
    fd34:	f000 f87e 	bl	fe34 <am_hal_flash_delay>
    fd38:	9901      	ldr	r1, [sp, #4]
    fd3a:	b149      	cbz	r1, fd50 <am_hal_clkgen_control+0x120>
    fd3c:	680b      	ldr	r3, [r1, #0]
    fd3e:	f043 0301 	orr.w	r3, r3, #1
    fd42:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fd46:	2000      	movs	r0, #0
    fd48:	6213      	str	r3, [r2, #32]
    fd4a:	b003      	add	sp, #12
    fd4c:	f85d fb04 	ldr.w	pc, [sp], #4
    fd50:	4b04      	ldr	r3, [pc, #16]	; (fd64 <am_hal_clkgen_control+0x134>)
    fd52:	e7f6      	b.n	fd42 <am_hal_clkgen_control+0x112>
    fd54:	2006      	movs	r0, #6
    fd56:	4770      	bx	lr
    fd58:	100067a4 	.word	0x100067a4
    fd5c:	4ffff000 	.word	0x4ffff000
    fd60:	40020000 	.word	0x40020000
    fd64:	0025b801 	.word	0x0025b801

0000fd68 <am_hal_clkgen_status_get>:
    fd68:	b1b0      	cbz	r0, fd98 <am_hal_clkgen_status_get+0x30>
    fd6a:	b410      	push	{r4}
    fd6c:	f04f 2140 	mov.w	r1, #1073758208	; 0x40004000
    fd70:	4603      	mov	r3, r0
    fd72:	698c      	ldr	r4, [r1, #24]
    fd74:	4809      	ldr	r0, [pc, #36]	; (fd9c <am_hal_clkgen_status_get+0x34>)
    fd76:	4a0a      	ldr	r2, [pc, #40]	; (fda0 <am_hal_clkgen_status_get+0x38>)
    fd78:	f014 0f01 	tst.w	r4, #1
    fd7c:	bf08      	it	eq
    fd7e:	4602      	moveq	r2, r0
    fd80:	601a      	str	r2, [r3, #0]
    fd82:	69ca      	ldr	r2, [r1, #28]
    fd84:	f85d 4b04 	ldr.w	r4, [sp], #4
    fd88:	f002 0101 	and.w	r1, r2, #1
    fd8c:	f3c2 0240 	ubfx	r2, r2, #1, #1
    fd90:	2000      	movs	r0, #0
    fd92:	6059      	str	r1, [r3, #4]
    fd94:	721a      	strb	r2, [r3, #8]
    fd96:	4770      	bx	lr
    fd98:	2006      	movs	r0, #6
    fd9a:	4770      	bx	lr
    fd9c:	02dc6c00 	.word	0x02dc6c00
    fda0:	016e3600 	.word	0x016e3600

0000fda4 <am_hal_ctimer_int_service>:
    fda4:	b198      	cbz	r0, fdce <am_hal_ctimer_int_service+0x2a>
    fda6:	b570      	push	{r4, r5, r6, lr}
    fda8:	4e09      	ldr	r6, [pc, #36]	; (fdd0 <am_hal_ctimer_int_service+0x2c>)
    fdaa:	4604      	mov	r4, r0
    fdac:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
    fdb0:	fab4 f384 	clz	r3, r4
    fdb4:	f1c3 021f 	rsb	r2, r3, #31
    fdb8:	fa25 f303 	lsr.w	r3, r5, r3
    fdbc:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
    fdc0:	ea24 0403 	bic.w	r4, r4, r3
    fdc4:	b102      	cbz	r2, fdc8 <am_hal_ctimer_int_service+0x24>
    fdc6:	4790      	blx	r2
    fdc8:	2c00      	cmp	r4, #0
    fdca:	d1f1      	bne.n	fdb0 <am_hal_ctimer_int_service+0xc>
    fdcc:	bd70      	pop	{r4, r5, r6, pc}
    fdce:	4770      	bx	lr
    fdd0:	10006594 	.word	0x10006594

0000fdd4 <am_hal_ctimer_int_clear>:
    fdd4:	b510      	push	{r4, lr}
    fdd6:	b082      	sub	sp, #8
    fdd8:	4604      	mov	r4, r0
    fdda:	f000 fb05 	bl	103e8 <am_hal_interrupt_master_disable>
    fdde:	4b05      	ldr	r3, [pc, #20]	; (fdf4 <am_hal_ctimer_int_clear+0x20>)
    fde0:	9001      	str	r0, [sp, #4]
    fde2:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
    fde6:	9801      	ldr	r0, [sp, #4]
    fde8:	b002      	add	sp, #8
    fdea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fdee:	f000 baff 	b.w	103f0 <am_hal_interrupt_master_set>
    fdf2:	bf00      	nop
    fdf4:	40008000 	.word	0x40008000

0000fdf8 <am_hal_ctimer_int_status_get>:
    fdf8:	b510      	push	{r4, lr}
    fdfa:	b082      	sub	sp, #8
    fdfc:	4604      	mov	r4, r0
    fdfe:	f000 faf3 	bl	103e8 <am_hal_interrupt_master_disable>
    fe02:	4b0b      	ldr	r3, [pc, #44]	; (fe30 <am_hal_ctimer_int_status_get+0x38>)
    fe04:	9001      	str	r0, [sp, #4]
    fe06:	b154      	cbz	r4, fe1e <am_hal_ctimer_int_status_get+0x26>
    fe08:	f8d3 4204 	ldr.w	r4, [r3, #516]	; 0x204
    fe0c:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    fe10:	9801      	ldr	r0, [sp, #4]
    fe12:	401c      	ands	r4, r3
    fe14:	f000 faec 	bl	103f0 <am_hal_interrupt_master_set>
    fe18:	4620      	mov	r0, r4
    fe1a:	b002      	add	sp, #8
    fe1c:	bd10      	pop	{r4, pc}
    fe1e:	f8d3 4204 	ldr.w	r4, [r3, #516]	; 0x204
    fe22:	9801      	ldr	r0, [sp, #4]
    fe24:	f000 fae4 	bl	103f0 <am_hal_interrupt_master_set>
    fe28:	4620      	mov	r0, r4
    fe2a:	b002      	add	sp, #8
    fe2c:	bd10      	pop	{r4, pc}
    fe2e:	bf00      	nop
    fe30:	40008000 	.word	0x40008000

0000fe34 <am_hal_flash_delay>:
    fe34:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fe38:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    fe3a:	075b      	lsls	r3, r3, #29
    fe3c:	bf46      	itte	mi
    fe3e:	0040      	lslmi	r0, r0, #1
    fe40:	230e      	movmi	r3, #14
    fe42:	230b      	movpl	r3, #11
    fe44:	4298      	cmp	r0, r3
    fe46:	d902      	bls.n	fe4e <am_hal_flash_delay+0x1a>
    fe48:	4a01      	ldr	r2, [pc, #4]	; (fe50 <am_hal_flash_delay+0x1c>)
    fe4a:	1ac0      	subs	r0, r0, r3
    fe4c:	4710      	bx	r2
    fe4e:	4770      	bx	lr
    fe50:	0800009d 	.word	0x0800009d

0000fe54 <am_hal_flash_delay_status_check>:
    fe54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    fe58:	f89d c020 	ldrb.w	ip, [sp, #32]
    fe5c:	f8df 805c 	ldr.w	r8, [pc, #92]	; febc <am_hal_flash_delay_status_check+0x68>
    fe60:	4604      	mov	r4, r0
    fe62:	460d      	mov	r5, r1
    fe64:	4616      	mov	r6, r2
    fe66:	461f      	mov	r7, r3
    fe68:	f04f 2940 	mov.w	r9, #1073758208	; 0x40004000
    fe6c:	f1bc 0f00 	cmp.w	ip, #0
    fe70:	d00a      	beq.n	fe88 <am_hal_flash_delay_status_check+0x34>
    fe72:	e01a      	b.n	feaa <am_hal_flash_delay_status_check+0x56>
    fe74:	b1f4      	cbz	r4, feb4 <am_hal_flash_delay_status_check+0x60>
    fe76:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
    fe7a:	f013 0f04 	tst.w	r3, #4
    fe7e:	bf0c      	ite	eq
    fe80:	2005      	moveq	r0, #5
    fe82:	2012      	movne	r0, #18
    fe84:	3c01      	subs	r4, #1
    fe86:	47c0      	blx	r8
    fe88:	6828      	ldr	r0, [r5, #0]
    fe8a:	4030      	ands	r0, r6
    fe8c:	42b8      	cmp	r0, r7
    fe8e:	d0f1      	beq.n	fe74 <am_hal_flash_delay_status_check+0x20>
    fe90:	2000      	movs	r0, #0
    fe92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    fe96:	b16c      	cbz	r4, feb4 <am_hal_flash_delay_status_check+0x60>
    fe98:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
    fe9c:	f013 0f04 	tst.w	r3, #4
    fea0:	bf0c      	ite	eq
    fea2:	2005      	moveq	r0, #5
    fea4:	2012      	movne	r0, #18
    fea6:	3c01      	subs	r4, #1
    fea8:	47c0      	blx	r8
    feaa:	6828      	ldr	r0, [r5, #0]
    feac:	4030      	ands	r0, r6
    feae:	42b8      	cmp	r0, r7
    feb0:	d1f1      	bne.n	fe96 <am_hal_flash_delay_status_check+0x42>
    feb2:	e7ed      	b.n	fe90 <am_hal_flash_delay_status_check+0x3c>
    feb4:	2004      	movs	r0, #4
    feb6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    feba:	bf00      	nop
    febc:	0800009d 	.word	0x0800009d

0000fec0 <am_hal_flash_load_ui32>:
    fec0:	4b00      	ldr	r3, [pc, #0]	; (fec4 <am_hal_flash_load_ui32+0x4>)
    fec2:	4718      	bx	r3
    fec4:	08000075 	.word	0x08000075

0000fec8 <am_hal_flash_store_ui32>:
    fec8:	4b01      	ldr	r3, [pc, #4]	; (fed0 <am_hal_flash_store_ui32+0x8>)
    feca:	f043 0301 	orr.w	r3, r3, #1
    fece:	4718      	bx	r3
    fed0:	10002330 	.word	0x10002330

0000fed4 <am_hal_triple_read>:
    fed4:	b412      	push	{r1, r4}
    fed6:	f3ef 8410 	mrs	r4, PRIMASK
    feda:	b672      	cpsid	i
    fedc:	6801      	ldr	r1, [r0, #0]
    fede:	6802      	ldr	r2, [r0, #0]
    fee0:	6803      	ldr	r3, [r0, #0]
    fee2:	f384 8810 	msr	PRIMASK, r4
    fee6:	bc11      	pop	{r0, r4}
    fee8:	6001      	str	r1, [r0, #0]
    feea:	6042      	str	r2, [r0, #4]
    feec:	6083      	str	r3, [r0, #8]
    feee:	4770      	bx	lr

0000fef0 <am_hal_gpio_pinconfig>:
    fef0:	2831      	cmp	r0, #49	; 0x31
    fef2:	f200 80c3 	bhi.w	1007c <am_hal_gpio_pinconfig+0x18c>
    fef6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fefa:	4604      	mov	r4, r0
    fefc:	f011 07e0 	ands.w	r7, r1, #224	; 0xe0
    ff00:	f001 0007 	and.w	r0, r1, #7
    ff04:	b085      	sub	sp, #20
    ff06:	f3c1 03c1 	ubfx	r3, r1, #3, #2
    ff0a:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    ff0e:	d00f      	beq.n	ff30 <am_hal_gpio_pinconfig+0x40>
    ff10:	f3c1 1642 	ubfx	r6, r1, #5, #3
    ff14:	1db5      	adds	r5, r6, #6
    ff16:	f005 0507 	and.w	r5, r5, #7
    ff1a:	2d03      	cmp	r5, #3
    ff1c:	f042 0201 	orr.w	r2, r2, #1
    ff20:	f240 80ae 	bls.w	10080 <am_hal_gpio_pinconfig+0x190>
    ff24:	2fc0      	cmp	r7, #192	; 0xc0
    ff26:	f000 80e1 	beq.w	100ec <am_hal_gpio_pinconfig+0x1fc>
    ff2a:	2f20      	cmp	r7, #32
    ff2c:	f000 80e3 	beq.w	100f6 <am_hal_gpio_pinconfig+0x206>
    ff30:	b163      	cbz	r3, ff4c <am_hal_gpio_pinconfig+0x5c>
    ff32:	2b01      	cmp	r3, #1
    ff34:	f000 80d3 	beq.w	100de <am_hal_gpio_pinconfig+0x1ee>
    ff38:	2b02      	cmp	r3, #2
    ff3a:	f040 80c9 	bne.w	100d0 <am_hal_gpio_pinconfig+0x1e0>
    ff3e:	4b79      	ldr	r3, [pc, #484]	; (10124 <am_hal_gpio_pinconfig+0x234>)
    ff40:	5d1b      	ldrb	r3, [r3, r4]
    ff42:	075b      	lsls	r3, r3, #29
    ff44:	f140 80c4 	bpl.w	100d0 <am_hal_gpio_pinconfig+0x1e0>
    ff48:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    ff4c:	4b76      	ldr	r3, [pc, #472]	; (10128 <am_hal_gpio_pinconfig+0x238>)
    ff4e:	5d1b      	ldrb	r3, [r3, r4]
    ff50:	4103      	asrs	r3, r0
    ff52:	005b      	lsls	r3, r3, #1
    ff54:	f003 0302 	and.w	r3, r3, #2
    ff58:	4313      	orrs	r3, r2
    ff5a:	4a74      	ldr	r2, [pc, #464]	; (1012c <am_hal_gpio_pinconfig+0x23c>)
    ff5c:	5d12      	ldrb	r2, [r2, r4]
    ff5e:	4282      	cmp	r2, r0
    ff60:	f000 8099 	beq.w	10096 <am_hal_gpio_pinconfig+0x1a6>
    ff64:	f3c1 3000 	ubfx	r0, r1, #12, #1
    ff68:	f3c1 2581 	ubfx	r5, r1, #10, #2
    ff6c:	f3c1 3280 	ubfx	r2, r1, #14, #1
    ff70:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
    ff74:	0a88      	lsrs	r0, r1, #10
    ff76:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
    ff7a:	f000 0008 	and.w	r0, r0, #8
    ff7e:	4302      	orrs	r2, r0
    ff80:	f3c1 2007 	ubfx	r0, r1, #8, #8
    ff84:	f000 050c 	and.w	r5, r0, #12
    ff88:	2d04      	cmp	r5, #4
    ff8a:	f000 80a5 	beq.w	100d8 <am_hal_gpio_pinconfig+0x1e8>
    ff8e:	4d68      	ldr	r5, [pc, #416]	; (10130 <am_hal_gpio_pinconfig+0x240>)
    ff90:	682d      	ldr	r5, [r5, #0]
    ff92:	eba1 0805 	sub.w	r8, r1, r5
    ff96:	fab8 f888 	clz	r8, r8
    ff9a:	ea4f 1858 	mov.w	r8, r8, lsr #5
    ff9e:	f010 0f60 	tst.w	r0, #96	; 0x60
    ffa2:	bf04      	itt	eq
    ffa4:	f3c1 30c0 	ubfxeq	r0, r1, #15, #1
    ffa8:	f360 0200 	bfieq	r2, r0, #0, #1
    ffac:	00a0      	lsls	r0, r4, #2
    ffae:	f3c1 2101 	ubfx	r1, r1, #8, #2
    ffb2:	2902      	cmp	r1, #2
    ffb4:	d05c      	beq.n	10070 <am_hal_gpio_pinconfig+0x180>
    ffb6:	2903      	cmp	r1, #3
    ffb8:	d058      	beq.n	1006c <am_hal_gpio_pinconfig+0x17c>
    ffba:	2901      	cmp	r1, #1
    ffbc:	ea4f 01c4 	mov.w	r1, r4, lsl #3
    ffc0:	bf08      	it	eq
    ffc2:	f043 0304 	orreq.w	r3, r3, #4
    ffc6:	f001 0118 	and.w	r1, r1, #24
    ffca:	2700      	movs	r7, #0
    ffcc:	f000 001c 	and.w	r0, r0, #28
    ffd0:	fa02 f600 	lsl.w	r6, r2, r0
    ffd4:	220f      	movs	r2, #15
    ffd6:	4082      	lsls	r2, r0
    ffd8:	43d2      	mvns	r2, r2
    ffda:	f04f 09ff 	mov.w	r9, #255	; 0xff
    ffde:	fa03 f501 	lsl.w	r5, r3, r1
    ffe2:	fa09 f901 	lsl.w	r9, r9, r1
    ffe6:	9201      	str	r2, [sp, #4]
    ffe8:	f000 f9fe 	bl	103e8 <am_hal_interrupt_master_disable>
    ffec:	f024 0a03 	bic.w	sl, r4, #3
    fff0:	ea4f 0b54 	mov.w	fp, r4, lsr #1
    fff4:	f10a 4c80 	add.w	ip, sl, #1073741824	; 0x40000000
    fff8:	4b4e      	ldr	r3, [pc, #312]	; (10134 <am_hal_gpio_pinconfig+0x244>)
    fffa:	494f      	ldr	r1, [pc, #316]	; (10138 <am_hal_gpio_pinconfig+0x248>)
    fffc:	9a01      	ldr	r2, [sp, #4]
    fffe:	9003      	str	r0, [sp, #12]
   10000:	ea6f 0909 	mvn.w	r9, r9
   10004:	f02b 0b03 	bic.w	fp, fp, #3
   10008:	f50c 3c80 	add.w	ip, ip, #65536	; 0x10000
   1000c:	f1b8 0f00 	cmp.w	r8, #0
   10010:	d00b      	beq.n	1002a <am_hal_gpio_pinconfig+0x13a>
   10012:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
   10016:	f004 081f 	and.w	r8, r4, #31
   1001a:	4848      	ldr	r0, [pc, #288]	; (1013c <am_hal_gpio_pinconfig+0x24c>)
   1001c:	f00e 0e04 	and.w	lr, lr, #4
   10020:	2401      	movs	r4, #1
   10022:	fa04 f408 	lsl.w	r4, r4, r8
   10026:	f84e 4000 	str.w	r4, [lr, r0]
   1002a:	4845      	ldr	r0, [pc, #276]	; (10140 <am_hal_gpio_pinconfig+0x250>)
   1002c:	2473      	movs	r4, #115	; 0x73
   1002e:	6604      	str	r4, [r0, #96]	; 0x60
   10030:	f8dc 4000 	ldr.w	r4, [ip]
   10034:	ea04 0409 	and.w	r4, r4, r9
   10038:	4325      	orrs	r5, r4
   1003a:	f8cc 5000 	str.w	r5, [ip]
   1003e:	f85b 4003 	ldr.w	r4, [fp, r3]
   10042:	4022      	ands	r2, r4
   10044:	4332      	orrs	r2, r6
   10046:	f84b 2003 	str.w	r2, [fp, r3]
   1004a:	f85a 3001 	ldr.w	r3, [sl, r1]
   1004e:	ea03 0909 	and.w	r9, r3, r9
   10052:	2400      	movs	r4, #0
   10054:	ea49 0707 	orr.w	r7, r9, r7
   10058:	f84a 7001 	str.w	r7, [sl, r1]
   1005c:	6604      	str	r4, [r0, #96]	; 0x60
   1005e:	9803      	ldr	r0, [sp, #12]
   10060:	f000 f9c6 	bl	103f0 <am_hal_interrupt_master_set>
   10064:	4620      	mov	r0, r4
   10066:	b005      	add	sp, #20
   10068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1006c:	f043 0304 	orr.w	r3, r3, #4
   10070:	00e1      	lsls	r1, r4, #3
   10072:	f001 0118 	and.w	r1, r1, #24
   10076:	2701      	movs	r7, #1
   10078:	408f      	lsls	r7, r1
   1007a:	e7a7      	b.n	ffcc <am_hal_gpio_pinconfig+0xdc>
   1007c:	2006      	movs	r0, #6
   1007e:	4770      	bx	lr
   10080:	4d28      	ldr	r5, [pc, #160]	; (10124 <am_hal_gpio_pinconfig+0x234>)
   10082:	5d2d      	ldrb	r5, [r5, r4]
   10084:	3e02      	subs	r6, #2
   10086:	ea42 1286 	orr.w	r2, r2, r6, lsl #6
   1008a:	07ee      	lsls	r6, r5, #31
   1008c:	d536      	bpl.n	100fc <am_hal_gpio_pinconfig+0x20c>
   1008e:	2b00      	cmp	r3, #0
   10090:	f43f af5c 	beq.w	ff4c <am_hal_gpio_pinconfig+0x5c>
   10094:	e74d      	b.n	ff32 <am_hal_gpio_pinconfig+0x42>
   10096:	f3c1 4202 	ubfx	r2, r1, #16, #3
   1009a:	2a07      	cmp	r2, #7
   1009c:	d030      	beq.n	10100 <am_hal_gpio_pinconfig+0x210>
   1009e:	4d29      	ldr	r5, [pc, #164]	; (10144 <am_hal_gpio_pinconfig+0x254>)
   100a0:	f3c1 40c1 	ubfx	r0, r1, #19, #2
   100a4:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
   100a8:	f815 0024 	ldrb.w	r0, [r5, r4, lsl #2]
   100ac:	4290      	cmp	r0, r2
   100ae:	d029      	beq.n	10104 <am_hal_gpio_pinconfig+0x214>
   100b0:	eb05 0584 	add.w	r5, r5, r4, lsl #2
   100b4:	00a0      	lsls	r0, r4, #2
   100b6:	786e      	ldrb	r6, [r5, #1]
   100b8:	4296      	cmp	r6, r2
   100ba:	d02d      	beq.n	10118 <am_hal_gpio_pinconfig+0x228>
   100bc:	78ae      	ldrb	r6, [r5, #2]
   100be:	4296      	cmp	r6, r2
   100c0:	d02c      	beq.n	1011c <am_hal_gpio_pinconfig+0x22c>
   100c2:	78ed      	ldrb	r5, [r5, #3]
   100c4:	4295      	cmp	r5, r2
   100c6:	d02b      	beq.n	10120 <am_hal_gpio_pinconfig+0x230>
   100c8:	481f      	ldr	r0, [pc, #124]	; (10148 <am_hal_gpio_pinconfig+0x258>)
   100ca:	b005      	add	sp, #20
   100cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   100d0:	481e      	ldr	r0, [pc, #120]	; (1014c <am_hal_gpio_pinconfig+0x25c>)
   100d2:	b005      	add	sp, #20
   100d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   100d8:	f04f 0801 	mov.w	r8, #1
   100dc:	e75f      	b.n	ff9e <am_hal_gpio_pinconfig+0xae>
   100de:	4b11      	ldr	r3, [pc, #68]	; (10124 <am_hal_gpio_pinconfig+0x234>)
   100e0:	5d1b      	ldrb	r3, [r3, r4]
   100e2:	079d      	lsls	r5, r3, #30
   100e4:	d5f4      	bpl.n	100d0 <am_hal_gpio_pinconfig+0x1e0>
   100e6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   100ea:	e72f      	b.n	ff4c <am_hal_gpio_pinconfig+0x5c>
   100ec:	2c14      	cmp	r4, #20
   100ee:	f43f af1f 	beq.w	ff30 <am_hal_gpio_pinconfig+0x40>
   100f2:	4817      	ldr	r0, [pc, #92]	; (10150 <am_hal_gpio_pinconfig+0x260>)
   100f4:	e7b7      	b.n	10066 <am_hal_gpio_pinconfig+0x176>
   100f6:	2c14      	cmp	r4, #20
   100f8:	f47f af1a 	bne.w	ff30 <am_hal_gpio_pinconfig+0x40>
   100fc:	4815      	ldr	r0, [pc, #84]	; (10154 <am_hal_gpio_pinconfig+0x264>)
   100fe:	e7b2      	b.n	10066 <am_hal_gpio_pinconfig+0x176>
   10100:	4815      	ldr	r0, [pc, #84]	; (10158 <am_hal_gpio_pinconfig+0x268>)
   10102:	e7b0      	b.n	10066 <am_hal_gpio_pinconfig+0x176>
   10104:	2200      	movs	r2, #0
   10106:	00a0      	lsls	r0, r4, #2
   10108:	0052      	lsls	r2, r2, #1
   1010a:	f3c1 5540 	ubfx	r5, r1, #21, #1
   1010e:	ea42 02c5 	orr.w	r2, r2, r5, lsl #3
   10112:	f04f 0800 	mov.w	r8, #0
   10116:	e74a      	b.n	ffae <am_hal_gpio_pinconfig+0xbe>
   10118:	2201      	movs	r2, #1
   1011a:	e7f5      	b.n	10108 <am_hal_gpio_pinconfig+0x218>
   1011c:	2202      	movs	r2, #2
   1011e:	e7f3      	b.n	10108 <am_hal_gpio_pinconfig+0x218>
   10120:	2203      	movs	r2, #3
   10122:	e7f1      	b.n	10108 <am_hal_gpio_pinconfig+0x218>
   10124:	00010ec8 	.word	0x00010ec8
   10128:	00010efc 	.word	0x00010efc
   1012c:	00010ff8 	.word	0x00010ff8
   10130:	00010ebc 	.word	0x00010ebc
   10134:	40010040 	.word	0x40010040
   10138:	400100e0 	.word	0x400100e0
   1013c:	400100b4 	.word	0x400100b4
   10140:	40010000 	.word	0x40010000
   10144:	00010f30 	.word	0x00010f30
   10148:	08000104 	.word	0x08000104
   1014c:	08000102 	.word	0x08000102
   10150:	08000101 	.word	0x08000101
   10154:	08000100 	.word	0x08000100
   10158:	08000103 	.word	0x08000103

0001015c <am_hal_gpio_state_read>:
   1015c:	b15a      	cbz	r2, 10176 <am_hal_gpio_state_read+0x1a>
   1015e:	2831      	cmp	r0, #49	; 0x31
   10160:	d81d      	bhi.n	1019e <am_hal_gpio_state_read+0x42>
   10162:	08c3      	lsrs	r3, r0, #3
   10164:	2901      	cmp	r1, #1
   10166:	f003 0304 	and.w	r3, r3, #4
   1016a:	f000 001f 	and.w	r0, r0, #31
   1016e:	d01b      	beq.n	101a8 <am_hal_gpio_state_read+0x4c>
   10170:	2902      	cmp	r1, #2
   10172:	d00b      	beq.n	1018c <am_hal_gpio_state_read+0x30>
   10174:	b109      	cbz	r1, 1017a <am_hal_gpio_state_read+0x1e>
   10176:	2006      	movs	r0, #6
   10178:	4770      	bx	lr
   1017a:	4910      	ldr	r1, [pc, #64]	; (101bc <am_hal_gpio_state_read+0x60>)
   1017c:	585b      	ldr	r3, [r3, r1]
   1017e:	fa23 f000 	lsr.w	r0, r3, r0
   10182:	f000 0001 	and.w	r0, r0, #1
   10186:	6010      	str	r0, [r2, #0]
   10188:	2000      	movs	r0, #0
   1018a:	4770      	bx	lr
   1018c:	490c      	ldr	r1, [pc, #48]	; (101c0 <am_hal_gpio_state_read+0x64>)
   1018e:	585b      	ldr	r3, [r3, r1]
   10190:	fa23 f000 	lsr.w	r0, r3, r0
   10194:	f000 0001 	and.w	r0, r0, #1
   10198:	6010      	str	r0, [r2, #0]
   1019a:	2000      	movs	r0, #0
   1019c:	4770      	bx	lr
   1019e:	f04f 33ff 	mov.w	r3, #4294967295
   101a2:	6013      	str	r3, [r2, #0]
   101a4:	2005      	movs	r0, #5
   101a6:	4770      	bx	lr
   101a8:	4906      	ldr	r1, [pc, #24]	; (101c4 <am_hal_gpio_state_read+0x68>)
   101aa:	585b      	ldr	r3, [r3, r1]
   101ac:	fa23 f000 	lsr.w	r0, r3, r0
   101b0:	f000 0001 	and.w	r0, r0, #1
   101b4:	6010      	str	r0, [r2, #0]
   101b6:	2000      	movs	r0, #0
   101b8:	4770      	bx	lr
   101ba:	bf00      	nop
   101bc:	40010080 	.word	0x40010080
   101c0:	400100a0 	.word	0x400100a0
   101c4:	40010088 	.word	0x40010088

000101c8 <am_hal_gpio_state_write>:
   101c8:	2831      	cmp	r0, #49	; 0x31
   101ca:	d81a      	bhi.n	10202 <am_hal_gpio_state_write+0x3a>
   101cc:	b570      	push	{r4, r5, r6, lr}
   101ce:	2905      	cmp	r1, #5
   101d0:	b082      	sub	sp, #8
   101d2:	460d      	mov	r5, r1
   101d4:	d812      	bhi.n	101fc <am_hal_gpio_state_write+0x34>
   101d6:	f000 031f 	and.w	r3, r0, #31
   101da:	2201      	movs	r2, #1
   101dc:	08c0      	lsrs	r0, r0, #3
   101de:	fa02 f603 	lsl.w	r6, r2, r3
   101e2:	f000 0404 	and.w	r4, r0, #4
   101e6:	f000 f8ff 	bl	103e8 <am_hal_interrupt_master_disable>
   101ea:	3d01      	subs	r5, #1
   101ec:	9001      	str	r0, [sp, #4]
   101ee:	2d04      	cmp	r5, #4
   101f0:	d821      	bhi.n	10236 <am_hal_gpio_state_write+0x6e>
   101f2:	e8df f005 	tbb	[pc, r5]
   101f6:	1512      	.short	0x1512
   101f8:	1d1a      	.short	0x1d1a
   101fa:	08          	.byte	0x08
   101fb:	00          	.byte	0x00
   101fc:	2006      	movs	r0, #6
   101fe:	b002      	add	sp, #8
   10200:	bd70      	pop	{r4, r5, r6, pc}
   10202:	2005      	movs	r0, #5
   10204:	4770      	bx	lr
   10206:	4a0d      	ldr	r2, [pc, #52]	; (1023c <am_hal_gpio_state_write+0x74>)
   10208:	58a3      	ldr	r3, [r4, r2]
   1020a:	4073      	eors	r3, r6
   1020c:	50a3      	str	r3, [r4, r2]
   1020e:	9801      	ldr	r0, [sp, #4]
   10210:	f000 f8ee 	bl	103f0 <am_hal_interrupt_master_set>
   10214:	2000      	movs	r0, #0
   10216:	b002      	add	sp, #8
   10218:	bd70      	pop	{r4, r5, r6, pc}
   1021a:	4b09      	ldr	r3, [pc, #36]	; (10240 <am_hal_gpio_state_write+0x78>)
   1021c:	50e6      	str	r6, [r4, r3]
   1021e:	e7f6      	b.n	1020e <am_hal_gpio_state_write+0x46>
   10220:	4a08      	ldr	r2, [pc, #32]	; (10244 <am_hal_gpio_state_write+0x7c>)
   10222:	58a3      	ldr	r3, [r4, r2]
   10224:	4073      	eors	r3, r6
   10226:	50a3      	str	r3, [r4, r2]
   10228:	e7f1      	b.n	1020e <am_hal_gpio_state_write+0x46>
   1022a:	4b04      	ldr	r3, [pc, #16]	; (1023c <am_hal_gpio_state_write+0x74>)
   1022c:	50e6      	str	r6, [r4, r3]
   1022e:	e7ee      	b.n	1020e <am_hal_gpio_state_write+0x46>
   10230:	4b05      	ldr	r3, [pc, #20]	; (10248 <am_hal_gpio_state_write+0x80>)
   10232:	50e6      	str	r6, [r4, r3]
   10234:	e7eb      	b.n	1020e <am_hal_gpio_state_write+0x46>
   10236:	4b05      	ldr	r3, [pc, #20]	; (1024c <am_hal_gpio_state_write+0x84>)
   10238:	50e6      	str	r6, [r4, r3]
   1023a:	e7e8      	b.n	1020e <am_hal_gpio_state_write+0x46>
   1023c:	400100b4 	.word	0x400100b4
   10240:	40010090 	.word	0x40010090
   10244:	40010088 	.word	0x40010088
   10248:	400100a8 	.word	0x400100a8
   1024c:	40010098 	.word	0x40010098

00010250 <am_hal_gpio_interrupt_enable>:
   10250:	b570      	push	{r4, r5, r6, lr}
   10252:	0c8c      	lsrs	r4, r1, #18
   10254:	04a4      	lsls	r4, r4, #18
   10256:	b082      	sub	sp, #8
   10258:	b9ac      	cbnz	r4, 10286 <am_hal_gpio_interrupt_enable+0x36>
   1025a:	460d      	mov	r5, r1
   1025c:	4606      	mov	r6, r0
   1025e:	f000 f8c3 	bl	103e8 <am_hal_interrupt_master_disable>
   10262:	4b0a      	ldr	r3, [pc, #40]	; (1028c <am_hal_gpio_interrupt_enable+0x3c>)
   10264:	9001      	str	r0, [sp, #4]
   10266:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
   1026a:	4330      	orrs	r0, r6
   1026c:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
   10270:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
   10274:	430d      	orrs	r5, r1
   10276:	f8c3 5210 	str.w	r5, [r3, #528]	; 0x210
   1027a:	9801      	ldr	r0, [sp, #4]
   1027c:	f000 f8b8 	bl	103f0 <am_hal_interrupt_master_set>
   10280:	4620      	mov	r0, r4
   10282:	b002      	add	sp, #8
   10284:	bd70      	pop	{r4, r5, r6, pc}
   10286:	2005      	movs	r0, #5
   10288:	b002      	add	sp, #8
   1028a:	bd70      	pop	{r4, r5, r6, pc}
   1028c:	40010000 	.word	0x40010000

00010290 <am_hal_gpio_interrupt_clear>:
   10290:	b570      	push	{r4, r5, r6, lr}
   10292:	0c8c      	lsrs	r4, r1, #18
   10294:	04a4      	lsls	r4, r4, #18
   10296:	b082      	sub	sp, #8
   10298:	b97c      	cbnz	r4, 102ba <am_hal_gpio_interrupt_clear+0x2a>
   1029a:	460d      	mov	r5, r1
   1029c:	4606      	mov	r6, r0
   1029e:	f000 f8a3 	bl	103e8 <am_hal_interrupt_master_disable>
   102a2:	4b07      	ldr	r3, [pc, #28]	; (102c0 <am_hal_gpio_interrupt_clear+0x30>)
   102a4:	9001      	str	r0, [sp, #4]
   102a6:	f8c3 6208 	str.w	r6, [r3, #520]	; 0x208
   102aa:	f8c3 5218 	str.w	r5, [r3, #536]	; 0x218
   102ae:	9801      	ldr	r0, [sp, #4]
   102b0:	f000 f89e 	bl	103f0 <am_hal_interrupt_master_set>
   102b4:	4620      	mov	r0, r4
   102b6:	b002      	add	sp, #8
   102b8:	bd70      	pop	{r4, r5, r6, pc}
   102ba:	2005      	movs	r0, #5
   102bc:	b002      	add	sp, #8
   102be:	bd70      	pop	{r4, r5, r6, pc}
   102c0:	40010000 	.word	0x40010000

000102c4 <am_hal_gpio_interrupt_status_get>:
   102c4:	b1d1      	cbz	r1, 102fc <am_hal_gpio_interrupt_status_get+0x38>
   102c6:	b530      	push	{r4, r5, lr}
   102c8:	b083      	sub	sp, #12
   102ca:	460c      	mov	r4, r1
   102cc:	4605      	mov	r5, r0
   102ce:	f000 f88b 	bl	103e8 <am_hal_interrupt_master_disable>
   102d2:	4a0b      	ldr	r2, [pc, #44]	; (10300 <am_hal_gpio_interrupt_status_get+0x3c>)
   102d4:	9001      	str	r0, [sp, #4]
   102d6:	f8d2 3214 	ldr.w	r3, [r2, #532]	; 0x214
   102da:	f8d2 1204 	ldr.w	r1, [r2, #516]	; 0x204
   102de:	b12d      	cbz	r5, 102ec <am_hal_gpio_interrupt_status_get+0x28>
   102e0:	f8d2 0210 	ldr.w	r0, [r2, #528]	; 0x210
   102e4:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
   102e8:	4003      	ands	r3, r0
   102ea:	4011      	ands	r1, r2
   102ec:	9801      	ldr	r0, [sp, #4]
   102ee:	e9c4 1300 	strd	r1, r3, [r4]
   102f2:	f000 f87d 	bl	103f0 <am_hal_interrupt_master_set>
   102f6:	2000      	movs	r0, #0
   102f8:	b003      	add	sp, #12
   102fa:	bd30      	pop	{r4, r5, pc}
   102fc:	2006      	movs	r0, #6
   102fe:	4770      	bx	lr
   10300:	40010000 	.word	0x40010000

00010304 <am_hal_gpio_interrupt_register>:
   10304:	2831      	cmp	r0, #49	; 0x31
   10306:	4603      	mov	r3, r0
   10308:	d805      	bhi.n	10316 <am_hal_gpio_interrupt_register+0x12>
   1030a:	b131      	cbz	r1, 1031a <am_hal_gpio_interrupt_register+0x16>
   1030c:	4a04      	ldr	r2, [pc, #16]	; (10320 <am_hal_gpio_interrupt_register+0x1c>)
   1030e:	2000      	movs	r0, #0
   10310:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   10314:	4770      	bx	lr
   10316:	2005      	movs	r0, #5
   10318:	4770      	bx	lr
   1031a:	2006      	movs	r0, #6
   1031c:	4770      	bx	lr
   1031e:	bf00      	nop
   10320:	100066dc 	.word	0x100066dc

00010324 <am_hal_gpio_interrupt_service>:
   10324:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10328:	0c8b      	lsrs	r3, r1, #18
   1032a:	049b      	lsls	r3, r3, #18
   1032c:	2b00      	cmp	r3, #0
   1032e:	d14d      	bne.n	103cc <am_hal_gpio_interrupt_service+0xa8>
   10330:	ea50 0201 	orrs.w	r2, r0, r1
   10334:	460e      	mov	r6, r1
   10336:	4607      	mov	r7, r0
   10338:	d043      	beq.n	103c2 <am_hal_gpio_interrupt_service+0x9e>
   1033a:	4d27      	ldr	r5, [pc, #156]	; (103d8 <am_hal_gpio_interrupt_service+0xb4>)
   1033c:	f8df 909c 	ldr.w	r9, [pc, #156]	; 103dc <am_hal_gpio_interrupt_service+0xb8>
   10340:	469b      	mov	fp, r3
   10342:	4698      	mov	r8, r3
   10344:	f1cb 0220 	rsb	r2, fp, #32
   10348:	fa06 f202 	lsl.w	r2, r6, r2
   1034c:	f1ab 0320 	sub.w	r3, fp, #32
   10350:	fa27 fa0b 	lsr.w	sl, r7, fp
   10354:	fa26 f303 	lsr.w	r3, r6, r3
   10358:	ea4a 0a02 	orr.w	sl, sl, r2
   1035c:	ea5a 0a03 	orrs.w	sl, sl, r3
   10360:	d01a      	beq.n	10398 <am_hal_gpio_interrupt_service+0x74>
   10362:	2401      	movs	r4, #1
   10364:	f1ca 0300 	rsb	r3, sl, #0
   10368:	ea03 030a 	and.w	r3, r3, sl
   1036c:	fab3 f383 	clz	r3, r3
   10370:	f1c3 031f 	rsb	r3, r3, #31
   10374:	eb03 010b 	add.w	r1, r3, fp
   10378:	fa04 f303 	lsl.w	r3, r4, r3
   1037c:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
   10380:	ea2a 0a03 	bic.w	sl, sl, r3
   10384:	b1ba      	cbz	r2, 103b6 <am_hal_gpio_interrupt_service+0x92>
   10386:	f012 0f01 	tst.w	r2, #1
   1038a:	f042 0301 	orr.w	r3, r2, #1
   1038e:	d00b      	beq.n	103a8 <am_hal_gpio_interrupt_service+0x84>
   10390:	4790      	blx	r2
   10392:	f1ba 0f00 	cmp.w	sl, #0
   10396:	d1e5      	bne.n	10364 <am_hal_gpio_interrupt_service+0x40>
   10398:	f10b 0b20 	add.w	fp, fp, #32
   1039c:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
   103a0:	d1d0      	bne.n	10344 <am_hal_gpio_interrupt_service+0x20>
   103a2:	4640      	mov	r0, r8
   103a4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   103a8:	f859 0021 	ldr.w	r0, [r9, r1, lsl #2]
   103ac:	4798      	blx	r3
   103ae:	f1ba 0f00 	cmp.w	sl, #0
   103b2:	d1d7      	bne.n	10364 <am_hal_gpio_interrupt_service+0x40>
   103b4:	e7f0      	b.n	10398 <am_hal_gpio_interrupt_service+0x74>
   103b6:	f04f 0807 	mov.w	r8, #7
   103ba:	f1ba 0f00 	cmp.w	sl, #0
   103be:	d1d1      	bne.n	10364 <am_hal_gpio_interrupt_service+0x40>
   103c0:	e7ea      	b.n	10398 <am_hal_gpio_interrupt_service+0x74>
   103c2:	f04f 0801 	mov.w	r8, #1
   103c6:	4640      	mov	r0, r8
   103c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   103cc:	f04f 0805 	mov.w	r8, #5
   103d0:	4640      	mov	r0, r8
   103d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   103d6:	bf00      	nop
   103d8:	100066dc 	.word	0x100066dc
   103dc:	10006614 	.word	0x10006614

000103e0 <am_hal_interrupt_master_enable>:
   103e0:	f3ef 8010 	mrs	r0, PRIMASK
   103e4:	b662      	cpsie	i
   103e6:	4770      	bx	lr

000103e8 <am_hal_interrupt_master_disable>:
   103e8:	f3ef 8010 	mrs	r0, PRIMASK
   103ec:	b672      	cpsid	i
   103ee:	4770      	bx	lr

000103f0 <am_hal_interrupt_master_set>:
   103f0:	f380 8810 	msr	PRIMASK, r0
   103f4:	4770      	bx	lr
   103f6:	bf00      	nop

000103f8 <am_hal_itm_enable>:
   103f8:	4a0e      	ldr	r2, [pc, #56]	; (10434 <am_hal_itm_enable+0x3c>)
   103fa:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   103fe:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   10402:	b410      	push	{r4}
   10404:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
   10408:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   1040c:	01db      	lsls	r3, r3, #7
   1040e:	d5fb      	bpl.n	10408 <am_hal_itm_enable+0x10>
   10410:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
   10414:	4c08      	ldr	r4, [pc, #32]	; (10438 <am_hal_itm_enable+0x40>)
   10416:	4a09      	ldr	r2, [pc, #36]	; (1043c <am_hal_itm_enable+0x44>)
   10418:	f8c3 4fb0 	str.w	r4, [r3, #4016]	; 0xfb0
   1041c:	200f      	movs	r0, #15
   1041e:	f04f 31ff 	mov.w	r1, #4294967295
   10422:	f8c3 0e40 	str.w	r0, [r3, #3648]	; 0xe40
   10426:	f85d 4b04 	ldr.w	r4, [sp], #4
   1042a:	f8c3 1e00 	str.w	r1, [r3, #3584]	; 0xe00
   1042e:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
   10432:	4770      	bx	lr
   10434:	e000ed00 	.word	0xe000ed00
   10438:	c5acce55 	.word	0xc5acce55
   1043c:	00150511 	.word	0x00150511

00010440 <am_hal_itm_disable>:
   10440:	4b27      	ldr	r3, [pc, #156]	; (104e0 <am_hal_itm_disable+0xa0>)
   10442:	f8d3 3250 	ldr.w	r3, [r3, #592]	; 0x250
   10446:	b510      	push	{r4, lr}
   10448:	b9cb      	cbnz	r3, 1047e <am_hal_itm_disable+0x3e>
   1044a:	4a26      	ldr	r2, [pc, #152]	; (104e4 <am_hal_itm_disable+0xa4>)
   1044c:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   10450:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   10454:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
   10458:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   1045c:	01d9      	lsls	r1, r3, #7
   1045e:	d5fb      	bpl.n	10458 <am_hal_itm_disable+0x18>
   10460:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
   10464:	4c20      	ldr	r4, [pc, #128]	; (104e8 <am_hal_itm_disable+0xa8>)
   10466:	4a21      	ldr	r2, [pc, #132]	; (104ec <am_hal_itm_disable+0xac>)
   10468:	f8c3 4fb0 	str.w	r4, [r3, #4016]	; 0xfb0
   1046c:	200f      	movs	r0, #15
   1046e:	f04f 31ff 	mov.w	r1, #4294967295
   10472:	f8c3 0e40 	str.w	r0, [r3, #3648]	; 0xe40
   10476:	f8c3 1e00 	str.w	r1, [r3, #3584]	; 0xe00
   1047a:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
   1047e:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
   10482:	f8d4 3e80 	ldr.w	r3, [r4, #3712]	; 0xe80
   10486:	021b      	lsls	r3, r3, #8
   10488:	d4fb      	bmi.n	10482 <am_hal_itm_disable+0x42>
   1048a:	f44f 7048 	mov.w	r0, #800	; 0x320
   1048e:	f7ff fcd1 	bl	fe34 <am_hal_flash_delay>
   10492:	4b15      	ldr	r3, [pc, #84]	; (104e8 <am_hal_itm_disable+0xa8>)
   10494:	4916      	ldr	r1, [pc, #88]	; (104f0 <am_hal_itm_disable+0xb0>)
   10496:	f8c4 3fb0 	str.w	r3, [r4, #4016]	; 0xfb0
   1049a:	2064      	movs	r0, #100	; 0x64
   1049c:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   104a0:	f8d2 3e80 	ldr.w	r3, [r2, #3712]	; 0xe80
   104a4:	f023 0301 	bic.w	r3, r3, #1
   104a8:	f8c2 3e80 	str.w	r3, [r2, #3712]	; 0xe80
   104ac:	f8d2 3e80 	ldr.w	r3, [r2, #3712]	; 0xe80
   104b0:	420b      	tst	r3, r1
   104b2:	d1fb      	bne.n	104ac <am_hal_itm_disable+0x6c>
   104b4:	3801      	subs	r0, #1
   104b6:	d1f3      	bne.n	104a0 <am_hal_itm_disable+0x60>
   104b8:	4a0a      	ldr	r2, [pc, #40]	; (104e4 <am_hal_itm_disable+0xa4>)
   104ba:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   104be:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   104c2:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
   104c6:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   104ca:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
   104ce:	d1fa      	bne.n	104c6 <am_hal_itm_disable+0x86>
   104d0:	4a03      	ldr	r2, [pc, #12]	; (104e0 <am_hal_itm_disable+0xa0>)
   104d2:	f8c2 3250 	str.w	r3, [r2, #592]	; 0x250
   104d6:	f8d2 3250 	ldr.w	r3, [r2, #592]	; 0x250
   104da:	2b00      	cmp	r3, #0
   104dc:	d1fb      	bne.n	104d6 <am_hal_itm_disable+0x96>
   104de:	bd10      	pop	{r4, pc}
   104e0:	40020000 	.word	0x40020000
   104e4:	e000ed00 	.word	0xe000ed00
   104e8:	c5acce55 	.word	0xc5acce55
   104ec:	00150511 	.word	0x00150511
   104f0:	00800001 	.word	0x00800001

000104f4 <am_hal_itm_print>:
   104f4:	7803      	ldrb	r3, [r0, #0]
   104f6:	b1a3      	cbz	r3, 10522 <am_hal_itm_print+0x2e>
   104f8:	4603      	mov	r3, r0
   104fa:	f1c0 0c01 	rsb	ip, r0, #1
   104fe:	eb0c 0103 	add.w	r1, ip, r3
   10502:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   10506:	2a00      	cmp	r2, #0
   10508:	d1f9      	bne.n	104fe <am_hal_itm_print+0xa>
   1050a:	4401      	add	r1, r0
   1050c:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   10510:	f810 cb01 	ldrb.w	ip, [r0], #1
   10514:	6813      	ldr	r3, [r2, #0]
   10516:	2b00      	cmp	r3, #0
   10518:	d0fc      	beq.n	10514 <am_hal_itm_print+0x20>
   1051a:	4288      	cmp	r0, r1
   1051c:	f882 c000 	strb.w	ip, [r2]
   10520:	d1f6      	bne.n	10510 <am_hal_itm_print+0x1c>
   10522:	4770      	bx	lr

00010524 <am_hal_mcuctrl_info_get>:
   10524:	2900      	cmp	r1, #0
   10526:	f000 808f 	beq.w	10648 <am_hal_mcuctrl_info_get+0x124>
   1052a:	2801      	cmp	r0, #1
   1052c:	b430      	push	{r4, r5}
   1052e:	d006      	beq.n	1053e <am_hal_mcuctrl_info_get+0x1a>
   10530:	2802      	cmp	r0, #2
   10532:	d06d      	beq.n	10610 <am_hal_mcuctrl_info_get+0xec>
   10534:	2800      	cmp	r0, #0
   10536:	d055      	beq.n	105e4 <am_hal_mcuctrl_info_get+0xc0>
   10538:	2006      	movs	r0, #6
   1053a:	bc30      	pop	{r4, r5}
   1053c:	4770      	bx	lr
   1053e:	4a43      	ldr	r2, [pc, #268]	; (1064c <am_hal_mcuctrl_info_get+0x128>)
   10540:	4843      	ldr	r0, [pc, #268]	; (10650 <am_hal_mcuctrl_info_get+0x12c>)
   10542:	6813      	ldr	r3, [r2, #0]
   10544:	600b      	str	r3, [r1, #0]
   10546:	6854      	ldr	r4, [r2, #4]
   10548:	604c      	str	r4, [r1, #4]
   1054a:	6894      	ldr	r4, [r2, #8]
   1054c:	608c      	str	r4, [r1, #8]
   1054e:	68d4      	ldr	r4, [r2, #12]
   10550:	60cc      	str	r4, [r1, #12]
   10552:	f3c3 5503 	ubfx	r5, r3, #20, #4
   10556:	6914      	ldr	r4, [r2, #16]
   10558:	610c      	str	r4, [r1, #16]
   1055a:	f850 5025 	ldr.w	r5, [r0, r5, lsl #2]
   1055e:	4c3d      	ldr	r4, [pc, #244]	; (10654 <am_hal_mcuctrl_info_get+0x130>)
   10560:	6950      	ldr	r0, [r2, #20]
   10562:	6148      	str	r0, [r1, #20]
   10564:	f003 0201 	and.w	r2, r3, #1
   10568:	f3c3 4303 	ubfx	r3, r3, #16, #4
   1056c:	e9c1 2506 	strd	r2, r5, [r1, #24]
   10570:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   10574:	4a38      	ldr	r2, [pc, #224]	; (10658 <am_hal_mcuctrl_info_get+0x134>)
   10576:	620b      	str	r3, [r1, #32]
   10578:	f8d2 30e0 	ldr.w	r3, [r2, #224]	; 0xe0
   1057c:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
   10580:	b2db      	uxtb	r3, r3
   10582:	f000 000f 	and.w	r0, r0, #15
   10586:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   1058a:	624b      	str	r3, [r1, #36]	; 0x24
   1058c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
   10590:	f8d2 00e8 	ldr.w	r0, [r2, #232]	; 0xe8
   10594:	f3c3 1303 	ubfx	r3, r3, #4, #4
   10598:	f000 000f 	and.w	r0, r0, #15
   1059c:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
   105a0:	628b      	str	r3, [r1, #40]	; 0x28
   105a2:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
   105a6:	f8d2 00ec 	ldr.w	r0, [r2, #236]	; 0xec
   105aa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   105ae:	f3c0 1003 	ubfx	r0, r0, #4, #4
   105b2:	4303      	orrs	r3, r0
   105b4:	62cb      	str	r3, [r1, #44]	; 0x2c
   105b6:	f8d2 40fc 	ldr.w	r4, [r2, #252]	; 0xfc
   105ba:	f8d2 30f8 	ldr.w	r3, [r2, #248]	; 0xf8
   105be:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
   105c2:	f8d2 20f0 	ldr.w	r2, [r2, #240]	; 0xf0
   105c6:	b2db      	uxtb	r3, r3
   105c8:	041b      	lsls	r3, r3, #16
   105ca:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
   105ce:	fa5f fc82 	uxtb.w	ip, r2
   105d2:	ea43 030c 	orr.w	r3, r3, ip
   105d6:	b2c2      	uxtb	r2, r0
   105d8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   105dc:	630b      	str	r3, [r1, #48]	; 0x30
   105de:	2000      	movs	r0, #0
   105e0:	bc30      	pop	{r4, r5}
   105e2:	4770      	bx	lr
   105e4:	4a19      	ldr	r2, [pc, #100]	; (1064c <am_hal_mcuctrl_info_get+0x128>)
   105e6:	6993      	ldr	r3, [r2, #24]
   105e8:	f3c3 1480 	ubfx	r4, r3, #6, #1
   105ec:	700c      	strb	r4, [r1, #0]
   105ee:	f8d2 41a0 	ldr.w	r4, [r2, #416]	; 0x1a0
   105f2:	f3c3 0380 	ubfx	r3, r3, #2, #1
   105f6:	704b      	strb	r3, [r1, #1]
   105f8:	f3c4 6381 	ubfx	r3, r4, #26, #2
   105fc:	710b      	strb	r3, [r1, #4]
   105fe:	6953      	ldr	r3, [r2, #20]
   10600:	f3c3 0240 	ubfx	r2, r3, #1, #1
   10604:	f003 0301 	and.w	r3, r3, #1
   10608:	bc30      	pop	{r4, r5}
   1060a:	708a      	strb	r2, [r1, #2]
   1060c:	70cb      	strb	r3, [r1, #3]
   1060e:	4770      	bx	lr
   10610:	4a0e      	ldr	r2, [pc, #56]	; (1064c <am_hal_mcuctrl_info_get+0x128>)
   10612:	6848      	ldr	r0, [r1, #4]
   10614:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
   10618:	f003 0401 	and.w	r4, r3, #1
   1061c:	700c      	strb	r4, [r1, #0]
   1061e:	f3c3 0440 	ubfx	r4, r3, #1, #1
   10622:	720c      	strb	r4, [r1, #8]
   10624:	f8d2 41c4 	ldr.w	r4, [r2, #452]	; 0x1c4
   10628:	60cc      	str	r4, [r1, #12]
   1062a:	f8d2 41c0 	ldr.w	r4, [r2, #448]	; 0x1c0
   1062e:	4320      	orrs	r0, r4
   10630:	f3c3 0380 	ubfx	r3, r3, #2, #1
   10634:	6048      	str	r0, [r1, #4]
   10636:	f8d2 21c8 	ldr.w	r2, [r2, #456]	; 0x1c8
   1063a:	740b      	strb	r3, [r1, #16]
   1063c:	694b      	ldr	r3, [r1, #20]
   1063e:	4313      	orrs	r3, r2
   10640:	2000      	movs	r0, #0
   10642:	bc30      	pop	{r4, r5}
   10644:	614b      	str	r3, [r1, #20]
   10646:	4770      	bx	lr
   10648:	2006      	movs	r0, #6
   1064a:	4770      	bx	lr
   1064c:	40020000 	.word	0x40020000
   10650:	0001102c 	.word	0x0001102c
   10654:	0001106c 	.word	0x0001106c
   10658:	f0000f00 	.word	0xf0000f00

0001065c <am_hal_pwrctrl_memory_enable>:
   1065c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10660:	4d22      	ldr	r5, [pc, #136]	; (106ec <am_hal_pwrctrl_memory_enable+0x90>)
   10662:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   10666:	eb05 09c3 	add.w	r9, r5, r3, lsl #3
   1066a:	f855 8033 	ldr.w	r8, [r5, r3, lsl #3]
   1066e:	f8d9 6010 	ldr.w	r6, [r9, #16]
   10672:	f1b8 3fff 	cmp.w	r8, #4294967295
   10676:	4604      	mov	r4, r0
   10678:	ea4f 0740 	mov.w	r7, r0, lsl #1
   1067c:	d120      	bne.n	106c0 <am_hal_pwrctrl_memory_enable+0x64>
   1067e:	f8df 9070 	ldr.w	r9, [pc, #112]	; 106f0 <am_hal_pwrctrl_memory_enable+0x94>
   10682:	f8d9 3010 	ldr.w	r3, [r9, #16]
   10686:	443c      	add	r4, r7
   10688:	ea43 0308 	orr.w	r3, r3, r8
   1068c:	f8c9 3010 	str.w	r3, [r9, #16]
   10690:	20a0      	movs	r0, #160	; 0xa0
   10692:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
   10696:	f7ff fbcd 	bl	fe34 <am_hal_flash_delay>
   1069a:	f8d9 3014 	ldr.w	r3, [r9, #20]
   1069e:	686c      	ldr	r4, [r5, #4]
   106a0:	4033      	ands	r3, r6
   106a2:	42a3      	cmp	r3, r4
   106a4:	d004      	beq.n	106b0 <am_hal_pwrctrl_memory_enable+0x54>
   106a6:	20a0      	movs	r0, #160	; 0xa0
   106a8:	f7ff fbc4 	bl	fe34 <am_hal_flash_delay>
   106ac:	f8d9 3014 	ldr.w	r3, [r9, #20]
   106b0:	4b0f      	ldr	r3, [pc, #60]	; (106f0 <am_hal_pwrctrl_memory_enable+0x94>)
   106b2:	6958      	ldr	r0, [r3, #20]
   106b4:	4030      	ands	r0, r6
   106b6:	1b00      	subs	r0, r0, r4
   106b8:	bf18      	it	ne
   106ba:	2001      	movne	r0, #1
   106bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   106c0:	f8d9 300c 	ldr.w	r3, [r9, #12]
   106c4:	4a0a      	ldr	r2, [pc, #40]	; (106f0 <am_hal_pwrctrl_memory_enable+0x94>)
   106c6:	ea68 0303 	orn	r3, r8, r3
   106ca:	6911      	ldr	r1, [r2, #16]
   106cc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   106d0:	f043 0301 	orr.w	r3, r3, #1
   106d4:	400b      	ands	r3, r1
   106d6:	2010      	movs	r0, #16
   106d8:	6113      	str	r3, [r2, #16]
   106da:	f7ff fbab 	bl	fe34 <am_hal_flash_delay>
   106de:	f1b8 0f00 	cmp.w	r8, #0
   106e2:	d1cc      	bne.n	1067e <am_hal_pwrctrl_memory_enable+0x22>
   106e4:	f8d9 4004 	ldr.w	r4, [r9, #4]
   106e8:	e7e2      	b.n	106b0 <am_hal_pwrctrl_memory_enable+0x54>
   106ea:	bf00      	nop
   106ec:	000110ac 	.word	0x000110ac
   106f0:	40021000 	.word	0x40021000

000106f4 <am_hal_pwrctrl_low_power_init>:
   106f4:	b530      	push	{r4, r5, lr}
   106f6:	4b69      	ldr	r3, [pc, #420]	; (1089c <am_hal_pwrctrl_low_power_init+0x1a8>)
   106f8:	681a      	ldr	r2, [r3, #0]
   106fa:	b085      	sub	sp, #20
   106fc:	b912      	cbnz	r2, 10704 <am_hal_pwrctrl_low_power_init+0x10>
   106fe:	4a68      	ldr	r2, [pc, #416]	; (108a0 <am_hal_pwrctrl_low_power_init+0x1ac>)
   10700:	6812      	ldr	r2, [r2, #0]
   10702:	601a      	str	r2, [r3, #0]
   10704:	4b67      	ldr	r3, [pc, #412]	; (108a4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   10706:	68db      	ldr	r3, [r3, #12]
   10708:	b2db      	uxtb	r3, r3
   1070a:	2b12      	cmp	r3, #18
   1070c:	d104      	bne.n	10718 <am_hal_pwrctrl_low_power_init+0x24>
   1070e:	4c66      	ldr	r4, [pc, #408]	; (108a8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   10710:	6863      	ldr	r3, [r4, #4]
   10712:	07d8      	lsls	r0, r3, #31
   10714:	f100 8088 	bmi.w	10828 <am_hal_pwrctrl_low_power_init+0x134>
   10718:	4b62      	ldr	r3, [pc, #392]	; (108a4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   1071a:	68da      	ldr	r2, [r3, #12]
   1071c:	b2d2      	uxtb	r2, r2
   1071e:	2a20      	cmp	r2, #32
   10720:	d934      	bls.n	1078c <am_hal_pwrctrl_low_power_init+0x98>
   10722:	f8d3 2354 	ldr.w	r2, [r3, #852]	; 0x354
   10726:	2002      	movs	r0, #2
   10728:	f360 4213 	bfi	r2, r0, #16, #4
   1072c:	f8c3 2354 	str.w	r2, [r3, #852]	; 0x354
   10730:	f8d3 1354 	ldr.w	r1, [r3, #852]	; 0x354
   10734:	2203      	movs	r2, #3
   10736:	f362 5117 	bfi	r1, r2, #20, #4
   1073a:	f8c3 1354 	str.w	r1, [r3, #852]	; 0x354
   1073e:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   10742:	2405      	movs	r4, #5
   10744:	f364 0103 	bfi	r1, r4, #0, #4
   10748:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   1074c:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   10750:	f360 1107 	bfi	r1, r0, #4, #4
   10754:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   10758:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   1075c:	2406      	movs	r4, #6
   1075e:	f364 210b 	bfi	r1, r4, #8, #4
   10762:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   10766:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   1076a:	2001      	movs	r0, #1
   1076c:	f360 310f 	bfi	r1, r0, #12, #4
   10770:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   10774:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   10778:	f362 61de 	bfi	r1, r2, #27, #4
   1077c:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   10780:	f8d3 135c 	ldr.w	r1, [r3, #860]	; 0x35c
   10784:	f362 0103 	bfi	r1, r2, #0, #4
   10788:	f8c3 135c 	str.w	r1, [r3, #860]	; 0x35c
   1078c:	4a45      	ldr	r2, [pc, #276]	; (108a4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   1078e:	68d3      	ldr	r3, [r2, #12]
   10790:	b2db      	uxtb	r3, r3
   10792:	2b11      	cmp	r3, #17
   10794:	d905      	bls.n	107a2 <am_hal_pwrctrl_low_power_init+0xae>
   10796:	f8d2 335c 	ldr.w	r3, [r2, #860]	; 0x35c
   1079a:	f36f 6318 	bfc	r3, #24, #1
   1079e:	f8c2 335c 	str.w	r3, [r2, #860]	; 0x35c
   107a2:	2100      	movs	r1, #0
   107a4:	200c      	movs	r0, #12
   107a6:	f7ff f8c9 	bl	f93c <am_hal_cachectrl_control>
   107aa:	4b3f      	ldr	r3, [pc, #252]	; (108a8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   107ac:	699b      	ldr	r3, [r3, #24]
   107ae:	f3c3 2500 	ubfx	r5, r3, #8, #1
   107b2:	05db      	lsls	r3, r3, #23
   107b4:	d420      	bmi.n	107f8 <am_hal_pwrctrl_low_power_init+0x104>
   107b6:	4c3b      	ldr	r4, [pc, #236]	; (108a4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   107b8:	68e3      	ldr	r3, [r4, #12]
   107ba:	b2db      	uxtb	r3, r3
   107bc:	2b11      	cmp	r3, #17
   107be:	d84e      	bhi.n	1085e <am_hal_pwrctrl_low_power_init+0x16a>
   107c0:	4c38      	ldr	r4, [pc, #224]	; (108a4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   107c2:	493a      	ldr	r1, [pc, #232]	; (108ac <am_hal_pwrctrl_low_power_init+0x1b8>)
   107c4:	7e22      	ldrb	r2, [r4, #24]
   107c6:	2001      	movs	r0, #1
   107c8:	4302      	orrs	r2, r0
   107ca:	2307      	movs	r3, #7
   107cc:	7622      	strb	r2, [r4, #24]
   107ce:	9000      	str	r0, [sp, #0]
   107d0:	461a      	mov	r2, r3
   107d2:	f242 7010 	movw	r0, #10000	; 0x2710
   107d6:	f7ff fb3d 	bl	fe54 <am_hal_flash_delay_status_check>
   107da:	2800      	cmp	r0, #0
   107dc:	d15a      	bne.n	10894 <am_hal_pwrctrl_low_power_init+0x1a0>
   107de:	4b32      	ldr	r3, [pc, #200]	; (108a8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   107e0:	681a      	ldr	r2, [r3, #0]
   107e2:	f042 0201 	orr.w	r2, r2, #1
   107e6:	601a      	str	r2, [r3, #0]
   107e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   107ea:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   107ee:	625a      	str	r2, [r3, #36]	; 0x24
   107f0:	68e3      	ldr	r3, [r4, #12]
   107f2:	b2db      	uxtb	r3, r3
   107f4:	2b11      	cmp	r3, #17
   107f6:	d002      	beq.n	107fe <am_hal_pwrctrl_low_power_init+0x10a>
   107f8:	2000      	movs	r0, #0
   107fa:	b005      	add	sp, #20
   107fc:	bd30      	pop	{r4, r5, pc}
   107fe:	f8d4 335c 	ldr.w	r3, [r4, #860]	; 0x35c
   10802:	f360 5356 	bfi	r3, r0, #21, #2
   10806:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
   1080a:	f8d4 3368 	ldr.w	r3, [r4, #872]	; 0x368
   1080e:	220f      	movs	r2, #15
   10810:	f362 138b 	bfi	r3, r2, #6, #6
   10814:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
   10818:	f8d4 3368 	ldr.w	r3, [r4, #872]	; 0x368
   1081c:	f362 0305 	bfi	r3, r2, #0, #6
   10820:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
   10824:	b005      	add	sp, #20
   10826:	bd30      	pop	{r4, r5, pc}
   10828:	f7ff fdde 	bl	103e8 <am_hal_interrupt_master_disable>
   1082c:	9002      	str	r0, [sp, #8]
   1082e:	68a3      	ldr	r3, [r4, #8]
   10830:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   10834:	60a3      	str	r3, [r4, #8]
   10836:	9802      	ldr	r0, [sp, #8]
   10838:	f7ff fdda 	bl	103f0 <am_hal_interrupt_master_set>
   1083c:	20a0      	movs	r0, #160	; 0xa0
   1083e:	f7ff faf9 	bl	fe34 <am_hal_flash_delay>
   10842:	69a3      	ldr	r3, [r4, #24]
   10844:	0619      	lsls	r1, r3, #24
   10846:	d403      	bmi.n	10850 <am_hal_pwrctrl_low_power_init+0x15c>
   10848:	20a0      	movs	r0, #160	; 0xa0
   1084a:	f7ff faf3 	bl	fe34 <am_hal_flash_delay>
   1084e:	69a3      	ldr	r3, [r4, #24]
   10850:	4b15      	ldr	r3, [pc, #84]	; (108a8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   10852:	699b      	ldr	r3, [r3, #24]
   10854:	061a      	lsls	r2, r3, #24
   10856:	f53f af5f 	bmi.w	10718 <am_hal_pwrctrl_low_power_init+0x24>
   1085a:	2001      	movs	r0, #1
   1085c:	e7cd      	b.n	107fa <am_hal_pwrctrl_low_power_init+0x106>
   1085e:	f7ff fdc3 	bl	103e8 <am_hal_interrupt_master_disable>
   10862:	9003      	str	r0, [sp, #12]
   10864:	f8d4 3368 	ldr.w	r3, [r4, #872]	; 0x368
   10868:	2219      	movs	r2, #25
   1086a:	f362 138b 	bfi	r3, r2, #6, #6
   1086e:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
   10872:	f8d4 2368 	ldr.w	r2, [r4, #872]	; 0x368
   10876:	210c      	movs	r1, #12
   10878:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1087c:	f361 0205 	bfi	r2, r1, #0, #6
   10880:	f8c4 2368 	str.w	r2, [r4, #872]	; 0x368
   10884:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   10886:	f365 5296 	bfi	r2, r5, #22, #1
   1088a:	63da      	str	r2, [r3, #60]	; 0x3c
   1088c:	9803      	ldr	r0, [sp, #12]
   1088e:	f7ff fdaf 	bl	103f0 <am_hal_interrupt_master_set>
   10892:	e795      	b.n	107c0 <am_hal_pwrctrl_low_power_init+0xcc>
   10894:	2004      	movs	r0, #4
   10896:	b005      	add	sp, #20
   10898:	bd30      	pop	{r4, r5, pc}
   1089a:	bf00      	nop
   1089c:	100067a4 	.word	0x100067a4
   108a0:	4ffff000 	.word	0x4ffff000
   108a4:	40020000 	.word	0x40020000
   108a8:	40021000 	.word	0x40021000
   108ac:	40020018 	.word	0x40020018

000108b0 <am_hal_rtc_osc_disable>:
   108b0:	4a03      	ldr	r2, [pc, #12]	; (108c0 <am_hal_rtc_osc_disable+0x10>)
   108b2:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   108b6:	f043 0310 	orr.w	r3, r3, #16
   108ba:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
   108be:	4770      	bx	lr
   108c0:	40004200 	.word	0x40004200

000108c4 <am_hal_stimer_config>:
   108c4:	4a03      	ldr	r2, [pc, #12]	; (108d4 <am_hal_stimer_config+0x10>)
   108c6:	4603      	mov	r3, r0
   108c8:	f8d2 0140 	ldr.w	r0, [r2, #320]	; 0x140
   108cc:	f8c2 3140 	str.w	r3, [r2, #320]	; 0x140
   108d0:	4770      	bx	lr
   108d2:	bf00      	nop
   108d4:	40008000 	.word	0x40008000

000108d8 <am_hal_stimer_counter_get>:
   108d8:	b500      	push	{lr}
   108da:	b085      	sub	sp, #20
   108dc:	4805      	ldr	r0, [pc, #20]	; (108f4 <am_hal_stimer_counter_get+0x1c>)
   108de:	a901      	add	r1, sp, #4
   108e0:	f7ff faf8 	bl	fed4 <am_hal_triple_read>
   108e4:	e9dd 3001 	ldrd	r3, r0, [sp, #4]
   108e8:	4283      	cmp	r3, r0
   108ea:	bf18      	it	ne
   108ec:	9803      	ldrne	r0, [sp, #12]
   108ee:	b005      	add	sp, #20
   108f0:	f85d fb04 	ldr.w	pc, [sp], #4
   108f4:	40008144 	.word	0x40008144

000108f8 <am_hal_stimer_compare_delta_set>:
   108f8:	2807      	cmp	r0, #7
   108fa:	d900      	bls.n	108fe <am_hal_stimer_compare_delta_set+0x6>
   108fc:	4770      	bx	lr
   108fe:	b530      	push	{r4, r5, lr}
   10900:	b083      	sub	sp, #12
   10902:	460c      	mov	r4, r1
   10904:	4605      	mov	r5, r0
   10906:	f7ff fd6f 	bl	103e8 <am_hal_interrupt_master_disable>
   1090a:	4a27      	ldr	r2, [pc, #156]	; (109a8 <am_hal_stimer_compare_delta_set+0xb0>)
   1090c:	9001      	str	r0, [sp, #4]
   1090e:	4b27      	ldr	r3, [pc, #156]	; (109ac <am_hal_stimer_compare_delta_set+0xb4>)
   10910:	f8d2 1140 	ldr.w	r1, [r2, #320]	; 0x140
   10914:	f8d2 0140 	ldr.w	r0, [r2, #320]	; 0x140
   10918:	f44f 7c80 	mov.w	ip, #256	; 0x100
   1091c:	442b      	add	r3, r5
   1091e:	fa0c f505 	lsl.w	r5, ip, r5
   10922:	009b      	lsls	r3, r3, #2
   10924:	ea20 0005 	bic.w	r0, r0, r5
   10928:	f8c2 0140 	str.w	r0, [r2, #320]	; 0x140
   1092c:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
   10930:	601c      	str	r4, [r3, #0]
   10932:	6818      	ldr	r0, [r3, #0]
   10934:	4422      	add	r2, r4
   10936:	eba0 0c02 	sub.w	ip, r0, r2
   1093a:	f1bc 0f00 	cmp.w	ip, #0
   1093e:	db03      	blt.n	10948 <am_hal_stimer_compare_delta_set+0x50>
   10940:	320a      	adds	r2, #10
   10942:	1a82      	subs	r2, r0, r2
   10944:	2a00      	cmp	r2, #0
   10946:	dd22      	ble.n	1098e <am_hal_stimer_compare_delta_set+0x96>
   10948:	4a17      	ldr	r2, [pc, #92]	; (109a8 <am_hal_stimer_compare_delta_set+0xb0>)
   1094a:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
   1094e:	601c      	str	r4, [r3, #0]
   10950:	6818      	ldr	r0, [r3, #0]
   10952:	4422      	add	r2, r4
   10954:	eba0 0c02 	sub.w	ip, r0, r2
   10958:	f1bc 0f00 	cmp.w	ip, #0
   1095c:	db03      	blt.n	10966 <am_hal_stimer_compare_delta_set+0x6e>
   1095e:	320a      	adds	r2, #10
   10960:	1a82      	subs	r2, r0, r2
   10962:	2a00      	cmp	r2, #0
   10964:	dd13      	ble.n	1098e <am_hal_stimer_compare_delta_set+0x96>
   10966:	4a10      	ldr	r2, [pc, #64]	; (109a8 <am_hal_stimer_compare_delta_set+0xb0>)
   10968:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
   1096c:	601c      	str	r4, [r3, #0]
   1096e:	6818      	ldr	r0, [r3, #0]
   10970:	4422      	add	r2, r4
   10972:	eba0 0c02 	sub.w	ip, r0, r2
   10976:	f1bc 0f00 	cmp.w	ip, #0
   1097a:	db03      	blt.n	10984 <am_hal_stimer_compare_delta_set+0x8c>
   1097c:	320a      	adds	r2, #10
   1097e:	1a82      	subs	r2, r0, r2
   10980:	2a00      	cmp	r2, #0
   10982:	dd04      	ble.n	1098e <am_hal_stimer_compare_delta_set+0x96>
   10984:	4a08      	ldr	r2, [pc, #32]	; (109a8 <am_hal_stimer_compare_delta_set+0xb0>)
   10986:	f8d2 2144 	ldr.w	r2, [r2, #324]	; 0x144
   1098a:	601c      	str	r4, [r3, #0]
   1098c:	681b      	ldr	r3, [r3, #0]
   1098e:	4b06      	ldr	r3, [pc, #24]	; (109a8 <am_hal_stimer_compare_delta_set+0xb0>)
   10990:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   10994:	400d      	ands	r5, r1
   10996:	4315      	orrs	r5, r2
   10998:	f8c3 5140 	str.w	r5, [r3, #320]	; 0x140
   1099c:	9801      	ldr	r0, [sp, #4]
   1099e:	b003      	add	sp, #12
   109a0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   109a4:	f7ff bd24 	b.w	103f0 <am_hal_interrupt_master_set>
   109a8:	40008000 	.word	0x40008000
   109ac:	10002054 	.word	0x10002054

000109b0 <am_hal_stimer_int_enable>:
   109b0:	4a03      	ldr	r2, [pc, #12]	; (109c0 <am_hal_stimer_int_enable+0x10>)
   109b2:	f8d2 3300 	ldr.w	r3, [r2, #768]	; 0x300
   109b6:	4318      	orrs	r0, r3
   109b8:	f8c2 0300 	str.w	r0, [r2, #768]	; 0x300
   109bc:	4770      	bx	lr
   109be:	bf00      	nop
   109c0:	40008000 	.word	0x40008000

000109c4 <am_hal_stimer_int_clear>:
   109c4:	4b01      	ldr	r3, [pc, #4]	; (109cc <am_hal_stimer_int_clear+0x8>)
   109c6:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
   109ca:	4770      	bx	lr
   109cc:	40008000 	.word	0x40008000

000109d0 <am_hal_stimer_int_status_get>:
   109d0:	4a04      	ldr	r2, [pc, #16]	; (109e4 <am_hal_stimer_int_status_get+0x14>)
   109d2:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
   109d6:	b110      	cbz	r0, 109de <am_hal_stimer_int_status_get+0xe>
   109d8:	f8d2 2300 	ldr.w	r2, [r2, #768]	; 0x300
   109dc:	4013      	ands	r3, r2
   109de:	4618      	mov	r0, r3
   109e0:	4770      	bx	lr
   109e2:	bf00      	nop
   109e4:	40008000 	.word	0x40008000

000109e8 <am_hal_sysctrl_sleep>:
   109e8:	b510      	push	{r4, lr}
   109ea:	b082      	sub	sp, #8
   109ec:	4604      	mov	r4, r0
   109ee:	f7ff fcfb 	bl	103e8 <am_hal_interrupt_master_disable>
   109f2:	9001      	str	r0, [sp, #4]
   109f4:	b124      	cbz	r4, 10a00 <am_hal_sysctrl_sleep+0x18>
   109f6:	4b12      	ldr	r3, [pc, #72]	; (10a40 <am_hal_sysctrl_sleep+0x58>)
   109f8:	f8d3 3250 	ldr.w	r3, [r3, #592]	; 0x250
   109fc:	07db      	lsls	r3, r3, #31
   109fe:	d513      	bpl.n	10a28 <am_hal_sysctrl_sleep+0x40>
   10a00:	4a10      	ldr	r2, [pc, #64]	; (10a44 <am_hal_sysctrl_sleep+0x5c>)
   10a02:	6913      	ldr	r3, [r2, #16]
   10a04:	f023 0304 	bic.w	r3, r3, #4
   10a08:	6113      	str	r3, [r2, #16]
   10a0a:	f3bf 8f4f 	dsb	sy
   10a0e:	4a0e      	ldr	r2, [pc, #56]	; (10a48 <am_hal_sysctrl_sleep+0x60>)
   10a10:	4b0e      	ldr	r3, [pc, #56]	; (10a4c <am_hal_sysctrl_sleep+0x64>)
   10a12:	6812      	ldr	r2, [r2, #0]
   10a14:	601a      	str	r2, [r3, #0]
   10a16:	bf30      	wfi
   10a18:	f3bf 8f6f 	isb	sy
   10a1c:	9801      	ldr	r0, [sp, #4]
   10a1e:	b002      	add	sp, #8
   10a20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10a24:	f7ff bce4 	b.w	103f0 <am_hal_interrupt_master_set>
   10a28:	4b09      	ldr	r3, [pc, #36]	; (10a50 <am_hal_sysctrl_sleep+0x68>)
   10a2a:	681a      	ldr	r2, [r3, #0]
   10a2c:	b912      	cbnz	r2, 10a34 <am_hal_sysctrl_sleep+0x4c>
   10a2e:	4a09      	ldr	r2, [pc, #36]	; (10a54 <am_hal_sysctrl_sleep+0x6c>)
   10a30:	6812      	ldr	r2, [r2, #0]
   10a32:	601a      	str	r2, [r3, #0]
   10a34:	4a03      	ldr	r2, [pc, #12]	; (10a44 <am_hal_sysctrl_sleep+0x5c>)
   10a36:	6913      	ldr	r3, [r2, #16]
   10a38:	f043 0304 	orr.w	r3, r3, #4
   10a3c:	6113      	str	r3, [r2, #16]
   10a3e:	e7e4      	b.n	10a0a <am_hal_sysctrl_sleep+0x22>
   10a40:	40020000 	.word	0x40020000
   10a44:	e000ed00 	.word	0xe000ed00
   10a48:	5fff0000 	.word	0x5fff0000
   10a4c:	100067a8 	.word	0x100067a8
   10a50:	100067a4 	.word	0x100067a4
   10a54:	4ffff000 	.word	0x4ffff000

00010a58 <am_hal_sysctrl_fpu_enable>:
   10a58:	4b02      	ldr	r3, [pc, #8]	; (10a64 <am_hal_sysctrl_fpu_enable+0xc>)
   10a5a:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
   10a5e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
   10a62:	4770      	bx	lr
   10a64:	e000ed00 	.word	0xe000ed00

00010a68 <am_hal_sysctrl_fpu_stacking_enable>:
   10a68:	b510      	push	{r4, lr}
   10a6a:	b082      	sub	sp, #8
   10a6c:	4604      	mov	r4, r0
   10a6e:	f7ff fcbb 	bl	103e8 <am_hal_interrupt_master_disable>
   10a72:	4909      	ldr	r1, [pc, #36]	; (10a98 <am_hal_sysctrl_fpu_stacking_enable+0x30>)
   10a74:	9001      	str	r0, [sp, #4]
   10a76:	6b4a      	ldr	r2, [r1, #52]	; 0x34
   10a78:	2c00      	cmp	r4, #0
   10a7a:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
   10a7e:	bf14      	ite	ne
   10a80:	f04f 4340 	movne.w	r3, #3221225472	; 0xc0000000
   10a84:	f04f 4300 	moveq.w	r3, #2147483648	; 0x80000000
   10a88:	4313      	orrs	r3, r2
   10a8a:	634b      	str	r3, [r1, #52]	; 0x34
   10a8c:	9801      	ldr	r0, [sp, #4]
   10a8e:	b002      	add	sp, #8
   10a90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10a94:	f7ff bcac 	b.w	103f0 <am_hal_interrupt_master_set>
   10a98:	e000ef00 	.word	0xe000ef00

00010a9c <am_hal_tpiu_enable>:
   10a9c:	b510      	push	{r4, lr}
   10a9e:	4b23      	ldr	r3, [pc, #140]	; (10b2c <am_hal_tpiu_enable+0x90>)
   10aa0:	6804      	ldr	r4, [r0, #0]
   10aa2:	2200      	movs	r2, #0
   10aa4:	b084      	sub	sp, #16
   10aa6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
   10aaa:	b334      	cbz	r4, 10afa <am_hal_tpiu_enable+0x5e>
   10aac:	4a20      	ldr	r2, [pc, #128]	; (10b30 <am_hal_tpiu_enable+0x94>)
   10aae:	4921      	ldr	r1, [pc, #132]	; (10b34 <am_hal_tpiu_enable+0x98>)
   10ab0:	2001      	movs	r0, #1
   10ab2:	6058      	str	r0, [r3, #4]
   10ab4:	f5a4 4361 	sub.w	r3, r4, #57600	; 0xe100
   10ab8:	a801      	add	r0, sp, #4
   10aba:	428b      	cmp	r3, r1
   10abc:	bf88      	it	hi
   10abe:	4614      	movhi	r4, r2
   10ac0:	f7ff f952 	bl	fd68 <am_hal_clkgen_status_get>
   10ac4:	9b01      	ldr	r3, [sp, #4]
   10ac6:	1c5a      	adds	r2, r3, #1
   10ac8:	d02d      	beq.n	10b26 <am_hal_tpiu_enable+0x8a>
   10aca:	08db      	lsrs	r3, r3, #3
   10acc:	fbb3 f4f4 	udiv	r4, r3, r4
   10ad0:	3c01      	subs	r4, #1
   10ad2:	b2a4      	uxth	r4, r4
   10ad4:	4b15      	ldr	r3, [pc, #84]	; (10b2c <am_hal_tpiu_enable+0x90>)
   10ad6:	4a18      	ldr	r2, [pc, #96]	; (10b38 <am_hal_tpiu_enable+0x9c>)
   10ad8:	611c      	str	r4, [r3, #16]
   10ada:	2102      	movs	r1, #2
   10adc:	f8c3 10f0 	str.w	r1, [r3, #240]	; 0xf0
   10ae0:	2000      	movs	r0, #0
   10ae2:	f240 2101 	movw	r1, #513	; 0x201
   10ae6:	f8c3 0f00 	str.w	r0, [r3, #3840]	; 0xf00
   10aea:	f8c2 1250 	str.w	r1, [r2, #592]	; 0x250
   10aee:	f44f 7048 	mov.w	r0, #800	; 0x320
   10af2:	f7ff f99f 	bl	fe34 <am_hal_flash_delay>
   10af6:	b004      	add	sp, #16
   10af8:	bd10      	pop	{r4, pc}
   10afa:	6902      	ldr	r2, [r0, #16]
   10afc:	611a      	str	r2, [r3, #16]
   10afe:	6882      	ldr	r2, [r0, #8]
   10b00:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
   10b04:	68c1      	ldr	r1, [r0, #12]
   10b06:	2201      	movs	r2, #1
   10b08:	3901      	subs	r1, #1
   10b0a:	408a      	lsls	r2, r1
   10b0c:	605a      	str	r2, [r3, #4]
   10b0e:	f8c3 4f00 	str.w	r4, [r3, #3840]	; 0xf00
   10b12:	4a09      	ldr	r2, [pc, #36]	; (10b38 <am_hal_tpiu_enable+0x9c>)
   10b14:	6843      	ldr	r3, [r0, #4]
   10b16:	f8c2 3250 	str.w	r3, [r2, #592]	; 0x250
   10b1a:	f44f 7048 	mov.w	r0, #800	; 0x320
   10b1e:	f7ff f989 	bl	fe34 <am_hal_flash_delay>
   10b22:	b004      	add	sp, #16
   10b24:	bd10      	pop	{r4, pc}
   10b26:	2405      	movs	r4, #5
   10b28:	e7d4      	b.n	10ad4 <am_hal_tpiu_enable+0x38>
   10b2a:	bf00      	nop
   10b2c:	e0040000 	.word	0xe0040000
   10b30:	000f4240 	.word	0x000f4240
   10b34:	001da380 	.word	0x001da380
   10b38:	40020000 	.word	0x40020000
   10b3c:	65657246 	.word	0x65657246
   10b40:	534f5452 	.word	0x534f5452
   10b44:	776f4c20 	.word	0x776f4c20
   10b48:	776f5020 	.word	0x776f5020
   10b4c:	45207265 	.word	0x45207265
   10b50:	706d6178 	.word	0x706d6178
   10b54:	000a656c 	.word	0x000a656c
   10b58:	5444454c 	.word	0x5444454c
   10b5c:	3a6b7361 	.word	0x3a6b7361
   10b60:	74657320 	.word	0x74657320
   10b64:	0a0d7075 	.word	0x0a0d7075
   10b68:	00000000 	.word	0x00000000
   10b6c:	6e6e7552 	.word	0x6e6e7552
   10b70:	20676e69 	.word	0x20676e69
   10b74:	75746573 	.word	0x75746573
   10b78:	61742070 	.word	0x61742070
   10b7c:	2e736b73 	.word	0x2e736b73
   10b80:	0a0d2e2e 	.word	0x0a0d2e2e
   10b84:	00000000 	.word	0x00000000
   10b88:	5444454c 	.word	0x5444454c
   10b8c:	006b7361 	.word	0x006b7361
   10b90:	75746553 	.word	0x75746553
   10b94:	00000070 	.word	0x00000070
   10b98:	20726d54 	.word	0x20726d54
   10b9c:	00637653 	.word	0x00637653
   10ba0:	64726148 	.word	0x64726148
   10ba4:	75614620 	.word	0x75614620
   10ba8:	7320746c 	.word	0x7320746c
   10bac:	6b636174 	.word	0x6b636174
   10bb0:	64206465 	.word	0x64206465
   10bb4:	3a617461 	.word	0x3a617461
   10bb8:	0000000a 	.word	0x0000000a
   10bbc:	20202020 	.word	0x20202020
   10bc0:	20203052 	.word	0x20203052
   10bc4:	7830203d 	.word	0x7830203d
   10bc8:	58383025 	.word	0x58383025
   10bcc:	0000000a 	.word	0x0000000a
   10bd0:	20202020 	.word	0x20202020
   10bd4:	20203152 	.word	0x20203152
   10bd8:	7830203d 	.word	0x7830203d
   10bdc:	58383025 	.word	0x58383025
   10be0:	0000000a 	.word	0x0000000a
   10be4:	20202020 	.word	0x20202020
   10be8:	20203252 	.word	0x20203252
   10bec:	7830203d 	.word	0x7830203d
   10bf0:	58383025 	.word	0x58383025
   10bf4:	0000000a 	.word	0x0000000a
   10bf8:	20202020 	.word	0x20202020
   10bfc:	20203352 	.word	0x20203352
   10c00:	7830203d 	.word	0x7830203d
   10c04:	58383025 	.word	0x58383025
   10c08:	0000000a 	.word	0x0000000a
   10c0c:	20202020 	.word	0x20202020
   10c10:	20323152 	.word	0x20323152
   10c14:	7830203d 	.word	0x7830203d
   10c18:	58383025 	.word	0x58383025
   10c1c:	0000000a 	.word	0x0000000a
   10c20:	20202020 	.word	0x20202020
   10c24:	2020524c 	.word	0x2020524c
   10c28:	7830203d 	.word	0x7830203d
   10c2c:	58383025 	.word	0x58383025
   10c30:	0000000a 	.word	0x0000000a
   10c34:	20202020 	.word	0x20202020
   10c38:	20204350 	.word	0x20204350
   10c3c:	7830203d 	.word	0x7830203d
   10c40:	58383025 	.word	0x58383025
   10c44:	0000000a 	.word	0x0000000a
   10c48:	20202020 	.word	0x20202020
   10c4c:	20525350 	.word	0x20525350
   10c50:	7830203d 	.word	0x7830203d
   10c54:	58383025 	.word	0x58383025
   10c58:	0000000a 	.word	0x0000000a
   10c5c:	6568744f 	.word	0x6568744f
   10c60:	61482072 	.word	0x61482072
   10c64:	46206472 	.word	0x46206472
   10c68:	746c7561 	.word	0x746c7561
   10c6c:	74616420 	.word	0x74616420
   10c70:	000a3a61 	.word	0x000a3a61
   10c74:	20202020 	.word	0x20202020
   10c78:	6c756146 	.word	0x6c756146
   10c7c:	64612074 	.word	0x64612074
   10c80:	73657264 	.word	0x73657264
   10c84:	203d2073 	.word	0x203d2073
   10c88:	30257830 	.word	0x30257830
   10c8c:	000a5838 	.word	0x000a5838
   10c90:	20202020 	.word	0x20202020
   10c94:	52414642 	.word	0x52414642
   10c98:	75422820 	.word	0x75422820
   10c9c:	61462073 	.word	0x61462073
   10ca0:	20746c75 	.word	0x20746c75
   10ca4:	72646441 	.word	0x72646441
   10ca8:	67655220 	.word	0x67655220
   10cac:	203d2029 	.word	0x203d2029
   10cb0:	30257830 	.word	0x30257830
   10cb4:	000a5838 	.word	0x000a5838
   10cb8:	20202020 	.word	0x20202020
   10cbc:	52534d4d 	.word	0x52534d4d
   10cc0:	654d2820 	.word	0x654d2820
   10cc4:	674d206d 	.word	0x674d206d
   10cc8:	4620746d 	.word	0x4620746d
   10ccc:	746c7561 	.word	0x746c7561
   10cd0:	61745320 	.word	0x61745320
   10cd4:	20737574 	.word	0x20737574
   10cd8:	29676552 	.word	0x29676552
   10cdc:	30203d20 	.word	0x30203d20
   10ce0:	32302578 	.word	0x32302578
   10ce4:	00000a58 	.word	0x00000a58
   10ce8:	20202020 	.word	0x20202020
   10cec:	52534642 	.word	0x52534642
   10cf0:	75422820 	.word	0x75422820
   10cf4:	61462073 	.word	0x61462073
   10cf8:	20746c75 	.word	0x20746c75
   10cfc:	74617453 	.word	0x74617453
   10d00:	52207375 	.word	0x52207375
   10d04:	20296765 	.word	0x20296765
   10d08:	7830203d 	.word	0x7830203d
   10d0c:	58323025 	.word	0x58323025
   10d10:	0000000a 	.word	0x0000000a
   10d14:	20202020 	.word	0x20202020
   10d18:	52534655 	.word	0x52534655
   10d1c:	73552820 	.word	0x73552820
   10d20:	20656761 	.word	0x20656761
   10d24:	6c756146 	.word	0x6c756146
   10d28:	74532074 	.word	0x74532074
   10d2c:	73757461 	.word	0x73757461
   10d30:	67655220 	.word	0x67655220
   10d34:	203d2029 	.word	0x203d2029
   10d38:	30257830 	.word	0x30257830
   10d3c:	000a5834 	.word	0x000a5834
   10d40:	20202020 	.word	0x20202020
   10d44:	20202020 	.word	0x20202020
   10d48:	52534642 	.word	0x52534642
   10d4c:	74696220 	.word	0x74696220
   10d50:	49203a30 	.word	0x49203a30
   10d54:	45535542 	.word	0x45535542
   10d58:	000a5252 	.word	0x000a5252
   10d5c:	20202020 	.word	0x20202020
   10d60:	20202020 	.word	0x20202020
   10d64:	52534642 	.word	0x52534642
   10d68:	74696220 	.word	0x74696220
   10d6c:	50203a31 	.word	0x50203a31
   10d70:	49434552 	.word	0x49434552
   10d74:	52454553 	.word	0x52454553
   10d78:	00000a52 	.word	0x00000a52
   10d7c:	20202020 	.word	0x20202020
   10d80:	20202020 	.word	0x20202020
   10d84:	52534642 	.word	0x52534642
   10d88:	74696220 	.word	0x74696220
   10d8c:	49203a32 	.word	0x49203a32
   10d90:	4552504d 	.word	0x4552504d
   10d94:	45534943 	.word	0x45534943
   10d98:	000a5252 	.word	0x000a5252
   10d9c:	20202020 	.word	0x20202020
   10da0:	20202020 	.word	0x20202020
   10da4:	52534642 	.word	0x52534642
   10da8:	74696220 	.word	0x74696220
   10dac:	55203a33 	.word	0x55203a33
   10db0:	4b54534e 	.word	0x4b54534e
   10db4:	0a525245 	.word	0x0a525245
   10db8:	00000000 	.word	0x00000000
   10dbc:	20202020 	.word	0x20202020
   10dc0:	20202020 	.word	0x20202020
   10dc4:	52534642 	.word	0x52534642
   10dc8:	74696220 	.word	0x74696220
   10dcc:	53203a34 	.word	0x53203a34
   10dd0:	52454b54 	.word	0x52454b54
   10dd4:	00000a52 	.word	0x00000a52
   10dd8:	20202020 	.word	0x20202020
   10ddc:	20202020 	.word	0x20202020
   10de0:	52534642 	.word	0x52534642
   10de4:	74696220 	.word	0x74696220
   10de8:	4c203a35 	.word	0x4c203a35
   10dec:	52455053 	.word	0x52455053
   10df0:	00000a52 	.word	0x00000a52
   10df4:	20202020 	.word	0x20202020
   10df8:	20202020 	.word	0x20202020
   10dfc:	52534642 	.word	0x52534642
   10e00:	74696220 	.word	0x74696220
   10e04:	52203a36 	.word	0x52203a36
   10e08:	52455345 	.word	0x52455345
   10e0c:	0a444556 	.word	0x0a444556
   10e10:	00000000 	.word	0x00000000
   10e14:	20202020 	.word	0x20202020
   10e18:	20202020 	.word	0x20202020
   10e1c:	52534642 	.word	0x52534642
   10e20:	74696220 	.word	0x74696220
   10e24:	42203a37 	.word	0x42203a37
   10e28:	56524146 	.word	0x56524146
   10e2c:	44494c41 	.word	0x44494c41
   10e30:	0000000a 	.word	0x0000000a
   10e34:	2055434d 	.word	0x2055434d
   10e38:	6c756146 	.word	0x6c756146
   10e3c:	61642074 	.word	0x61642074
   10e40:	0a3a6174 	.word	0x0a3a6174
   10e44:	00000000 	.word	0x00000000
   10e48:	49202020 	.word	0x49202020
   10e4c:	45444f43 	.word	0x45444f43
   10e50:	75614620 	.word	0x75614620
   10e54:	4120746c 	.word	0x4120746c
   10e58:	65726464 	.word	0x65726464
   10e5c:	203a7373 	.word	0x203a7373
   10e60:	30257830 	.word	0x30257830
   10e64:	000a5838 	.word	0x000a5838
   10e68:	44202020 	.word	0x44202020
   10e6c:	45444f43 	.word	0x45444f43
   10e70:	75614620 	.word	0x75614620
   10e74:	4120746c 	.word	0x4120746c
   10e78:	65726464 	.word	0x65726464
   10e7c:	203a7373 	.word	0x203a7373
   10e80:	30257830 	.word	0x30257830
   10e84:	000a5838 	.word	0x000a5838
   10e88:	53202020 	.word	0x53202020
   10e8c:	46205359 	.word	0x46205359
   10e90:	746c7561 	.word	0x746c7561
   10e94:	64644120 	.word	0x64644120
   10e98:	73736572 	.word	0x73736572
   10e9c:	7830203a 	.word	0x7830203a
   10ea0:	58383025 	.word	0x58383025
   10ea4:	0000000a 	.word	0x0000000a

00010ea8 <g_AM_BSP_GPIO_BUTTON0>:
   10ea8:	00001003                                ....

00010eac <g_AM_BSP_GPIO_BUTTON1>:
   10eac:	00001003                                ....

00010eb0 <g_AM_BSP_GPIO_BUTTON2>:
   10eb0:	00001003                                ....

00010eb4 <g_AM_BSP_GPIO_ITM_SWO>:
   10eb4:	00000002                                ....

00010eb8 <am_hal_cachectrl_defaults>:
   10eb8:	00000308                                ....

00010ebc <g_AM_HAL_GPIO_DISABLE>:
   10ebc:	00000003                                ....

00010ec0 <g_AM_HAL_GPIO_OUTPUT>:
   10ec0:	00000403                                ....

00010ec4 <g_AM_HAL_GPIO_TRISTATE>:
   10ec4:	00000c03                                ....

00010ec8 <g_ui8Bit76Capabilities>:
   10ec8:	02800101 80010180 80800101 80808080     ................
   10ed8:	80808080 80808008 01800180 80808080     ................
   10ee8:	80808080 01800402 01010401 80808080     ................
   10ef8:	00000101                                ....

00010efc <g_ui8Inpen>:
   10efc:	62272323 108703a1 e1005303 55418151     ##'b.....S..Q.AU
   10f0c:	4080c405 4140b101 31a03114 1180f100     ...@..@A.1.1....
   10f1c:	11c12191 304511e5 31300037 40007100     .!....E07.01.q.@
   10f2c:	00003130                                01..

00010f30 <g_ui8NCEtable>:
   10f30:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   10f40:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   10f50:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   10f60:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   10f70:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   10f80:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   10f90:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   10fa0:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   10fb0:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   10fc0:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   10fd0:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   10fe0:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   10ff0:	32221202 43231303                       .."2..#C

00010ff8 <g_ui8nCEpins>:
   10ff8:	02070707 00080802 01020202 01010101     ................
   11008:	01010101 01010101 01010101 01010101     ................
   11018:	01010101 08010101 01010008 01010101     ................
   11028:	00000101                                ....

0001102c <g_am_hal_mcuctrl_flash_size>:
   1102c:	00004000 00008000 00010000 00020000     .@..............
   1103c:	00040000 00080000 00100000 00200000     .............. .
   1104c:	00180000 00000000 00000000 00000000     ................
	...

0001106c <g_am_hal_mcuctrl_sram_size>:
   1106c:	00004000 00008000 00010000 00020000     .@..............
   1107c:	00040000 00080000 00100000 00060000     ................
   1108c:	000c0000 00000000 00000000 00000000     ................
	...

000110ac <am_hal_pwrctrl_memory_control>:
	...
   110c4:	00000001 00000001 00000001 00001fff     ................
   110d4:	00001fff 00000001 00000003 00000003     ................
   110e4:	00000003 00001fff 00001fff 00000003     ................
   110f4:	00000007 00000007 00000007 00001fff     ................
   11104:	00001fff 00000007 0000000f 0000000f     ................
   11114:	0000000f 00001fff 00001fff 0000000f     ................
   11124:	0000001f 0000001f 0000001f 00001fff     ................
   11134:	00001fff 0000001f 0000003f 0000003f     ........?...?...
   11144:	0000003f 00001fff 00001fff 0000003f     ?...........?...
   11154:	0000007f 0000007f 0000007f 00001fff     ................
   11164:	00001fff 0000007f 000000ff 000000ff     ................
   11174:	000000ff 00001fff 00001fff 000000ff     ................
   11184:	000001ff 000001ff 000001ff 00001fff     ................
   11194:	00001fff 000001ff 000003ff 000003ff     ................
   111a4:	000003ff 00001fff 00001fff 000003ff     ................
   111b4:	000007ff 000007ff 000007ff 00001fff     ................
   111c4:	00001fff 000007ff 00000fff 00000fff     ................
   111d4:	00000fff 00001fff 00001fff 00000fff     ................
   111e4:	00001fff 00001fff 00001fff 00001fff     ................
   111f4:	00001fff 00001fff 00002000 00002000     ......... ... ..
   11204:	00002000 00006000 00006000 00002000     . ...`...`... ..
   11214:	00006000 00006000 00006000 00006000     .`...`...`...`..
   11224:	00006000 00006000 c0000000 00000000     .`...`..........
   11234:	c0000000 c0000000 00000000 80000000     ................
   11244:	c0007fff 00007fff c0007fff c0007fff     ................
   11254:	00007fff 80007fff                       ........
