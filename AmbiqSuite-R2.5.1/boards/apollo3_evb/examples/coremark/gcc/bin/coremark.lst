
bin/coremark.axf:     file format elf32-littlearm


Disassembly of section .text:

0000c000 <g_am_pfnVectors>:
    c000:	00 10 00 10 29 f8 00 00 1d f8 00 00 19 ec 00 00     ....)...........
    c010:	21 f8 00 00 21 f8 00 00 21 f8 00 00 00 00 00 00     !...!...!.......
	...
    c02c:	25 f8 00 00 25 f8 00 00 00 00 00 00 25 f8 00 00     %...%.......%...
    c03c:	8d ca 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     ....%...%...%...
    c04c:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c05c:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c06c:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c07c:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c08c:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c09c:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c0ac:	25 f8 00 00 25 f8 00 00 25 f8 00 00 25 f8 00 00     %...%...%...%...
    c0bc:	25 f8 00 00                                         %...

0000c0c0 <__Patchable>:
	...

0000c100 <__aeabi_drsub>:
    c100:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    c104:	e002      	b.n	c10c <__adddf3>
    c106:	bf00      	nop

0000c108 <__aeabi_dsub>:
    c108:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000c10c <__adddf3>:
    c10c:	b530      	push	{r4, r5, lr}
    c10e:	ea4f 0441 	mov.w	r4, r1, lsl #1
    c112:	ea4f 0543 	mov.w	r5, r3, lsl #1
    c116:	ea94 0f05 	teq	r4, r5
    c11a:	bf08      	it	eq
    c11c:	ea90 0f02 	teqeq	r0, r2
    c120:	bf1f      	itttt	ne
    c122:	ea54 0c00 	orrsne.w	ip, r4, r0
    c126:	ea55 0c02 	orrsne.w	ip, r5, r2
    c12a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    c12e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c132:	f000 80e2 	beq.w	c2fa <__adddf3+0x1ee>
    c136:	ea4f 5454 	mov.w	r4, r4, lsr #21
    c13a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    c13e:	bfb8      	it	lt
    c140:	426d      	neglt	r5, r5
    c142:	dd0c      	ble.n	c15e <__adddf3+0x52>
    c144:	442c      	add	r4, r5
    c146:	ea80 0202 	eor.w	r2, r0, r2
    c14a:	ea81 0303 	eor.w	r3, r1, r3
    c14e:	ea82 0000 	eor.w	r0, r2, r0
    c152:	ea83 0101 	eor.w	r1, r3, r1
    c156:	ea80 0202 	eor.w	r2, r0, r2
    c15a:	ea81 0303 	eor.w	r3, r1, r3
    c15e:	2d36      	cmp	r5, #54	; 0x36
    c160:	bf88      	it	hi
    c162:	bd30      	pophi	{r4, r5, pc}
    c164:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    c168:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c16c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    c170:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    c174:	d002      	beq.n	c17c <__adddf3+0x70>
    c176:	4240      	negs	r0, r0
    c178:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c17c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    c180:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c184:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    c188:	d002      	beq.n	c190 <__adddf3+0x84>
    c18a:	4252      	negs	r2, r2
    c18c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c190:	ea94 0f05 	teq	r4, r5
    c194:	f000 80a7 	beq.w	c2e6 <__adddf3+0x1da>
    c198:	f1a4 0401 	sub.w	r4, r4, #1
    c19c:	f1d5 0e20 	rsbs	lr, r5, #32
    c1a0:	db0d      	blt.n	c1be <__adddf3+0xb2>
    c1a2:	fa02 fc0e 	lsl.w	ip, r2, lr
    c1a6:	fa22 f205 	lsr.w	r2, r2, r5
    c1aa:	1880      	adds	r0, r0, r2
    c1ac:	f141 0100 	adc.w	r1, r1, #0
    c1b0:	fa03 f20e 	lsl.w	r2, r3, lr
    c1b4:	1880      	adds	r0, r0, r2
    c1b6:	fa43 f305 	asr.w	r3, r3, r5
    c1ba:	4159      	adcs	r1, r3
    c1bc:	e00e      	b.n	c1dc <__adddf3+0xd0>
    c1be:	f1a5 0520 	sub.w	r5, r5, #32
    c1c2:	f10e 0e20 	add.w	lr, lr, #32
    c1c6:	2a01      	cmp	r2, #1
    c1c8:	fa03 fc0e 	lsl.w	ip, r3, lr
    c1cc:	bf28      	it	cs
    c1ce:	f04c 0c02 	orrcs.w	ip, ip, #2
    c1d2:	fa43 f305 	asr.w	r3, r3, r5
    c1d6:	18c0      	adds	r0, r0, r3
    c1d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    c1dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c1e0:	d507      	bpl.n	c1f2 <__adddf3+0xe6>
    c1e2:	f04f 0e00 	mov.w	lr, #0
    c1e6:	f1dc 0c00 	rsbs	ip, ip, #0
    c1ea:	eb7e 0000 	sbcs.w	r0, lr, r0
    c1ee:	eb6e 0101 	sbc.w	r1, lr, r1
    c1f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    c1f6:	d31b      	bcc.n	c230 <__adddf3+0x124>
    c1f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    c1fc:	d30c      	bcc.n	c218 <__adddf3+0x10c>
    c1fe:	0849      	lsrs	r1, r1, #1
    c200:	ea5f 0030 	movs.w	r0, r0, rrx
    c204:	ea4f 0c3c 	mov.w	ip, ip, rrx
    c208:	f104 0401 	add.w	r4, r4, #1
    c20c:	ea4f 5244 	mov.w	r2, r4, lsl #21
    c210:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    c214:	f080 809a 	bcs.w	c34c <__adddf3+0x240>
    c218:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    c21c:	bf08      	it	eq
    c21e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c222:	f150 0000 	adcs.w	r0, r0, #0
    c226:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c22a:	ea41 0105 	orr.w	r1, r1, r5
    c22e:	bd30      	pop	{r4, r5, pc}
    c230:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    c234:	4140      	adcs	r0, r0
    c236:	eb41 0101 	adc.w	r1, r1, r1
    c23a:	3c01      	subs	r4, #1
    c23c:	bf28      	it	cs
    c23e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
    c242:	d2e9      	bcs.n	c218 <__adddf3+0x10c>
    c244:	f091 0f00 	teq	r1, #0
    c248:	bf04      	itt	eq
    c24a:	4601      	moveq	r1, r0
    c24c:	2000      	moveq	r0, #0
    c24e:	fab1 f381 	clz	r3, r1
    c252:	bf08      	it	eq
    c254:	3320      	addeq	r3, #32
    c256:	f1a3 030b 	sub.w	r3, r3, #11
    c25a:	f1b3 0220 	subs.w	r2, r3, #32
    c25e:	da0c      	bge.n	c27a <__adddf3+0x16e>
    c260:	320c      	adds	r2, #12
    c262:	dd08      	ble.n	c276 <__adddf3+0x16a>
    c264:	f102 0c14 	add.w	ip, r2, #20
    c268:	f1c2 020c 	rsb	r2, r2, #12
    c26c:	fa01 f00c 	lsl.w	r0, r1, ip
    c270:	fa21 f102 	lsr.w	r1, r1, r2
    c274:	e00c      	b.n	c290 <__adddf3+0x184>
    c276:	f102 0214 	add.w	r2, r2, #20
    c27a:	bfd8      	it	le
    c27c:	f1c2 0c20 	rsble	ip, r2, #32
    c280:	fa01 f102 	lsl.w	r1, r1, r2
    c284:	fa20 fc0c 	lsr.w	ip, r0, ip
    c288:	bfdc      	itt	le
    c28a:	ea41 010c 	orrle.w	r1, r1, ip
    c28e:	4090      	lslle	r0, r2
    c290:	1ae4      	subs	r4, r4, r3
    c292:	bfa2      	ittt	ge
    c294:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    c298:	4329      	orrge	r1, r5
    c29a:	bd30      	popge	{r4, r5, pc}
    c29c:	ea6f 0404 	mvn.w	r4, r4
    c2a0:	3c1f      	subs	r4, #31
    c2a2:	da1c      	bge.n	c2de <__adddf3+0x1d2>
    c2a4:	340c      	adds	r4, #12
    c2a6:	dc0e      	bgt.n	c2c6 <__adddf3+0x1ba>
    c2a8:	f104 0414 	add.w	r4, r4, #20
    c2ac:	f1c4 0220 	rsb	r2, r4, #32
    c2b0:	fa20 f004 	lsr.w	r0, r0, r4
    c2b4:	fa01 f302 	lsl.w	r3, r1, r2
    c2b8:	ea40 0003 	orr.w	r0, r0, r3
    c2bc:	fa21 f304 	lsr.w	r3, r1, r4
    c2c0:	ea45 0103 	orr.w	r1, r5, r3
    c2c4:	bd30      	pop	{r4, r5, pc}
    c2c6:	f1c4 040c 	rsb	r4, r4, #12
    c2ca:	f1c4 0220 	rsb	r2, r4, #32
    c2ce:	fa20 f002 	lsr.w	r0, r0, r2
    c2d2:	fa01 f304 	lsl.w	r3, r1, r4
    c2d6:	ea40 0003 	orr.w	r0, r0, r3
    c2da:	4629      	mov	r1, r5
    c2dc:	bd30      	pop	{r4, r5, pc}
    c2de:	fa21 f004 	lsr.w	r0, r1, r4
    c2e2:	4629      	mov	r1, r5
    c2e4:	bd30      	pop	{r4, r5, pc}
    c2e6:	f094 0f00 	teq	r4, #0
    c2ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    c2ee:	bf06      	itte	eq
    c2f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    c2f4:	3401      	addeq	r4, #1
    c2f6:	3d01      	subne	r5, #1
    c2f8:	e74e      	b.n	c198 <__adddf3+0x8c>
    c2fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c2fe:	bf18      	it	ne
    c300:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c304:	d029      	beq.n	c35a <__adddf3+0x24e>
    c306:	ea94 0f05 	teq	r4, r5
    c30a:	bf08      	it	eq
    c30c:	ea90 0f02 	teqeq	r0, r2
    c310:	d005      	beq.n	c31e <__adddf3+0x212>
    c312:	ea54 0c00 	orrs.w	ip, r4, r0
    c316:	bf04      	itt	eq
    c318:	4619      	moveq	r1, r3
    c31a:	4610      	moveq	r0, r2
    c31c:	bd30      	pop	{r4, r5, pc}
    c31e:	ea91 0f03 	teq	r1, r3
    c322:	bf1e      	ittt	ne
    c324:	2100      	movne	r1, #0
    c326:	2000      	movne	r0, #0
    c328:	bd30      	popne	{r4, r5, pc}
    c32a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    c32e:	d105      	bne.n	c33c <__adddf3+0x230>
    c330:	0040      	lsls	r0, r0, #1
    c332:	4149      	adcs	r1, r1
    c334:	bf28      	it	cs
    c336:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    c33a:	bd30      	pop	{r4, r5, pc}
    c33c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    c340:	bf3c      	itt	cc
    c342:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    c346:	bd30      	popcc	{r4, r5, pc}
    c348:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c34c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    c350:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c354:	f04f 0000 	mov.w	r0, #0
    c358:	bd30      	pop	{r4, r5, pc}
    c35a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c35e:	bf1a      	itte	ne
    c360:	4619      	movne	r1, r3
    c362:	4610      	movne	r0, r2
    c364:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    c368:	bf1c      	itt	ne
    c36a:	460b      	movne	r3, r1
    c36c:	4602      	movne	r2, r0
    c36e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c372:	bf06      	itte	eq
    c374:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    c378:	ea91 0f03 	teqeq	r1, r3
    c37c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    c380:	bd30      	pop	{r4, r5, pc}
    c382:	bf00      	nop

0000c384 <__aeabi_ui2d>:
    c384:	f090 0f00 	teq	r0, #0
    c388:	bf04      	itt	eq
    c38a:	2100      	moveq	r1, #0
    c38c:	4770      	bxeq	lr
    c38e:	b530      	push	{r4, r5, lr}
    c390:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c394:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c398:	f04f 0500 	mov.w	r5, #0
    c39c:	f04f 0100 	mov.w	r1, #0
    c3a0:	e750      	b.n	c244 <__adddf3+0x138>
    c3a2:	bf00      	nop

0000c3a4 <__aeabi_i2d>:
    c3a4:	f090 0f00 	teq	r0, #0
    c3a8:	bf04      	itt	eq
    c3aa:	2100      	moveq	r1, #0
    c3ac:	4770      	bxeq	lr
    c3ae:	b530      	push	{r4, r5, lr}
    c3b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c3b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c3b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    c3bc:	bf48      	it	mi
    c3be:	4240      	negmi	r0, r0
    c3c0:	f04f 0100 	mov.w	r1, #0
    c3c4:	e73e      	b.n	c244 <__adddf3+0x138>
    c3c6:	bf00      	nop

0000c3c8 <__aeabi_f2d>:
    c3c8:	0042      	lsls	r2, r0, #1
    c3ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
    c3ce:	ea4f 0131 	mov.w	r1, r1, rrx
    c3d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
    c3d6:	bf1f      	itttt	ne
    c3d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    c3dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c3e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    c3e4:	4770      	bxne	lr
    c3e6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    c3ea:	bf08      	it	eq
    c3ec:	4770      	bxeq	lr
    c3ee:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    c3f2:	bf04      	itt	eq
    c3f4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    c3f8:	4770      	bxeq	lr
    c3fa:	b530      	push	{r4, r5, lr}
    c3fc:	f44f 7460 	mov.w	r4, #896	; 0x380
    c400:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c404:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c408:	e71c      	b.n	c244 <__adddf3+0x138>
    c40a:	bf00      	nop

0000c40c <__aeabi_ul2d>:
    c40c:	ea50 0201 	orrs.w	r2, r0, r1
    c410:	bf08      	it	eq
    c412:	4770      	bxeq	lr
    c414:	b530      	push	{r4, r5, lr}
    c416:	f04f 0500 	mov.w	r5, #0
    c41a:	e00a      	b.n	c432 <__aeabi_l2d+0x16>

0000c41c <__aeabi_l2d>:
    c41c:	ea50 0201 	orrs.w	r2, r0, r1
    c420:	bf08      	it	eq
    c422:	4770      	bxeq	lr
    c424:	b530      	push	{r4, r5, lr}
    c426:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    c42a:	d502      	bpl.n	c432 <__aeabi_l2d+0x16>
    c42c:	4240      	negs	r0, r0
    c42e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c432:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c436:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c43a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    c43e:	f43f aed8 	beq.w	c1f2 <__adddf3+0xe6>
    c442:	f04f 0203 	mov.w	r2, #3
    c446:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c44a:	bf18      	it	ne
    c44c:	3203      	addne	r2, #3
    c44e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c452:	bf18      	it	ne
    c454:	3203      	addne	r2, #3
    c456:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    c45a:	f1c2 0320 	rsb	r3, r2, #32
    c45e:	fa00 fc03 	lsl.w	ip, r0, r3
    c462:	fa20 f002 	lsr.w	r0, r0, r2
    c466:	fa01 fe03 	lsl.w	lr, r1, r3
    c46a:	ea40 000e 	orr.w	r0, r0, lr
    c46e:	fa21 f102 	lsr.w	r1, r1, r2
    c472:	4414      	add	r4, r2
    c474:	e6bd      	b.n	c1f2 <__adddf3+0xe6>
    c476:	bf00      	nop

0000c478 <__aeabi_dmul>:
    c478:	b570      	push	{r4, r5, r6, lr}
    c47a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c47e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c482:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c486:	bf1d      	ittte	ne
    c488:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c48c:	ea94 0f0c 	teqne	r4, ip
    c490:	ea95 0f0c 	teqne	r5, ip
    c494:	f000 f8de 	bleq	c654 <__aeabi_dmul+0x1dc>
    c498:	442c      	add	r4, r5
    c49a:	ea81 0603 	eor.w	r6, r1, r3
    c49e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    c4a2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    c4a6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    c4aa:	bf18      	it	ne
    c4ac:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    c4b0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c4b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    c4b8:	d038      	beq.n	c52c <__aeabi_dmul+0xb4>
    c4ba:	fba0 ce02 	umull	ip, lr, r0, r2
    c4be:	f04f 0500 	mov.w	r5, #0
    c4c2:	fbe1 e502 	umlal	lr, r5, r1, r2
    c4c6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    c4ca:	fbe0 e503 	umlal	lr, r5, r0, r3
    c4ce:	f04f 0600 	mov.w	r6, #0
    c4d2:	fbe1 5603 	umlal	r5, r6, r1, r3
    c4d6:	f09c 0f00 	teq	ip, #0
    c4da:	bf18      	it	ne
    c4dc:	f04e 0e01 	orrne.w	lr, lr, #1
    c4e0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    c4e4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    c4e8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    c4ec:	d204      	bcs.n	c4f8 <__aeabi_dmul+0x80>
    c4ee:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    c4f2:	416d      	adcs	r5, r5
    c4f4:	eb46 0606 	adc.w	r6, r6, r6
    c4f8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    c4fc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    c500:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    c504:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    c508:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    c50c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c510:	bf88      	it	hi
    c512:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c516:	d81e      	bhi.n	c556 <__aeabi_dmul+0xde>
    c518:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    c51c:	bf08      	it	eq
    c51e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    c522:	f150 0000 	adcs.w	r0, r0, #0
    c526:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c52a:	bd70      	pop	{r4, r5, r6, pc}
    c52c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    c530:	ea46 0101 	orr.w	r1, r6, r1
    c534:	ea40 0002 	orr.w	r0, r0, r2
    c538:	ea81 0103 	eor.w	r1, r1, r3
    c53c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    c540:	bfc2      	ittt	gt
    c542:	ebd4 050c 	rsbsgt	r5, r4, ip
    c546:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c54a:	bd70      	popgt	{r4, r5, r6, pc}
    c54c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c550:	f04f 0e00 	mov.w	lr, #0
    c554:	3c01      	subs	r4, #1
    c556:	f300 80ab 	bgt.w	c6b0 <__aeabi_dmul+0x238>
    c55a:	f114 0f36 	cmn.w	r4, #54	; 0x36
    c55e:	bfde      	ittt	le
    c560:	2000      	movle	r0, #0
    c562:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    c566:	bd70      	pople	{r4, r5, r6, pc}
    c568:	f1c4 0400 	rsb	r4, r4, #0
    c56c:	3c20      	subs	r4, #32
    c56e:	da35      	bge.n	c5dc <__aeabi_dmul+0x164>
    c570:	340c      	adds	r4, #12
    c572:	dc1b      	bgt.n	c5ac <__aeabi_dmul+0x134>
    c574:	f104 0414 	add.w	r4, r4, #20
    c578:	f1c4 0520 	rsb	r5, r4, #32
    c57c:	fa00 f305 	lsl.w	r3, r0, r5
    c580:	fa20 f004 	lsr.w	r0, r0, r4
    c584:	fa01 f205 	lsl.w	r2, r1, r5
    c588:	ea40 0002 	orr.w	r0, r0, r2
    c58c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    c590:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c594:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c598:	fa21 f604 	lsr.w	r6, r1, r4
    c59c:	eb42 0106 	adc.w	r1, r2, r6
    c5a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c5a4:	bf08      	it	eq
    c5a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c5aa:	bd70      	pop	{r4, r5, r6, pc}
    c5ac:	f1c4 040c 	rsb	r4, r4, #12
    c5b0:	f1c4 0520 	rsb	r5, r4, #32
    c5b4:	fa00 f304 	lsl.w	r3, r0, r4
    c5b8:	fa20 f005 	lsr.w	r0, r0, r5
    c5bc:	fa01 f204 	lsl.w	r2, r1, r4
    c5c0:	ea40 0002 	orr.w	r0, r0, r2
    c5c4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c5c8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c5cc:	f141 0100 	adc.w	r1, r1, #0
    c5d0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c5d4:	bf08      	it	eq
    c5d6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c5da:	bd70      	pop	{r4, r5, r6, pc}
    c5dc:	f1c4 0520 	rsb	r5, r4, #32
    c5e0:	fa00 f205 	lsl.w	r2, r0, r5
    c5e4:	ea4e 0e02 	orr.w	lr, lr, r2
    c5e8:	fa20 f304 	lsr.w	r3, r0, r4
    c5ec:	fa01 f205 	lsl.w	r2, r1, r5
    c5f0:	ea43 0302 	orr.w	r3, r3, r2
    c5f4:	fa21 f004 	lsr.w	r0, r1, r4
    c5f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c5fc:	fa21 f204 	lsr.w	r2, r1, r4
    c600:	ea20 0002 	bic.w	r0, r0, r2
    c604:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    c608:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c60c:	bf08      	it	eq
    c60e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c612:	bd70      	pop	{r4, r5, r6, pc}
    c614:	f094 0f00 	teq	r4, #0
    c618:	d10f      	bne.n	c63a <__aeabi_dmul+0x1c2>
    c61a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    c61e:	0040      	lsls	r0, r0, #1
    c620:	eb41 0101 	adc.w	r1, r1, r1
    c624:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c628:	bf08      	it	eq
    c62a:	3c01      	subeq	r4, #1
    c62c:	d0f7      	beq.n	c61e <__aeabi_dmul+0x1a6>
    c62e:	ea41 0106 	orr.w	r1, r1, r6
    c632:	f095 0f00 	teq	r5, #0
    c636:	bf18      	it	ne
    c638:	4770      	bxne	lr
    c63a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    c63e:	0052      	lsls	r2, r2, #1
    c640:	eb43 0303 	adc.w	r3, r3, r3
    c644:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    c648:	bf08      	it	eq
    c64a:	3d01      	subeq	r5, #1
    c64c:	d0f7      	beq.n	c63e <__aeabi_dmul+0x1c6>
    c64e:	ea43 0306 	orr.w	r3, r3, r6
    c652:	4770      	bx	lr
    c654:	ea94 0f0c 	teq	r4, ip
    c658:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c65c:	bf18      	it	ne
    c65e:	ea95 0f0c 	teqne	r5, ip
    c662:	d00c      	beq.n	c67e <__aeabi_dmul+0x206>
    c664:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c668:	bf18      	it	ne
    c66a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c66e:	d1d1      	bne.n	c614 <__aeabi_dmul+0x19c>
    c670:	ea81 0103 	eor.w	r1, r1, r3
    c674:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c678:	f04f 0000 	mov.w	r0, #0
    c67c:	bd70      	pop	{r4, r5, r6, pc}
    c67e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c682:	bf06      	itte	eq
    c684:	4610      	moveq	r0, r2
    c686:	4619      	moveq	r1, r3
    c688:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c68c:	d019      	beq.n	c6c2 <__aeabi_dmul+0x24a>
    c68e:	ea94 0f0c 	teq	r4, ip
    c692:	d102      	bne.n	c69a <__aeabi_dmul+0x222>
    c694:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    c698:	d113      	bne.n	c6c2 <__aeabi_dmul+0x24a>
    c69a:	ea95 0f0c 	teq	r5, ip
    c69e:	d105      	bne.n	c6ac <__aeabi_dmul+0x234>
    c6a0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    c6a4:	bf1c      	itt	ne
    c6a6:	4610      	movne	r0, r2
    c6a8:	4619      	movne	r1, r3
    c6aa:	d10a      	bne.n	c6c2 <__aeabi_dmul+0x24a>
    c6ac:	ea81 0103 	eor.w	r1, r1, r3
    c6b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c6b4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c6b8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c6bc:	f04f 0000 	mov.w	r0, #0
    c6c0:	bd70      	pop	{r4, r5, r6, pc}
    c6c2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c6c6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    c6ca:	bd70      	pop	{r4, r5, r6, pc}

0000c6cc <__aeabi_ddiv>:
    c6cc:	b570      	push	{r4, r5, r6, lr}
    c6ce:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c6d2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c6d6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c6da:	bf1d      	ittte	ne
    c6dc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c6e0:	ea94 0f0c 	teqne	r4, ip
    c6e4:	ea95 0f0c 	teqne	r5, ip
    c6e8:	f000 f8a7 	bleq	c83a <__aeabi_ddiv+0x16e>
    c6ec:	eba4 0405 	sub.w	r4, r4, r5
    c6f0:	ea81 0e03 	eor.w	lr, r1, r3
    c6f4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c6f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c6fc:	f000 8088 	beq.w	c810 <__aeabi_ddiv+0x144>
    c700:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c704:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    c708:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    c70c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    c710:	ea4f 2202 	mov.w	r2, r2, lsl #8
    c714:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    c718:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    c71c:	ea4f 2600 	mov.w	r6, r0, lsl #8
    c720:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    c724:	429d      	cmp	r5, r3
    c726:	bf08      	it	eq
    c728:	4296      	cmpeq	r6, r2
    c72a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    c72e:	f504 7440 	add.w	r4, r4, #768	; 0x300
    c732:	d202      	bcs.n	c73a <__aeabi_ddiv+0x6e>
    c734:	085b      	lsrs	r3, r3, #1
    c736:	ea4f 0232 	mov.w	r2, r2, rrx
    c73a:	1ab6      	subs	r6, r6, r2
    c73c:	eb65 0503 	sbc.w	r5, r5, r3
    c740:	085b      	lsrs	r3, r3, #1
    c742:	ea4f 0232 	mov.w	r2, r2, rrx
    c746:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    c74a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    c74e:	ebb6 0e02 	subs.w	lr, r6, r2
    c752:	eb75 0e03 	sbcs.w	lr, r5, r3
    c756:	bf22      	ittt	cs
    c758:	1ab6      	subcs	r6, r6, r2
    c75a:	4675      	movcs	r5, lr
    c75c:	ea40 000c 	orrcs.w	r0, r0, ip
    c760:	085b      	lsrs	r3, r3, #1
    c762:	ea4f 0232 	mov.w	r2, r2, rrx
    c766:	ebb6 0e02 	subs.w	lr, r6, r2
    c76a:	eb75 0e03 	sbcs.w	lr, r5, r3
    c76e:	bf22      	ittt	cs
    c770:	1ab6      	subcs	r6, r6, r2
    c772:	4675      	movcs	r5, lr
    c774:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    c778:	085b      	lsrs	r3, r3, #1
    c77a:	ea4f 0232 	mov.w	r2, r2, rrx
    c77e:	ebb6 0e02 	subs.w	lr, r6, r2
    c782:	eb75 0e03 	sbcs.w	lr, r5, r3
    c786:	bf22      	ittt	cs
    c788:	1ab6      	subcs	r6, r6, r2
    c78a:	4675      	movcs	r5, lr
    c78c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    c790:	085b      	lsrs	r3, r3, #1
    c792:	ea4f 0232 	mov.w	r2, r2, rrx
    c796:	ebb6 0e02 	subs.w	lr, r6, r2
    c79a:	eb75 0e03 	sbcs.w	lr, r5, r3
    c79e:	bf22      	ittt	cs
    c7a0:	1ab6      	subcs	r6, r6, r2
    c7a2:	4675      	movcs	r5, lr
    c7a4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    c7a8:	ea55 0e06 	orrs.w	lr, r5, r6
    c7ac:	d018      	beq.n	c7e0 <__aeabi_ddiv+0x114>
    c7ae:	ea4f 1505 	mov.w	r5, r5, lsl #4
    c7b2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    c7b6:	ea4f 1606 	mov.w	r6, r6, lsl #4
    c7ba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    c7be:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    c7c2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    c7c6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    c7ca:	d1c0      	bne.n	c74e <__aeabi_ddiv+0x82>
    c7cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c7d0:	d10b      	bne.n	c7ea <__aeabi_ddiv+0x11e>
    c7d2:	ea41 0100 	orr.w	r1, r1, r0
    c7d6:	f04f 0000 	mov.w	r0, #0
    c7da:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    c7de:	e7b6      	b.n	c74e <__aeabi_ddiv+0x82>
    c7e0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c7e4:	bf04      	itt	eq
    c7e6:	4301      	orreq	r1, r0
    c7e8:	2000      	moveq	r0, #0
    c7ea:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c7ee:	bf88      	it	hi
    c7f0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c7f4:	f63f aeaf 	bhi.w	c556 <__aeabi_dmul+0xde>
    c7f8:	ebb5 0c03 	subs.w	ip, r5, r3
    c7fc:	bf04      	itt	eq
    c7fe:	ebb6 0c02 	subseq.w	ip, r6, r2
    c802:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c806:	f150 0000 	adcs.w	r0, r0, #0
    c80a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c80e:	bd70      	pop	{r4, r5, r6, pc}
    c810:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    c814:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    c818:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    c81c:	bfc2      	ittt	gt
    c81e:	ebd4 050c 	rsbsgt	r5, r4, ip
    c822:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c826:	bd70      	popgt	{r4, r5, r6, pc}
    c828:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c82c:	f04f 0e00 	mov.w	lr, #0
    c830:	3c01      	subs	r4, #1
    c832:	e690      	b.n	c556 <__aeabi_dmul+0xde>
    c834:	ea45 0e06 	orr.w	lr, r5, r6
    c838:	e68d      	b.n	c556 <__aeabi_dmul+0xde>
    c83a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c83e:	ea94 0f0c 	teq	r4, ip
    c842:	bf08      	it	eq
    c844:	ea95 0f0c 	teqeq	r5, ip
    c848:	f43f af3b 	beq.w	c6c2 <__aeabi_dmul+0x24a>
    c84c:	ea94 0f0c 	teq	r4, ip
    c850:	d10a      	bne.n	c868 <__aeabi_ddiv+0x19c>
    c852:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c856:	f47f af34 	bne.w	c6c2 <__aeabi_dmul+0x24a>
    c85a:	ea95 0f0c 	teq	r5, ip
    c85e:	f47f af25 	bne.w	c6ac <__aeabi_dmul+0x234>
    c862:	4610      	mov	r0, r2
    c864:	4619      	mov	r1, r3
    c866:	e72c      	b.n	c6c2 <__aeabi_dmul+0x24a>
    c868:	ea95 0f0c 	teq	r5, ip
    c86c:	d106      	bne.n	c87c <__aeabi_ddiv+0x1b0>
    c86e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c872:	f43f aefd 	beq.w	c670 <__aeabi_dmul+0x1f8>
    c876:	4610      	mov	r0, r2
    c878:	4619      	mov	r1, r3
    c87a:	e722      	b.n	c6c2 <__aeabi_dmul+0x24a>
    c87c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c880:	bf18      	it	ne
    c882:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c886:	f47f aec5 	bne.w	c614 <__aeabi_dmul+0x19c>
    c88a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    c88e:	f47f af0d 	bne.w	c6ac <__aeabi_dmul+0x234>
    c892:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    c896:	f47f aeeb 	bne.w	c670 <__aeabi_dmul+0x1f8>
    c89a:	e712      	b.n	c6c2 <__aeabi_dmul+0x24a>

0000c89c <__gedf2>:
    c89c:	f04f 3cff 	mov.w	ip, #4294967295
    c8a0:	e006      	b.n	c8b0 <__cmpdf2+0x4>
    c8a2:	bf00      	nop

0000c8a4 <__ledf2>:
    c8a4:	f04f 0c01 	mov.w	ip, #1
    c8a8:	e002      	b.n	c8b0 <__cmpdf2+0x4>
    c8aa:	bf00      	nop

0000c8ac <__cmpdf2>:
    c8ac:	f04f 0c01 	mov.w	ip, #1
    c8b0:	f84d cd04 	str.w	ip, [sp, #-4]!
    c8b4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c8b8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c8bc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    c8c0:	bf18      	it	ne
    c8c2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    c8c6:	d01b      	beq.n	c900 <__cmpdf2+0x54>
    c8c8:	b001      	add	sp, #4
    c8ca:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    c8ce:	bf0c      	ite	eq
    c8d0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    c8d4:	ea91 0f03 	teqne	r1, r3
    c8d8:	bf02      	ittt	eq
    c8da:	ea90 0f02 	teqeq	r0, r2
    c8de:	2000      	moveq	r0, #0
    c8e0:	4770      	bxeq	lr
    c8e2:	f110 0f00 	cmn.w	r0, #0
    c8e6:	ea91 0f03 	teq	r1, r3
    c8ea:	bf58      	it	pl
    c8ec:	4299      	cmppl	r1, r3
    c8ee:	bf08      	it	eq
    c8f0:	4290      	cmpeq	r0, r2
    c8f2:	bf2c      	ite	cs
    c8f4:	17d8      	asrcs	r0, r3, #31
    c8f6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    c8fa:	f040 0001 	orr.w	r0, r0, #1
    c8fe:	4770      	bx	lr
    c900:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c904:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c908:	d102      	bne.n	c910 <__cmpdf2+0x64>
    c90a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    c90e:	d107      	bne.n	c920 <__cmpdf2+0x74>
    c910:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    c914:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c918:	d1d6      	bne.n	c8c8 <__cmpdf2+0x1c>
    c91a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    c91e:	d0d3      	beq.n	c8c8 <__cmpdf2+0x1c>
    c920:	f85d 0b04 	ldr.w	r0, [sp], #4
    c924:	4770      	bx	lr
    c926:	bf00      	nop

0000c928 <__aeabi_cdrcmple>:
    c928:	4684      	mov	ip, r0
    c92a:	4610      	mov	r0, r2
    c92c:	4662      	mov	r2, ip
    c92e:	468c      	mov	ip, r1
    c930:	4619      	mov	r1, r3
    c932:	4663      	mov	r3, ip
    c934:	e000      	b.n	c938 <__aeabi_cdcmpeq>
    c936:	bf00      	nop

0000c938 <__aeabi_cdcmpeq>:
    c938:	b501      	push	{r0, lr}
    c93a:	f7ff ffb7 	bl	c8ac <__cmpdf2>
    c93e:	2800      	cmp	r0, #0
    c940:	bf48      	it	mi
    c942:	f110 0f00 	cmnmi.w	r0, #0
    c946:	bd01      	pop	{r0, pc}

0000c948 <__aeabi_dcmpeq>:
    c948:	f84d ed08 	str.w	lr, [sp, #-8]!
    c94c:	f7ff fff4 	bl	c938 <__aeabi_cdcmpeq>
    c950:	bf0c      	ite	eq
    c952:	2001      	moveq	r0, #1
    c954:	2000      	movne	r0, #0
    c956:	f85d fb08 	ldr.w	pc, [sp], #8
    c95a:	bf00      	nop

0000c95c <__aeabi_dcmplt>:
    c95c:	f84d ed08 	str.w	lr, [sp, #-8]!
    c960:	f7ff ffea 	bl	c938 <__aeabi_cdcmpeq>
    c964:	bf34      	ite	cc
    c966:	2001      	movcc	r0, #1
    c968:	2000      	movcs	r0, #0
    c96a:	f85d fb08 	ldr.w	pc, [sp], #8
    c96e:	bf00      	nop

0000c970 <__aeabi_dcmple>:
    c970:	f84d ed08 	str.w	lr, [sp, #-8]!
    c974:	f7ff ffe0 	bl	c938 <__aeabi_cdcmpeq>
    c978:	bf94      	ite	ls
    c97a:	2001      	movls	r0, #1
    c97c:	2000      	movhi	r0, #0
    c97e:	f85d fb08 	ldr.w	pc, [sp], #8
    c982:	bf00      	nop

0000c984 <__aeabi_dcmpge>:
    c984:	f84d ed08 	str.w	lr, [sp, #-8]!
    c988:	f7ff ffce 	bl	c928 <__aeabi_cdrcmple>
    c98c:	bf94      	ite	ls
    c98e:	2001      	movls	r0, #1
    c990:	2000      	movhi	r0, #0
    c992:	f85d fb08 	ldr.w	pc, [sp], #8
    c996:	bf00      	nop

0000c998 <__aeabi_dcmpgt>:
    c998:	f84d ed08 	str.w	lr, [sp, #-8]!
    c99c:	f7ff ffc4 	bl	c928 <__aeabi_cdrcmple>
    c9a0:	bf34      	ite	cc
    c9a2:	2001      	movcc	r0, #1
    c9a4:	2000      	movcs	r0, #0
    c9a6:	f85d fb08 	ldr.w	pc, [sp], #8
    c9aa:	bf00      	nop

0000c9ac <__aeabi_d2uiz>:
    c9ac:	004a      	lsls	r2, r1, #1
    c9ae:	d211      	bcs.n	c9d4 <__aeabi_d2uiz+0x28>
    c9b0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    c9b4:	d211      	bcs.n	c9da <__aeabi_d2uiz+0x2e>
    c9b6:	d50d      	bpl.n	c9d4 <__aeabi_d2uiz+0x28>
    c9b8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    c9bc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    c9c0:	d40e      	bmi.n	c9e0 <__aeabi_d2uiz+0x34>
    c9c2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c9c6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    c9ca:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    c9ce:	fa23 f002 	lsr.w	r0, r3, r2
    c9d2:	4770      	bx	lr
    c9d4:	f04f 0000 	mov.w	r0, #0
    c9d8:	4770      	bx	lr
    c9da:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    c9de:	d102      	bne.n	c9e6 <__aeabi_d2uiz+0x3a>
    c9e0:	f04f 30ff 	mov.w	r0, #4294967295
    c9e4:	4770      	bx	lr
    c9e6:	f04f 0000 	mov.w	r0, #0
    c9ea:	4770      	bx	lr

0000c9ec <__aeabi_d2f>:
    c9ec:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c9f0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c9f4:	bf24      	itt	cs
    c9f6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c9fa:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c9fe:	d90d      	bls.n	ca1c <__aeabi_d2f+0x30>
    ca00:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    ca04:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    ca08:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    ca0c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    ca10:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    ca14:	bf08      	it	eq
    ca16:	f020 0001 	biceq.w	r0, r0, #1
    ca1a:	4770      	bx	lr
    ca1c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    ca20:	d121      	bne.n	ca66 <__aeabi_d2f+0x7a>
    ca22:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    ca26:	bfbc      	itt	lt
    ca28:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    ca2c:	4770      	bxlt	lr
    ca2e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    ca32:	ea4f 5252 	mov.w	r2, r2, lsr #21
    ca36:	f1c2 0218 	rsb	r2, r2, #24
    ca3a:	f1c2 0c20 	rsb	ip, r2, #32
    ca3e:	fa10 f30c 	lsls.w	r3, r0, ip
    ca42:	fa20 f002 	lsr.w	r0, r0, r2
    ca46:	bf18      	it	ne
    ca48:	f040 0001 	orrne.w	r0, r0, #1
    ca4c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    ca50:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    ca54:	fa03 fc0c 	lsl.w	ip, r3, ip
    ca58:	ea40 000c 	orr.w	r0, r0, ip
    ca5c:	fa23 f302 	lsr.w	r3, r3, r2
    ca60:	ea4f 0343 	mov.w	r3, r3, lsl #1
    ca64:	e7cc      	b.n	ca00 <__aeabi_d2f+0x14>
    ca66:	ea7f 5362 	mvns.w	r3, r2, asr #21
    ca6a:	d107      	bne.n	ca7c <__aeabi_d2f+0x90>
    ca6c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    ca70:	bf1e      	ittt	ne
    ca72:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    ca76:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    ca7a:	4770      	bxne	lr
    ca7c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    ca80:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    ca84:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    ca88:	4770      	bx	lr
    ca8a:	bf00      	nop

0000ca8c <SysTick_Handler>:
{
    //
    // Add enough cycles to account for one full cycle of systick.
    //
#ifdef TIME_64
    g_ui32SysTickWrappedTime++;
    ca8c:	4a02      	ldr	r2, [pc, #8]	; (ca98 <SysTick_Handler+0xc>)
    ca8e:	6813      	ldr	r3, [r2, #0]
    ca90:	3301      	adds	r3, #1
    ca92:	6013      	str	r3, [r2, #0]
#else
    g_ui32SysTickWrappedTime += 0x01000000;
#endif
}
    ca94:	4770      	bx	lr
    ca96:	bf00      	nop
    ca98:	10001040 	.word	0x10001040

0000ca9c <cmp_complex>:
/* Function: cmp_complex
    Compare the data item in a list cell.

    Can be used by mergesort.
*/
ee_s32 cmp_complex(list_data *a, list_data *b, core_results *res) {
    ca9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ee_s16 data=*pdata;
    caa0:	f9b0 5000 	ldrsh.w	r5, [r0]
ee_s32 cmp_complex(list_data *a, list_data *b, core_results *res) {
    caa4:	4614      	mov	r4, r2
    if (optype) /* if cached, use cache */
    caa6:	062a      	lsls	r2, r5, #24
ee_s32 cmp_complex(list_data *a, list_data *b, core_results *res) {
    caa8:	b082      	sub	sp, #8
    caaa:	460e      	mov	r6, r1
    if (optype) /* if cached, use cache */
    caac:	d52e      	bpl.n	cb0c <cmp_complex+0x70>
        return (data & 0x007f);
    caae:	f005 077f 	and.w	r7, r5, #127	; 0x7f
    ee_s16 data=*pdata;
    cab2:	f9b6 5000 	ldrsh.w	r5, [r6]
    if (optype) /* if cached, use cache */
    cab6:	062b      	lsls	r3, r5, #24
    cab8:	d505      	bpl.n	cac6 <cmp_complex+0x2a>
        return (data & 0x007f);
    caba:	f005 007f 	and.w	r0, r5, #127	; 0x7f
    ee_s16 val1=calc_func(&(a->data16),res);
    ee_s16 val2=calc_func(&(b->data16),res);
    return val1 - val2;
}
    cabe:	1a38      	subs	r0, r7, r0
    cac0:	b002      	add	sp, #8
    cac2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
    cac6:	f3c5 01c3 	ubfx	r1, r5, #3, #4
        switch (flag) {
    caca:	f015 0307 	ands.w	r3, r5, #7
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
    cace:	ea41 1101 	orr.w	r1, r1, r1, lsl #4
        switch (flag) {
    cad2:	d038      	beq.n	cb46 <cmp_complex+0xaa>
    cad4:	2b01      	cmp	r3, #1
    cad6:	d133      	bne.n	cb40 <cmp_complex+0xa4>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cad8:	8f22      	ldrh	r2, [r4, #56]	; 0x38
    cada:	f104 0028 	add.w	r0, r4, #40	; 0x28
    cade:	f001 f931 	bl	dd44 <core_bench_matrix>
                if (res->crcmatrix==0)
    cae2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cae4:	fa0f f880 	sxth.w	r8, r0
                if (res->crcmatrix==0)
    cae8:	b903      	cbnz	r3, caec <cmp_complex+0x50>
                    res->crcmatrix=retval;
    caea:	87a0      	strh	r0, [r4, #60]	; 0x3c
        res->crc=crcu16(retval,res->crc);
    caec:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    caee:	f001 fd65 	bl	e5bc <crcu16>
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    caf2:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
        res->crc=crcu16(retval,res->crc);
    caf6:	8720      	strh	r0, [r4, #56]	; 0x38
        retval &= 0x007f;
    caf8:	f008 007f 	and.w	r0, r8, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    cafc:	4305      	orrs	r5, r0
    cafe:	f045 0580 	orr.w	r5, r5, #128	; 0x80
}
    cb02:	1a38      	subs	r0, r7, r0
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    cb04:	8035      	strh	r5, [r6, #0]
}
    cb06:	b002      	add	sp, #8
    cb08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ee_s16 dtype=((data>>3) & 0xf); /* bits 3-6 is specific data for the operation */
    cb0c:	f3c5 01c3 	ubfx	r1, r5, #3, #4
        switch (flag) {
    cb10:	f015 0307 	ands.w	r3, r5, #7
    cb14:	4680      	mov	r8, r0
        dtype |= dtype << 4; /* replicate the lower 4 bits to get an 8b value */
    cb16:	ea41 1101 	orr.w	r1, r1, r1, lsl #4
        switch (flag) {
    cb1a:	d034      	beq.n	cb86 <cmp_complex+0xea>
    cb1c:	2b01      	cmp	r3, #1
    cb1e:	d027      	beq.n	cb70 <cmp_complex+0xd4>
        res->crc=crcu16(retval,res->crc);
    cb20:	b2a8      	uxth	r0, r5
    cb22:	462f      	mov	r7, r5
    cb24:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    cb26:	f001 fd49 	bl	e5bc <crcu16>
        retval &= 0x007f;
    cb2a:	f007 077f 	and.w	r7, r7, #127	; 0x7f
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    cb2e:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
    cb32:	433d      	orrs	r5, r7
    cb34:	f045 0580 	orr.w	r5, r5, #128	; 0x80
        res->crc=crcu16(retval,res->crc);
    cb38:	8720      	strh	r0, [r4, #56]	; 0x38
        *pdata = (data & 0xff00) | 0x0080 | retval; /* cache the result */
    cb3a:	f8a8 5000 	strh.w	r5, [r8]
        return retval;
    cb3e:	e7b8      	b.n	cab2 <cmp_complex+0x16>
        res->crc=crcu16(retval,res->crc);
    cb40:	b2a8      	uxth	r0, r5
    cb42:	46a8      	mov	r8, r5
    cb44:	e7d2      	b.n	caec <cmp_complex+0x50>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cb46:	2922      	cmp	r1, #34	; 0x22
    cb48:	bfb8      	it	lt
    cb4a:	2122      	movlt	r1, #34	; 0x22
    cb4c:	9100      	str	r1, [sp, #0]
    cb4e:	8f22      	ldrh	r2, [r4, #56]	; 0x38
    cb50:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
    cb54:	9201      	str	r2, [sp, #4]
    cb56:	e9d4 1005 	ldrd	r1, r0, [r4, #20]
    cb5a:	f9b4 2000 	ldrsh.w	r2, [r4]
    cb5e:	f001 fc8d 	bl	e47c <core_bench_state>
                if (res->crcstate==0)
    cb62:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cb64:	fa0f f880 	sxth.w	r8, r0
                if (res->crcstate==0)
    cb68:	2b00      	cmp	r3, #0
    cb6a:	d1bf      	bne.n	caec <cmp_complex+0x50>
                    res->crcstate=retval;
    cb6c:	87e0      	strh	r0, [r4, #62]	; 0x3e
    cb6e:	e7bd      	b.n	caec <cmp_complex+0x50>
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cb70:	8f22      	ldrh	r2, [r4, #56]	; 0x38
    cb72:	f104 0028 	add.w	r0, r4, #40	; 0x28
    cb76:	f001 f8e5 	bl	dd44 <core_bench_matrix>
                if (res->crcmatrix==0)
    cb7a:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
                retval=core_bench_matrix(&(res->mat),dtype,res->crc);
    cb7c:	b207      	sxth	r7, r0
                if (res->crcmatrix==0)
    cb7e:	2b00      	cmp	r3, #0
    cb80:	d1d0      	bne.n	cb24 <cmp_complex+0x88>
                    res->crcmatrix=retval;
    cb82:	87a0      	strh	r0, [r4, #60]	; 0x3c
    cb84:	e7ce      	b.n	cb24 <cmp_complex+0x88>
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cb86:	2922      	cmp	r1, #34	; 0x22
    cb88:	bfb8      	it	lt
    cb8a:	2122      	movlt	r1, #34	; 0x22
    cb8c:	9100      	str	r1, [sp, #0]
    cb8e:	8f22      	ldrh	r2, [r4, #56]	; 0x38
    cb90:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
    cb94:	9201      	str	r2, [sp, #4]
    cb96:	e9d4 1005 	ldrd	r1, r0, [r4, #20]
    cb9a:	f9b4 2000 	ldrsh.w	r2, [r4]
    cb9e:	f001 fc6d 	bl	e47c <core_bench_state>
                if (res->crcstate==0)
    cba2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
                retval=core_bench_state(res->size,res->memblock[3],res->seed1,res->seed2,dtype,res->crc);
    cba4:	b207      	sxth	r7, r0
                if (res->crcstate==0)
    cba6:	2b00      	cmp	r3, #0
    cba8:	d1bc      	bne.n	cb24 <cmp_complex+0x88>
                    res->crcstate=retval;
    cbaa:	87e0      	strh	r0, [r4, #62]	; 0x3e
    cbac:	e7ba      	b.n	cb24 <cmp_complex+0x88>
    cbae:	bf00      	nop

0000cbb0 <core_bench_list>:
    - List sort
    - Operate on data from list (crc)
    - Single remove/reinsert
    * At the end of this function, the list is back to original state
*/
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    cbb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u16 retval=0;
    ee_u16 found=0,missed=0;
    list_head *list=res->list;
    ee_s16 find_num=res->seed3;
    cbb4:	f9b0 e004 	ldrsh.w	lr, [r0, #4]
    list_head *list=res->list;
    cbb8:	6a44      	ldr	r4, [r0, #36]	; 0x24
    list_data info = {0,0};
    ee_s16 i;

    info.idx=finder_idx;
    /* find <find_num> values in the list, and change the list each time (reverse and cache if value found) */
    for (i=0; i<find_num; i++) {
    cbba:	f1be 0f00 	cmp.w	lr, #0
ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {
    cbbe:	b085      	sub	sp, #20
    cbc0:	4602      	mov	r2, r0
    cbc2:	4688      	mov	r8, r1
    for (i=0; i<find_num; i++) {
    cbc4:	f340 8155 	ble.w	ce72 <core_bench_list+0x2c2>
    cbc8:	2600      	movs	r6, #0
    info.idx=finder_idx;
    cbca:	468a      	mov	sl, r1
    ee_u16 found=0,missed=0;
    cbcc:	46b4      	mov	ip, r6
    cbce:	4637      	mov	r7, r6
    ee_u16 retval=0;
    cbd0:	4635      	mov	r5, r6
    cbd2:	4681      	mov	r9, r0

    Returns:
    Found item, or NULL if not found.
*/
list_head *core_list_find(list_head *list,list_data *info) {
    if (info->idx>=0) {
    cbd4:	f1ba 0f00 	cmp.w	sl, #0
        info.data16= (i & 0xff) ;
    cbd8:	b2f1      	uxtb	r1, r6
    if (info->idx>=0) {
    cbda:	f2c0 80b2 	blt.w	cd42 <core_bench_list+0x192>
        while (list && (list->info->idx != info->idx))
    cbde:	2c00      	cmp	r4, #0
    cbe0:	f000 814e 	beq.w	ce80 <core_bench_list+0x2d0>
    cbe4:	4620      	mov	r0, r4
    cbe6:	e001      	b.n	cbec <core_bench_list+0x3c>
            list=list->next;
    cbe8:	6800      	ldr	r0, [r0, #0]
        while (list && (list->info->idx != info->idx))
    cbea:	b120      	cbz	r0, cbf6 <core_bench_list+0x46>
    cbec:	6843      	ldr	r3, [r0, #4]
    cbee:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
    cbf2:	4553      	cmp	r3, sl
    cbf4:	d1f8      	bne.n	cbe8 <core_bench_list+0x38>
    Returns:
    Found item, or NULL if not found.
*/

list_head *core_list_reverse(list_head *list) {
    list_head *next=NULL, *tmp;
    cbf6:	2200      	movs	r2, #0
    cbf8:	e001      	b.n	cbfe <core_bench_list+0x4e>
    cbfa:	4622      	mov	r2, r4
    cbfc:	461c      	mov	r4, r3
    while (list) {
        tmp=list->next;
    cbfe:	6823      	ldr	r3, [r4, #0]
        list->next=next;
    cc00:	6022      	str	r2, [r4, #0]
    while (list) {
    cc02:	2b00      	cmp	r3, #0
    cc04:	d1f9      	bne.n	cbfa <core_bench_list+0x4a>
        if (this_find==NULL) {
    cc06:	2800      	cmp	r0, #0
    cc08:	f000 80a9 	beq.w	cd5e <core_bench_list+0x1ae>
            if (this_find->info->data16 & 0x1) /* use found value */
    cc0c:	6843      	ldr	r3, [r0, #4]
    cc0e:	f9b3 3000 	ldrsh.w	r3, [r3]
            found++;
    cc12:	3701      	adds	r7, #1
            if (this_find->info->data16 & 0x1) /* use found value */
    cc14:	07da      	lsls	r2, r3, #31
            found++;
    cc16:	b2bf      	uxth	r7, r7
            if (this_find->info->data16 & 0x1) /* use found value */
    cc18:	d503      	bpl.n	cc22 <core_bench_list+0x72>
                retval+=(this_find->info->data16 >> 9) & 1;
    cc1a:	f3c3 2340 	ubfx	r3, r3, #9, #1
    cc1e:	441d      	add	r5, r3
    cc20:	b2ad      	uxth	r5, r5
            if (this_find->next != NULL) {
    cc22:	6803      	ldr	r3, [r0, #0]
    cc24:	b123      	cbz	r3, cc30 <core_bench_list+0x80>
                this_find->next = finder->next;
    cc26:	681a      	ldr	r2, [r3, #0]
    cc28:	6002      	str	r2, [r0, #0]
                finder->next=list->next;
    cc2a:	6822      	ldr	r2, [r4, #0]
    cc2c:	601a      	str	r2, [r3, #0]
                list->next=finder;
    cc2e:	6023      	str	r3, [r4, #0]
        if (info.idx>=0)
    cc30:	f1ba 0f00 	cmp.w	sl, #0
    for (i=0; i<find_num; i++) {
    cc34:	f106 0601 	add.w	r6, r6, #1
            info.idx++;
    cc38:	bfa8      	it	ge
    cc3a:	f10a 0a01 	addge.w	sl, sl, #1
    for (i=0; i<find_num; i++) {
    cc3e:	b233      	sxth	r3, r6
            info.idx++;
    cc40:	bfa8      	it	ge
    cc42:	fa0f fa8a 	sxthge.w	sl, sl
    for (i=0; i<find_num; i++) {
    cc46:	459e      	cmp	lr, r3
    cc48:	dcc4      	bgt.n	cbd4 <core_bench_list+0x24>
    retval+=found*4-missed;
    cc4a:	ebcc 0787 	rsb	r7, ip, r7, lsl #2
    cc4e:	443d      	add	r5, r7
    cc50:	b2ab      	uxth	r3, r5
    cc52:	9102      	str	r1, [sp, #8]
    cc54:	464a      	mov	r2, r9
    cc56:	9301      	str	r3, [sp, #4]
    if (finder_idx>0)
    cc58:	f1b8 0f00 	cmp.w	r8, #0
    cc5c:	f300 80c4 	bgt.w	cde8 <core_bench_list+0x238>
    remover=core_list_remove(list->next);
    cc60:	6823      	ldr	r3, [r4, #0]
    tmp=item->info;
    cc62:	e9d3 6200 	ldrd	r6, r2, [r3]
    ret->next=NULL;
    cc66:	2000      	movs	r0, #0
    item->info=ret->info;
    cc68:	6871      	ldr	r1, [r6, #4]
    cc6a:	6059      	str	r1, [r3, #4]
    if (info->idx>=0) {
    cc6c:	4582      	cmp	sl, r0
    item->next=item->next->next;
    cc6e:	6831      	ldr	r1, [r6, #0]
    ret->info=tmp;
    cc70:	6072      	str	r2, [r6, #4]
    item->next=item->next->next;
    cc72:	4625      	mov	r5, r4
    cc74:	6019      	str	r1, [r3, #0]
    ret->next=NULL;
    cc76:	6030      	str	r0, [r6, #0]
    if (info->idx>=0) {
    cc78:	f2c0 80a8 	blt.w	cdcc <core_bench_list+0x21c>
        while (list && (list->info->idx != info->idx))
    cc7c:	686b      	ldr	r3, [r5, #4]
    cc7e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
    cc82:	4553      	cmp	r3, sl
    cc84:	d004      	beq.n	cc90 <core_bench_list+0xe0>
            list=list->next;
    cc86:	682d      	ldr	r5, [r5, #0]
        while (list && (list->info->idx != info->idx))
    cc88:	2d00      	cmp	r5, #0
    cc8a:	d1f7      	bne.n	cc7c <core_bench_list+0xcc>
        finder=list->next;
    cc8c:	6825      	ldr	r5, [r4, #0]
    while (finder) {
    cc8e:	b165      	cbz	r5, ccaa <core_bench_list+0xfa>
    cc90:	9901      	ldr	r1, [sp, #4]
        retval=crc16(list->info->data16,retval);
    cc92:	6863      	ldr	r3, [r4, #4]
    cc94:	f9b3 0000 	ldrsh.w	r0, [r3]
    cc98:	f001 fe7a 	bl	e990 <crc16>
        finder=finder->next;
    cc9c:	682d      	ldr	r5, [r5, #0]
        retval=crc16(list->info->data16,retval);
    cc9e:	4601      	mov	r1, r0
    while (finder) {
    cca0:	2d00      	cmp	r5, #0
    cca2:	d1f6      	bne.n	cc92 <core_bench_list+0xe2>
    remover=core_list_undo_remove(remover,list->next);
    cca4:	6825      	ldr	r5, [r4, #0]
    tmp=item_removed->info;
    cca6:	6872      	ldr	r2, [r6, #4]
    remover=core_list_undo_remove(remover,list->next);
    cca8:	9001      	str	r0, [sp, #4]
    item_removed->info=item_modified->info;
    ccaa:	686b      	ldr	r3, [r5, #4]
    ccac:	6073      	str	r3, [r6, #4]
    insize = 1;

    while (1) {
        p = list;
        list = NULL;
        tail = NULL;
    ccae:	2100      	movs	r1, #0
    item_removed->next=item_modified->next;
    ccb0:	682b      	ldr	r3, [r5, #0]
    item_modified->info=tmp;
    ccb2:	606a      	str	r2, [r5, #4]
    insize = 1;
    ccb4:	f04f 0e01 	mov.w	lr, #1
    item_removed->next=item_modified->next;
    ccb8:	6033      	str	r3, [r6, #0]

        nmerges = 0;  /* count number of merges we do in this pass */
    ccba:	468a      	mov	sl, r1
    item_modified->next=item_removed;
    ccbc:	602e      	str	r6, [r5, #0]

            /* now p has stepped `insize' places along, and q has too */
            p = q;
        }

        tail->next = NULL;
    ccbe:	468b      	mov	fp, r1
    ccc0:	460f      	mov	r7, r1
            nmerges++;  /* there exists a merge to be done */
    ccc2:	f10a 0a01 	add.w	sl, sl, #1
    ccc6:	4623      	mov	r3, r4
            psize = 0;
    ccc8:	2200      	movs	r2, #0
                q = q->next;
    ccca:	681b      	ldr	r3, [r3, #0]
                psize++;
    cccc:	3201      	adds	r2, #1
                if (!q) break;
    ccce:	b10b      	cbz	r3, ccd4 <core_bench_list+0x124>
            for (i = 0; i < insize; i++) {
    ccd0:	4596      	cmp	lr, r2
    ccd2:	d1fa      	bne.n	ccca <core_bench_list+0x11a>
                    list = e;
    ccd4:	4675      	mov	r5, lr
            while (psize > 0 || (qsize > 0 && q)) {
    ccd6:	b352      	cbz	r2, cd2e <core_bench_list+0x17e>
                } else if (qsize == 0 || !q) {
    ccd8:	2d00      	cmp	r5, #0
    ccda:	d04c      	beq.n	cd76 <core_bench_list+0x1c6>
    ccdc:	2b00      	cmp	r3, #0
    ccde:	d04a      	beq.n	cd76 <core_bench_list+0x1c6>
                } else if (cmp(p->info,q->info,res) <= 0) {
    cce0:	f8d4 c004 	ldr.w	ip, [r4, #4]
    cce4:	685e      	ldr	r6, [r3, #4]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    cce6:	f9bc 0000 	ldrsh.w	r0, [ip]
    return a->idx - b->idx;
    ccea:	f9bc 8002 	ldrsh.w	r8, [ip, #2]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    ccee:	f020 09ff 	bic.w	r9, r0, #255	; 0xff
    ccf2:	f3c0 2007 	ubfx	r0, r0, #8, #8
    ccf6:	ea49 0000 	orr.w	r0, r9, r0
    ccfa:	f8ac 0000 	strh.w	r0, [ip]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    ccfe:	f9b6 0000 	ldrsh.w	r0, [r6]
    return a->idx - b->idx;
    cd02:	f9b6 c002 	ldrsh.w	ip, [r6, #2]
    cd06:	eba8 080c 	sub.w	r8, r8, ip
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cd0a:	f020 0cff 	bic.w	ip, r0, #255	; 0xff
    cd0e:	f3c0 2007 	ubfx	r0, r0, #8, #8
    cd12:	ea4c 0000 	orr.w	r0, ip, r0
                } else if (cmp(p->info,q->info,res) <= 0) {
    cd16:	f1b8 0f00 	cmp.w	r8, #0
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cd1a:	8030      	strh	r0, [r6, #0]
                } else if (cmp(p->info,q->info,res) <= 0) {
    cd1c:	dd2b      	ble.n	cd76 <core_bench_list+0x1c6>
                    e = q; q = q->next; qsize--;
    cd1e:	4618      	mov	r0, r3
    cd20:	681b      	ldr	r3, [r3, #0]
    cd22:	3d01      	subs	r5, #1
                if (tail) {
    cd24:	b151      	cbz	r1, cd3c <core_bench_list+0x18c>
                    tail->next = e;
    cd26:	6008      	str	r0, [r1, #0]
                    list = e;
    cd28:	4601      	mov	r1, r0
            while (psize > 0 || (qsize > 0 && q)) {
    cd2a:	2a00      	cmp	r2, #0
    cd2c:	d1d4      	bne.n	ccd8 <core_bench_list+0x128>
    cd2e:	b335      	cbz	r5, cd7e <core_bench_list+0x1ce>
    cd30:	b343      	cbz	r3, cd84 <core_bench_list+0x1d4>
                    e = q; q = q->next; qsize--;
    cd32:	4618      	mov	r0, r3
    cd34:	3d01      	subs	r5, #1
    cd36:	681b      	ldr	r3, [r3, #0]
                if (tail) {
    cd38:	2900      	cmp	r1, #0
    cd3a:	d1f4      	bne.n	cd26 <core_bench_list+0x176>
                    list = e;
    cd3c:	4607      	mov	r7, r0
    cd3e:	4601      	mov	r1, r0
    cd40:	e7f3      	b.n	cd2a <core_bench_list+0x17a>
        while (list && ((list->info->data16 & 0xff) != info->data16))
    cd42:	2c00      	cmp	r4, #0
    cd44:	f000 809c 	beq.w	ce80 <core_bench_list+0x2d0>
    cd48:	4620      	mov	r0, r4
    cd4a:	e003      	b.n	cd54 <core_bench_list+0x1a4>
            list=list->next;
    cd4c:	6800      	ldr	r0, [r0, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    cd4e:	2800      	cmp	r0, #0
    cd50:	f43f af51 	beq.w	cbf6 <core_bench_list+0x46>
    cd54:	6843      	ldr	r3, [r0, #4]
    cd56:	781b      	ldrb	r3, [r3, #0]
    cd58:	4299      	cmp	r1, r3
    cd5a:	d1f7      	bne.n	cd4c <core_bench_list+0x19c>
    cd5c:	e74b      	b.n	cbf6 <core_bench_list+0x46>
            retval+=(list->next->info->data16 >> 8) & 1;
    cd5e:	6853      	ldr	r3, [r2, #4]
    cd60:	f993 3001 	ldrsb.w	r3, [r3, #1]
    cd64:	f003 0301 	and.w	r3, r3, #1
            missed++;
    cd68:	f10c 0c01 	add.w	ip, ip, #1
            retval+=(list->next->info->data16 >> 8) & 1;
    cd6c:	441d      	add	r5, r3
            missed++;
    cd6e:	fa1f fc8c 	uxth.w	ip, ip
            retval+=(list->next->info->data16 >> 8) & 1;
    cd72:	b2ad      	uxth	r5, r5
    cd74:	e75c      	b.n	cc30 <core_bench_list+0x80>
                    e = p; p = p->next; psize--;
    cd76:	4620      	mov	r0, r4
    cd78:	3a01      	subs	r2, #1
    cd7a:	6824      	ldr	r4, [r4, #0]
    cd7c:	e7d2      	b.n	cd24 <core_bench_list+0x174>
        while (p) {
    cd7e:	b10b      	cbz	r3, cd84 <core_bench_list+0x1d4>
        list = NULL;
    cd80:	461c      	mov	r4, r3
    cd82:	e79e      	b.n	ccc2 <core_bench_list+0x112>

        /* If we have done only one merge, we're finished. */
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    cd84:	f1ba 0f01 	cmp.w	sl, #1
        tail->next = NULL;
    cd88:	f8c1 b000 	str.w	fp, [r1]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    cd8c:	d00b      	beq.n	cda6 <core_bench_list+0x1f6>
            return list;

        /* Otherwise repeat, merging lists twice the size */
        insize *= 2;
    cd8e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
        while (p) {
    cd92:	b137      	cbz	r7, cda2 <core_bench_list+0x1f2>
        nmerges = 0;  /* count number of merges we do in this pass */
    cd94:	f04f 0a00 	mov.w	sl, #0
        while (p) {
    cd98:	463b      	mov	r3, r7
        tail = NULL;
    cd9a:	4651      	mov	r1, sl
        list = NULL;
    cd9c:	4657      	mov	r7, sl
    cd9e:	461c      	mov	r4, r3
    cda0:	e78f      	b.n	ccc2 <core_bench_list+0x112>
        tail->next = NULL;
    cda2:	603f      	str	r7, [r7, #0]
    cda4:	deff      	udf	#255	; 0xff
    finder=list->next;
    cda6:	683c      	ldr	r4, [r7, #0]
    while (finder) {
    cda8:	9801      	ldr	r0, [sp, #4]
    finder=list->next;
    cdaa:	46b8      	mov	r8, r7
    while (finder) {
    cdac:	b15c      	cbz	r4, cdc6 <core_bench_list+0x216>
    cdae:	9901      	ldr	r1, [sp, #4]
        retval=crc16(list->info->data16,retval);
    cdb0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    cdb4:	f9b3 0000 	ldrsh.w	r0, [r3]
    cdb8:	f001 fdea 	bl	e990 <crc16>
        finder=finder->next;
    cdbc:	6824      	ldr	r4, [r4, #0]
        retval=crc16(list->info->data16,retval);
    cdbe:	4601      	mov	r1, r0
    while (finder) {
    cdc0:	2c00      	cmp	r4, #0
    cdc2:	d1f5      	bne.n	cdb0 <core_bench_list+0x200>
    cdc4:	9001      	str	r0, [sp, #4]
}
    cdc6:	b005      	add	sp, #20
    cdc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cdcc:	9902      	ldr	r1, [sp, #8]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    cdce:	686b      	ldr	r3, [r5, #4]
    cdd0:	781b      	ldrb	r3, [r3, #0]
    cdd2:	428b      	cmp	r3, r1
    cdd4:	f43f af5c 	beq.w	cc90 <core_bench_list+0xe0>
            list=list->next;
    cdd8:	682d      	ldr	r5, [r5, #0]
        while (list && ((list->info->data16 & 0xff) != info->data16))
    cdda:	2d00      	cmp	r5, #0
    cddc:	d1f7      	bne.n	cdce <core_bench_list+0x21e>
        finder=list->next;
    cdde:	6825      	ldr	r5, [r4, #0]
    while (finder) {
    cde0:	2d00      	cmp	r5, #0
    cde2:	f47f af55 	bne.w	cc90 <core_bench_list+0xe0>
    cde6:	e760      	b.n	ccaa <core_bench_list+0xfa>
    insize = 1;
    cde8:	f04f 0b01 	mov.w	fp, #1
        tail = NULL;
    cdec:	f8cd a00c 	str.w	sl, [sp, #12]
        while (p) {
    cdf0:	2c00      	cmp	r4, #0
    cdf2:	d043      	beq.n	ce7c <core_bench_list+0x2cc>
        tail = NULL;
    cdf4:	2600      	movs	r6, #0
        list = NULL;
    cdf6:	46b1      	mov	r9, r6
        nmerges = 0;  /* count number of merges we do in this pass */
    cdf8:	46b2      	mov	sl, r6
            nmerges++;  /* there exists a merge to be done */
    cdfa:	f10a 0a01 	add.w	sl, sl, #1
    cdfe:	4623      	mov	r3, r4
            psize = 0;
    ce00:	2500      	movs	r5, #0
                q = q->next;
    ce02:	681b      	ldr	r3, [r3, #0]
                psize++;
    ce04:	3501      	adds	r5, #1
                if (!q) break;
    ce06:	b10b      	cbz	r3, ce0c <core_bench_list+0x25c>
            for (i = 0; i < insize; i++) {
    ce08:	455d      	cmp	r5, fp
    ce0a:	d1fa      	bne.n	ce02 <core_bench_list+0x252>
                    list = e;
    ce0c:	46a0      	mov	r8, r4
    ce0e:	465f      	mov	r7, fp
    ce10:	461c      	mov	r4, r3
            while (psize > 0 || (qsize > 0 && q)) {
    ce12:	b195      	cbz	r5, ce3a <core_bench_list+0x28a>
                } else if (qsize == 0 || !q) {
    ce14:	b1ef      	cbz	r7, ce52 <core_bench_list+0x2a2>
    ce16:	b1e4      	cbz	r4, ce52 <core_bench_list+0x2a2>
                } else if (cmp(p->info,q->info,res) <= 0) {
    ce18:	6861      	ldr	r1, [r4, #4]
    ce1a:	f8d8 0004 	ldr.w	r0, [r8, #4]
    ce1e:	9200      	str	r2, [sp, #0]
    ce20:	f7ff fe3c 	bl	ca9c <cmp_complex>
    ce24:	2800      	cmp	r0, #0
    ce26:	9a00      	ldr	r2, [sp, #0]
    ce28:	dd13      	ble.n	ce52 <core_bench_list+0x2a2>
                    e = q; q = q->next; qsize--;
    ce2a:	4623      	mov	r3, r4
    ce2c:	3f01      	subs	r7, #1
    ce2e:	6824      	ldr	r4, [r4, #0]
                if (tail) {
    ce30:	b1ae      	cbz	r6, ce5e <core_bench_list+0x2ae>
                    tail->next = e;
    ce32:	6033      	str	r3, [r6, #0]
                    list = e;
    ce34:	461e      	mov	r6, r3
            while (psize > 0 || (qsize > 0 && q)) {
    ce36:	2d00      	cmp	r5, #0
    ce38:	d1ec      	bne.n	ce14 <core_bench_list+0x264>
    ce3a:	b19f      	cbz	r7, ce64 <core_bench_list+0x2b4>
    ce3c:	2c00      	cmp	r4, #0
    ce3e:	d1f4      	bne.n	ce2a <core_bench_list+0x27a>
        tail->next = NULL;
    ce40:	2300      	movs	r3, #0
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    ce42:	f1ba 0f01 	cmp.w	sl, #1
        tail->next = NULL;
    ce46:	6033      	str	r3, [r6, #0]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    ce48:	d00f      	beq.n	ce6a <core_bench_list+0x2ba>
        insize *= 2;
    ce4a:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
        p = list;
    ce4e:	464c      	mov	r4, r9
    ce50:	e7ce      	b.n	cdf0 <core_bench_list+0x240>
                    e = p; p = p->next; psize--;
    ce52:	4643      	mov	r3, r8
    ce54:	3d01      	subs	r5, #1
    ce56:	f8d8 8000 	ldr.w	r8, [r8]
                if (tail) {
    ce5a:	2e00      	cmp	r6, #0
    ce5c:	d1e9      	bne.n	ce32 <core_bench_list+0x282>
                    list = e;
    ce5e:	4699      	mov	r9, r3
    ce60:	461e      	mov	r6, r3
    ce62:	e7e8      	b.n	ce36 <core_bench_list+0x286>
        while (p) {
    ce64:	2c00      	cmp	r4, #0
    ce66:	d1c8      	bne.n	cdfa <core_bench_list+0x24a>
    ce68:	e7ea      	b.n	ce40 <core_bench_list+0x290>
    ce6a:	f8dd a00c 	ldr.w	sl, [sp, #12]
    ce6e:	464c      	mov	r4, r9
    ce70:	e6f6      	b.n	cc60 <core_bench_list+0xb0>
    for (i=0; i<find_num; i++) {
    ce72:	2300      	movs	r3, #0
    ce74:	9301      	str	r3, [sp, #4]
    info.idx=finder_idx;
    ce76:	468a      	mov	sl, r1
    list_data info = {0,0};
    ce78:	9302      	str	r3, [sp, #8]
    ce7a:	e6ed      	b.n	cc58 <core_bench_list+0xa8>
        tail->next = NULL;
    ce7c:	6024      	str	r4, [r4, #0]
    ce7e:	deff      	udf	#255	; 0xff
            retval+=(list->next->info->data16 >> 8) & 1;
    ce80:	2300      	movs	r3, #0
    ce82:	681b      	ldr	r3, [r3, #0]
    ce84:	deff      	udf	#255	; 0xff
    ce86:	bf00      	nop

0000ce88 <core_list_init>:
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    ce88:	4b6a      	ldr	r3, [pc, #424]	; (d034 <core_list_init+0x1ac>)
    ce8a:	fba3 0300 	umull	r0, r3, r3, r0
    ce8e:	091b      	lsrs	r3, r3, #4
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    ce90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u32 size=(blksize/per_item)-2; /* to accomodate systems with 64b pointers, and make sure same code is executed, set max list elements */
    ce94:	1e9e      	subs	r6, r3, #2
    list_head *memblock_end=memblock+size;
    ce96:	eb01 0cc6 	add.w	ip, r1, r6, lsl #3
list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {
    ce9a:	460c      	mov	r4, r1
    list->next=NULL;
    ce9c:	2300      	movs	r3, #0
    list->info=datablock;
    ce9e:	f8c1 c004 	str.w	ip, [r1, #4]
    list->next=NULL;
    cea2:	600b      	str	r3, [r1, #0]
    list->info->data16=(ee_s16)0x8080;
    cea4:	f248 0180 	movw	r1, #32896	; 0x8080
    cea8:	f844 1036 	str.w	r1, [r4, r6, lsl #3]
    if ((*memblock+1) >= memblock_end)
    ceac:	f104 0110 	add.w	r1, r4, #16
    ceb0:	458c      	cmp	ip, r1
    list_data *datablock_end=datablock+size;
    ceb2:	eb0c 0886 	add.w	r8, ip, r6, lsl #2
    memblock++;
    ceb6:	f104 0008 	add.w	r0, r4, #8
    datablock++;
    ceba:	f10c 0704 	add.w	r7, ip, #4
    if ((*memblock+1) >= memblock_end)
    cebe:	f240 80b4 	bls.w	d02a <core_list_init+0x1a2>
    if ((*datablock+1) >= datablock_end)
    cec2:	f10c 0508 	add.w	r5, ip, #8
    cec6:	45a8      	cmp	r8, r5
    cec8:	f240 80af 	bls.w	d02a <core_list_init+0x1a2>
    newitem->info=*datablock;
    cecc:	e9c4 3702 	strd	r3, r7, [r4, #8]
    to->data16=from->data16;
    ced0:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    insert_point->next=newitem;
    ced4:	6020      	str	r0, [r4, #0]
    to->data16=from->data16;
    ced6:	f8cc 3004 	str.w	r3, [ip, #4]
    for (i=0; i<size; i++) {
    ceda:	b32e      	cbz	r6, cf28 <core_list_init+0xa0>
            ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
    cedc:	fa1f fa82 	uxth.w	sl, r2
    cee0:	2700      	movs	r7, #0
    to->idx=from->idx;
    cee2:	f647 79ff 	movw	r9, #32767	; 0x7fff
    if ((*memblock+1) >= memblock_end)
    cee6:	f101 0308 	add.w	r3, r1, #8
    ceea:	459c      	cmp	ip, r3
    ceec:	d91c      	bls.n	cf28 <core_list_init+0xa0>
    if ((*datablock+1) >= datablock_end)
    ceee:	f105 0e04 	add.w	lr, r5, #4
    cef2:	45f0      	cmp	r8, lr
    cef4:	d915      	bls.n	cf22 <core_list_init+0x9a>
    cef6:	fa1f fb87 	uxth.w	fp, r7
    newitem->next=insert_point->next;
    cefa:	6008      	str	r0, [r1, #0]
    insert_point->next=newitem;
    cefc:	6021      	str	r1, [r4, #0]
    return newitem;
    cefe:	4608      	mov	r0, r1
    newitem->info=*datablock;
    cf00:	604d      	str	r5, [r1, #4]
    return newitem;
    cf02:	4619      	mov	r1, r3
        ee_u16 datpat=((ee_u16)(seed^i) & 0xf);
    cf04:	ea8b 030a 	eor.w	r3, fp, sl
        ee_u16 dat=(datpat<<3) | (i&0x7); /* alternate between algorithms */
    cf08:	00db      	lsls	r3, r3, #3
    cf0a:	f003 0378 	and.w	r3, r3, #120	; 0x78
    cf0e:	f00b 0b07 	and.w	fp, fp, #7
    cf12:	ea43 030b 	orr.w	r3, r3, fp
        info.data16=(dat<<8) | dat;     /* fill the data with actual data and upper bits with rebuild value */
    cf16:	ea43 2303 	orr.w	r3, r3, r3, lsl #8
    to->idx=from->idx;
    cf1a:	f8a5 9002 	strh.w	r9, [r5, #2]
    to->data16=from->data16;
    cf1e:	802b      	strh	r3, [r5, #0]
    return newitem;
    cf20:	4675      	mov	r5, lr
    for (i=0; i<size; i++) {
    cf22:	3701      	adds	r7, #1
    cf24:	42be      	cmp	r6, r7
    cf26:	d1de      	bne.n	cee6 <core_list_init+0x5e>
    while (finder->next!=NULL) {
    cf28:	6805      	ldr	r5, [r0, #0]
    cf2a:	b305      	cbz	r5, cf6e <core_list_init+0xe6>
        if (i<size/5) /* first 20% of the list in order */
    cf2c:	4b41      	ldr	r3, [pc, #260]	; (d034 <core_list_init+0x1ac>)
    cf2e:	fba3 3606 	umull	r3, r6, r3, r6
    cf32:	ea4f 0c96 	mov.w	ip, r6, lsr #2
    cf36:	2702      	movs	r7, #2
    cf38:	2301      	movs	r3, #1
    cf3a:	e007      	b.n	cf4c <core_list_init+0xc4>
            finder->info->idx=i++;
    cf3c:	6841      	ldr	r1, [r0, #4]
    while (finder->next!=NULL) {
    cf3e:	682e      	ldr	r6, [r5, #0]
            finder->info->idx=i++;
    cf40:	804b      	strh	r3, [r1, #2]
    while (finder->next!=NULL) {
    cf42:	3701      	adds	r7, #1
    cf44:	3301      	adds	r3, #1
    cf46:	b196      	cbz	r6, cf6e <core_list_init+0xe6>
        if (i<size/5) /* first 20% of the list in order */
    cf48:	4628      	mov	r0, r5
    cf4a:	4635      	mov	r5, r6
    cf4c:	459c      	cmp	ip, r3
    cf4e:	d8f5      	bhi.n	cf3c <core_list_init+0xb4>
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    cf50:	0239      	lsls	r1, r7, #8
            ee_u16 pat=(ee_u16)(i++ ^ seed); /* get a pseudo random number */
    cf52:	ea82 0603 	eor.w	r6, r2, r3
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    cf56:	f401 61e0 	and.w	r1, r1, #1792	; 0x700
    cf5a:	4331      	orrs	r1, r6
    cf5c:	6840      	ldr	r0, [r0, #4]
    while (finder->next!=NULL) {
    cf5e:	682e      	ldr	r6, [r5, #0]
            finder->info->idx=0x3fff & (((i & 0x07) << 8) | pat); /* make sure the mixed items end up after the ones in sequence */
    cf60:	f3c1 010d 	ubfx	r1, r1, #0, #14
    cf64:	8041      	strh	r1, [r0, #2]
    while (finder->next!=NULL) {
    cf66:	3301      	adds	r3, #1
    cf68:	3701      	adds	r7, #1
    cf6a:	2e00      	cmp	r6, #0
    cf6c:	d1ec      	bne.n	cf48 <core_list_init+0xc0>
        tail = NULL;
    cf6e:	2500      	movs	r5, #0
    insize = 1;
    cf70:	f04f 0c01 	mov.w	ip, #1
        list = NULL;
    cf74:	46ae      	mov	lr, r5
        nmerges = 0;  /* count number of merges we do in this pass */
    cf76:	462e      	mov	r6, r5
        tail->next = NULL;
    cf78:	46a8      	mov	r8, r5
            nmerges++;  /* there exists a merge to be done */
    cf7a:	3601      	adds	r6, #1
    cf7c:	4623      	mov	r3, r4
            psize = 0;
    cf7e:	2200      	movs	r2, #0
                q = q->next;
    cf80:	681b      	ldr	r3, [r3, #0]
                psize++;
    cf82:	3201      	adds	r2, #1
                if (!q) break;
    cf84:	b10b      	cbz	r3, cf8a <core_list_init+0x102>
            for (i = 0; i < insize; i++) {
    cf86:	4562      	cmp	r2, ip
    cf88:	d1fa      	bne.n	cf80 <core_list_init+0xf8>
                    list = e;
    cf8a:	4660      	mov	r0, ip
            while (psize > 0 || (qsize > 0 && q)) {
    cf8c:	b33a      	cbz	r2, cfde <core_list_init+0x156>
                } else if (qsize == 0 || !q) {
    cf8e:	b380      	cbz	r0, cff2 <core_list_init+0x16a>
    cf90:	b37b      	cbz	r3, cff2 <core_list_init+0x16a>
                } else if (cmp(p->info,q->info,res) <= 0) {
    cf92:	f8d4 9004 	ldr.w	r9, [r4, #4]
    cf96:	685f      	ldr	r7, [r3, #4]
        a->data16 = (a->data16 & 0xff00) | (0x00ff & (a->data16>>8));
    cf98:	f9b9 1000 	ldrsh.w	r1, [r9]
    cf9c:	f021 0aff 	bic.w	sl, r1, #255	; 0xff
    cfa0:	f3c1 2107 	ubfx	r1, r1, #8, #8
    cfa4:	ea4a 0101 	orr.w	r1, sl, r1
    cfa8:	f8a9 1000 	strh.w	r1, [r9]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cfac:	f9b7 1000 	ldrsh.w	r1, [r7]
    return a->idx - b->idx;
    cfb0:	f9b9 9002 	ldrsh.w	r9, [r9, #2]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cfb4:	f021 0aff 	bic.w	sl, r1, #255	; 0xff
    cfb8:	f3c1 2107 	ubfx	r1, r1, #8, #8
    cfbc:	ea4a 0101 	orr.w	r1, sl, r1
    return a->idx - b->idx;
    cfc0:	f9b7 a002 	ldrsh.w	sl, [r7, #2]
        b->data16 = (b->data16 & 0xff00) | (0x00ff & (b->data16>>8));
    cfc4:	8039      	strh	r1, [r7, #0]
    return a->idx - b->idx;
    cfc6:	eba9 010a 	sub.w	r1, r9, sl
                } else if (cmp(p->info,q->info,res) <= 0) {
    cfca:	2900      	cmp	r1, #0
    cfcc:	dd11      	ble.n	cff2 <core_list_init+0x16a>
                    e = q; q = q->next; qsize--;
    cfce:	4619      	mov	r1, r3
    cfd0:	681b      	ldr	r3, [r3, #0]
    cfd2:	3801      	subs	r0, #1
                if (tail) {
    cfd4:	b155      	cbz	r5, cfec <core_list_init+0x164>
                    tail->next = e;
    cfd6:	6029      	str	r1, [r5, #0]
                    list = e;
    cfd8:	460d      	mov	r5, r1
            while (psize > 0 || (qsize > 0 && q)) {
    cfda:	2a00      	cmp	r2, #0
    cfdc:	d1d7      	bne.n	cf8e <core_list_init+0x106>
    cfde:	b160      	cbz	r0, cffa <core_list_init+0x172>
    cfe0:	b173      	cbz	r3, d000 <core_list_init+0x178>
                    e = q; q = q->next; qsize--;
    cfe2:	4619      	mov	r1, r3
    cfe4:	3801      	subs	r0, #1
    cfe6:	681b      	ldr	r3, [r3, #0]
                if (tail) {
    cfe8:	2d00      	cmp	r5, #0
    cfea:	d1f4      	bne.n	cfd6 <core_list_init+0x14e>
                    list = e;
    cfec:	468e      	mov	lr, r1
    cfee:	460d      	mov	r5, r1
    cff0:	e7f3      	b.n	cfda <core_list_init+0x152>
                    e = p; p = p->next; psize--;
    cff2:	4621      	mov	r1, r4
    cff4:	3a01      	subs	r2, #1
    cff6:	6824      	ldr	r4, [r4, #0]
    cff8:	e7ec      	b.n	cfd4 <core_list_init+0x14c>
        while (p) {
    cffa:	b10b      	cbz	r3, d000 <core_list_init+0x178>
        list = NULL;
    cffc:	461c      	mov	r4, r3
    cffe:	e7bc      	b.n	cf7a <core_list_init+0xf2>
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    d000:	2e01      	cmp	r6, #1
        tail->next = NULL;
    d002:	f8c5 8000 	str.w	r8, [r5]
        if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
    d006:	d00a      	beq.n	d01e <core_list_init+0x196>
        insize *= 2;
    d008:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
        while (p) {
    d00c:	f1be 0f00 	cmp.w	lr, #0
    d010:	d008      	beq.n	d024 <core_list_init+0x19c>
        nmerges = 0;  /* count number of merges we do in this pass */
    d012:	2600      	movs	r6, #0
        while (p) {
    d014:	4673      	mov	r3, lr
        tail = NULL;
    d016:	4635      	mov	r5, r6
        list = NULL;
    d018:	46b6      	mov	lr, r6
    d01a:	461c      	mov	r4, r3
    d01c:	e7ad      	b.n	cf7a <core_list_init+0xf2>
}
    d01e:	4670      	mov	r0, lr
    d020:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tail->next = NULL;
    d024:	f8ce e000 	str.w	lr, [lr]
    d028:	deff      	udf	#255	; 0xff
    memblock++;
    d02a:	4601      	mov	r1, r0
    datablock++;
    d02c:	463d      	mov	r5, r7
    d02e:	4618      	mov	r0, r3
    d030:	e753      	b.n	ceda <core_list_init+0x52>
    d032:	bf00      	nop
    d034:	cccccccd 	.word	0xcccccccd

0000d038 <iterate>:
    NULL.
*/
static ee_u16 list_known_crc[]   =      {(ee_u16)0xd4b0,(ee_u16)0x3340,(ee_u16)0x6a79,(ee_u16)0xe714,(ee_u16)0xe3c1};
static ee_u16 matrix_known_crc[] =      {(ee_u16)0xbe52,(ee_u16)0x1199,(ee_u16)0x5608,(ee_u16)0x1fd7,(ee_u16)0x0747};
static ee_u16 state_known_crc[]  =      {(ee_u16)0x5e47,(ee_u16)0x39bf,(ee_u16)0xe5a4,(ee_u16)0x8e3a,(ee_u16)0x8d84};
void *iterate(void *pres) {
    d038:	b570      	push	{r4, r5, r6, lr}
    ee_u32 i;
    ee_u16 crc;
    core_results *res=(core_results *)pres;
    ee_u32 iterations=res->iterations;
    d03a:	69c6      	ldr	r6, [r0, #28]
    res->crc=0;
    d03c:	2500      	movs	r5, #0
    d03e:	e9c0 550e 	strd	r5, r5, [r0, #56]	; 0x38
void *iterate(void *pres) {
    d042:	4604      	mov	r4, r0
    res->crclist=0;
    res->crcmatrix=0;
    res->crcstate=0;

    for (i=0; i<iterations; i++) {
    d044:	b1a6      	cbz	r6, d070 <iterate+0x38>
        crc=core_bench_list(res,1);
    d046:	2101      	movs	r1, #1
    d048:	4620      	mov	r0, r4
    d04a:	f7ff fdb1 	bl	cbb0 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d04e:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d050:	f001 fab4 	bl	e5bc <crcu16>
        crc=core_bench_list(res,-1);
    d054:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d058:	8720      	strh	r0, [r4, #56]	; 0x38
        crc=core_bench_list(res,-1);
    d05a:	4620      	mov	r0, r4
    d05c:	f7ff fda8 	bl	cbb0 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d060:	8f21      	ldrh	r1, [r4, #56]	; 0x38
    d062:	f001 faab 	bl	e5bc <crcu16>
    d066:	8720      	strh	r0, [r4, #56]	; 0x38
        if (i==0) res->crclist=res->crc;
    d068:	b125      	cbz	r5, d074 <iterate+0x3c>
    for (i=0; i<iterations; i++) {
    d06a:	3501      	adds	r5, #1
    d06c:	42ae      	cmp	r6, r5
    d06e:	d1ea      	bne.n	d046 <iterate+0xe>
    }
    return NULL;
}
    d070:	2000      	movs	r0, #0
    d072:	bd70      	pop	{r4, r5, r6, pc}
    for (i=0; i<iterations; i++) {
    d074:	2e01      	cmp	r6, #1
        if (i==0) res->crclist=res->crc;
    d076:	8760      	strh	r0, [r4, #58]	; 0x3a
    for (i=0; i<iterations; i++) {
    d078:	d0fa      	beq.n	d070 <iterate+0x38>
    d07a:	2501      	movs	r5, #1
    d07c:	e7e3      	b.n	d046 <iterate+0xe>
    d07e:	bf00      	nop

0000d080 <main>:
    4 - Iterations  : Special, if set to 0, iterations will be automatically determined such that the benchmark will run between 10 to 100 secs

*/

#if MAIN_HAS_NOARGC
MAIN_RETURN_TYPE main(void) {
    d080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d084:	ed2d 8b04 	vpush	{d8-d9}
    d088:	f6ad 0d3c 	subw	sp, sp, #2108	; 0x83c
    core_results results[MULTITHREAD];
#if (MEM_METHOD==MEM_STACK)
    ee_u8 stack_memblock[TOTAL_DATA_SIZE*MULTITHREAD];
#endif
    /* first call any initializations needed */
    portable_init(&(results[0].port), &argc, argv);
    d08c:	aa08      	add	r2, sp, #32
    d08e:	a907      	add	r1, sp, #28
    int argc=0;
    d090:	2300      	movs	r3, #0
    portable_init(&(results[0].port), &argc, argv);
    d092:	f10d 0066 	add.w	r0, sp, #102	; 0x66
    int argc=0;
    d096:	9307      	str	r3, [sp, #28]
    portable_init(&(results[0].port), &argc, argv);
    d098:	f000 ff26 	bl	dee8 <portable_init>
    /* First some checks to make sure benchmark will run ok */
    if (sizeof(struct list_head_s)>128) {
        ee_printf("list_head structure too big for comparable data!\n");
        return MAIN_RETURN_VAL;
    }
    results[0].seed1=get_seed(1);
    d09c:	2001      	movs	r0, #1
    d09e:	f001 fa69 	bl	e574 <get_seed_32>
    d0a2:	4603      	mov	r3, r0
    results[0].seed2=get_seed(2);
    d0a4:	2002      	movs	r0, #2
    results[0].seed1=get_seed(1);
    d0a6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    results[0].seed2=get_seed(2);
    d0aa:	f001 fa63 	bl	e574 <get_seed_32>
    d0ae:	4603      	mov	r3, r0
    results[0].seed3=get_seed(3);
    d0b0:	2003      	movs	r0, #3
    results[0].seed2=get_seed(2);
    d0b2:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
    results[0].seed3=get_seed(3);
    d0b6:	f001 fa5d 	bl	e574 <get_seed_32>
    d0ba:	4603      	mov	r3, r0
    results[0].iterations=get_seed_32(4);
    d0bc:	2004      	movs	r0, #4
    results[0].seed3=get_seed(3);
    d0be:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    results[0].iterations=get_seed_32(4);
    d0c2:	f001 fa57 	bl	e574 <get_seed_32>
    d0c6:	4603      	mov	r3, r0
#if CORE_DEBUG
    results[0].iterations=1;
#endif
    results[0].execs=get_seed_32(5);
    d0c8:	2005      	movs	r0, #5
    results[0].iterations=get_seed_32(4);
    d0ca:	9310      	str	r3, [sp, #64]	; 0x40
    results[0].execs=get_seed_32(5);
    d0cc:	f001 fa52 	bl	e574 <get_seed_32>
    if (results[0].execs==0) { /* if not supplied, execute all algorithms */
    d0d0:	2800      	cmp	r0, #0
    d0d2:	f000 8265 	beq.w	d5a0 <main+0x520>
    results[0].execs=get_seed_32(5);
    d0d6:	9011      	str	r0, [sp, #68]	; 0x44
        results[0].execs=ALL_ALGORITHMS_MASK;
    }
        /* put in some default values based on one seed only for easy testing */
    if ((results[0].seed1==0) && (results[0].seed2==0) && (results[0].seed3==0)) { /* validation run */
    d0d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d0da:	2b00      	cmp	r3, #0
    d0dc:	f040 8252 	bne.w	d584 <main+0x504>
    d0e0:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
    d0e4:	2b00      	cmp	r3, #0
    d0e6:	f000 8270 	beq.w	d5ca <main+0x54a>
#error "Please define a way to initialize a memory block."
#endif
    /* Data init */
    /* Find out how space much we have based on number of algorithms */
    for (i=0; i<NUM_ALGORITHMS; i++) {
        if ((1<<(ee_u32)i) & results[0].execs)
    d0ea:	9b11      	ldr	r3, [sp, #68]	; 0x44
        results[i].err=0;
    d0ec:	2200      	movs	r2, #0
        if ((1<<(ee_u32)i) & results[0].execs)
    d0ee:	f003 0401 	and.w	r4, r3, #1
        results[i].err=0;
    d0f2:	f8ad 2064 	strh.w	r2, [sp, #100]	; 0x64
        if ((1<<(ee_u32)i) & results[0].execs)
    d0f6:	4620      	mov	r0, r4
    d0f8:	f013 0202 	ands.w	r2, r3, #2
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    d0fc:	a91a      	add	r1, sp, #104	; 0x68
            num_algorithms++;
    d0fe:	bf18      	it	ne
    d100:	3001      	addne	r0, #1
        if ((1<<(ee_u32)i) & results[0].execs)
    d102:	f013 0504 	ands.w	r5, r3, #4
        results[i].memblock[0]=stack_memblock+i*TOTAL_DATA_SIZE;
    d106:	910b      	str	r1, [sp, #44]	; 0x2c
        if ((1<<(ee_u32)i) & results[0].execs)
    d108:	d001      	beq.n	d10e <main+0x8e>
            num_algorithms++;
    d10a:	3001      	adds	r0, #1
    d10c:	b280      	uxth	r0, r0
    }
    for (i=0 ; i<MULTITHREAD; i++)
        results[i].size=results[i].size/num_algorithms;
    d10e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
    d112:	fbb1 f0f0 	udiv	r0, r1, r0
    d116:	900f      	str	r0, [sp, #60]	; 0x3c
    /* Assign pointers */
    for (i=0; i<NUM_ALGORITHMS; i++) {
        ee_u32 ctx;
        if ((1<<(ee_u32)i) & results[0].execs) {
    d118:	2c00      	cmp	r4, #0
    d11a:	f040 8282 	bne.w	d622 <main+0x5a2>
    ee_u16 i,j=0,num_algorithms=0;
    d11e:	4621      	mov	r1, r4
        if ((1<<(ee_u32)i) & results[0].execs) {
    d120:	2a00      	cmp	r2, #0
    d122:	f040 8248 	bne.w	d5b6 <main+0x536>
    d126:	2d00      	cmp	r5, #0
    d128:	f040 823d 	bne.w	d5a6 <main+0x526>
            j++;
        }
    }
    /* call inits */
    for (i=0 ; i<MULTITHREAD; i++) {
        if (results[i].execs & ID_LIST) {
    d12c:	2c00      	cmp	r4, #0
    d12e:	f040 8100 	bne.w	d332 <main+0x2b2>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
        }
        if (results[i].execs & ID_MATRIX) {
    d132:	2a00      	cmp	r2, #0
    d134:	f040 8109 	bne.w	d34a <main+0x2ca>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
        }
        if (results[i].execs & ID_STATE) {
    d138:	0758      	lsls	r0, r3, #29
    d13a:	d505      	bpl.n	d148 <main+0xc8>
            core_init_state(results[0].size,results[i].seed1,results[i].memblock[3]);
    d13c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    d13e:	f9bd 1024 	ldrsh.w	r1, [sp, #36]	; 0x24
    d142:	980f      	ldr	r0, [sp, #60]	; 0x3c
    d144:	f001 f80e 	bl	e164 <core_init_state>
        }
    }

    /* automatically determine number of iterations if not set */
    if (results[0].iterations==0) {
    d148:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    d14c:	f1b8 0f00 	cmp.w	r8, #0
    d150:	d14a      	bne.n	d1e8 <main+0x168>
        secs_ret secs_passed=0;
        ee_u32 divisor;
        results[0].iterations=1;
    d152:	2301      	movs	r3, #1
        while (secs_passed < (secs_ret)1) {
    d154:	4d87      	ldr	r5, [pc, #540]	; (d374 <main+0x2f4>)
        results[0].iterations=1;
    d156:	9310      	str	r3, [sp, #64]	; 0x40
        while (secs_passed < (secs_ret)1) {
    d158:	2400      	movs	r4, #0
            results[0].iterations*=10;
    d15a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d15c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    d160:	005b      	lsls	r3, r3, #1
    d162:	9310      	str	r3, [sp, #64]	; 0x40
            start_time();
    d164:	f000 fe6c 	bl	de40 <start_time>
    ee_u32 iterations=res->iterations;
    d168:	9f10      	ldr	r7, [sp, #64]	; 0x40
    res->crc=0;
    d16a:	e9cd 8817 	strd	r8, r8, [sp, #92]	; 0x5c
    for (i=0; i<iterations; i++) {
    d16e:	2600      	movs	r6, #0
    d170:	b1df      	cbz	r7, d1aa <main+0x12a>
        crc=core_bench_list(res,1);
    d172:	2101      	movs	r1, #1
    d174:	a809      	add	r0, sp, #36	; 0x24
    d176:	f7ff fd1b 	bl	cbb0 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d17a:	f8bd 105c 	ldrh.w	r1, [sp, #92]	; 0x5c
    d17e:	f001 fa1d 	bl	e5bc <crcu16>
        crc=core_bench_list(res,-1);
    d182:	f04f 31ff 	mov.w	r1, #4294967295
        res->crc=crcu16(crc,res->crc);
    d186:	4603      	mov	r3, r0
        crc=core_bench_list(res,-1);
    d188:	a809      	add	r0, sp, #36	; 0x24
        res->crc=crcu16(crc,res->crc);
    d18a:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
        crc=core_bench_list(res,-1);
    d18e:	f7ff fd0f 	bl	cbb0 <core_bench_list>
        res->crc=crcu16(crc,res->crc);
    d192:	f8bd 105c 	ldrh.w	r1, [sp, #92]	; 0x5c
    d196:	f001 fa11 	bl	e5bc <crcu16>
    d19a:	f8ad 005c 	strh.w	r0, [sp, #92]	; 0x5c
        if (i==0) res->crclist=res->crc;
    d19e:	2e00      	cmp	r6, #0
    d1a0:	f000 80e0 	beq.w	d364 <main+0x2e4>
    for (i=0; i<iterations; i++) {
    d1a4:	3601      	adds	r6, #1
    d1a6:	42b7      	cmp	r7, r6
    d1a8:	d1e3      	bne.n	d172 <main+0xf2>
            iterate(&results[0]);
            stop_time();
    d1aa:	f000 fe65 	bl	de78 <stop_time>
            secs_passed=time_in_secs(get_time());
    d1ae:	f000 fe81 	bl	deb4 <get_time>
    d1b2:	f000 fe89 	bl	dec8 <time_in_secs>
    d1b6:	ec57 6b10 	vmov	r6, r7, d0
        while (secs_passed < (secs_ret)1) {
    d1ba:	ee10 0a10 	vmov	r0, s0
    d1be:	4622      	mov	r2, r4
    d1c0:	462b      	mov	r3, r5
    d1c2:	4639      	mov	r1, r7
    d1c4:	f7ff fbca 	bl	c95c <__aeabi_dcmplt>
    d1c8:	2800      	cmp	r0, #0
    d1ca:	d1c6      	bne.n	d15a <main+0xda>
        }
        /* now we know it executes for at least 1 sec, set actual run time at about 10 secs */
        divisor=(ee_u32)secs_passed;
    d1cc:	4639      	mov	r1, r7
    d1ce:	4630      	mov	r0, r6
    d1d0:	f7ff fbec 	bl	c9ac <__aeabi_d2uiz>
        if (divisor==0) /* some machines cast float to int as 0 since this conversion is not defined by ANSI, but we know at least one second passed */
            divisor=1;
        results[0].iterations*=1+10/divisor;
    d1d4:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d1d6:	2801      	cmp	r0, #1
    d1d8:	bf38      	it	cc
    d1da:	2001      	movcc	r0, #1
    d1dc:	210a      	movs	r1, #10
    d1de:	fbb1 f2f0 	udiv	r2, r1, r0
    d1e2:	fb02 3303 	mla	r3, r2, r3, r3
    d1e6:	9310      	str	r3, [sp, #64]	; 0x40
    }
    /* perform actual benchmark */
    start_time();
    d1e8:	f000 fe2a 	bl	de40 <start_time>
    }
    for (i=0 ; i<default_num_contexts; i++) {
        core_stop_parallel(&results[i]);
    }
#else
    iterate(&results[0]);
    d1ec:	a809      	add	r0, sp, #36	; 0x24
    d1ee:	f7ff ff23 	bl	d038 <iterate>
#endif
    stop_time();
    d1f2:	f000 fe41 	bl	de78 <stop_time>
    total_time=get_time();
    d1f6:	f000 fe5d 	bl	deb4 <get_time>
    /* get a function of the input to report */
    seedcrc=crc16(results[0].seed1,seedcrc);
    d1fa:	2100      	movs	r1, #0
    total_time=get_time();
    d1fc:	4681      	mov	r9, r0
    seedcrc=crc16(results[0].seed1,seedcrc);
    d1fe:	f9bd 0024 	ldrsh.w	r0, [sp, #36]	; 0x24
    d202:	f001 fbc5 	bl	e990 <crc16>
    d206:	4601      	mov	r1, r0
    seedcrc=crc16(results[0].seed2,seedcrc);
    d208:	f9bd 0026 	ldrsh.w	r0, [sp, #38]	; 0x26
    d20c:	f001 fbc0 	bl	e990 <crc16>
    d210:	4601      	mov	r1, r0
    seedcrc=crc16(results[0].seed3,seedcrc);
    d212:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
    d216:	f001 fbbb 	bl	e990 <crc16>
    d21a:	4601      	mov	r1, r0
    seedcrc=crc16(results[0].size,seedcrc);
    d21c:	f9bd 003c 	ldrsh.w	r0, [sp, #60]	; 0x3c
    d220:	f001 fbb6 	bl	e990 <crc16>

    switch (seedcrc) { /* test known output for common seeds */
    d224:	f647 3305 	movw	r3, #31493	; 0x7b05
    d228:	4298      	cmp	r0, r3
    seedcrc=crc16(results[0].size,seedcrc);
    d22a:	4680      	mov	r8, r0
    switch (seedcrc) { /* test known output for common seeds */
    d22c:	f000 8252 	beq.w	d6d4 <main+0x654>
    d230:	f200 818c 	bhi.w	d54c <main+0x4cc>
    d234:	f641 03f2 	movw	r3, #6386	; 0x18f2
    d238:	4298      	cmp	r0, r3
    d23a:	f000 825e 	beq.w	d6fa <main+0x67a>
    d23e:	f644 63af 	movw	r3, #20143	; 0x4eaf
    d242:	4298      	cmp	r0, r3
    d244:	f040 8270 	bne.w	d728 <main+0x6a8>
            known_id=1;
            ee_printf("6k validation run parameters for coremark.\n");
            break;
        case 0x4eaf: /* seed1=0x8, seed2=0x8, seed3=0x8, size 400 per algorithm */
            known_id=2;
            ee_printf("Profile generation run parameters for coremark.\n");
    d248:	484b      	ldr	r0, [pc, #300]	; (d378 <main+0x2f8>)
    d24a:	f000 ff45 	bl	e0d8 <am_sprintf>
    d24e:	f245 6308 	movw	r3, #22024	; 0x5608
    d252:	f646 2279 	movw	r2, #27257	; 0x6a79
    d256:	ee08 3a90 	vmov	s17, r3
    d25a:	f24e 5ba4 	movw	fp, #58788	; 0xe5a4
    d25e:	4619      	mov	r1, r3
    d260:	ee08 2a10 	vmov	s16, r2
            known_id=2;
    d264:	2302      	movs	r3, #2
            ee_printf("Profile generation run parameters for coremark.\n");
    d266:	f8cd b00c 	str.w	fp, [sp, #12]
            known_id=2;
    d26a:	9305      	str	r3, [sp, #20]
        default:
            total_errors=-1;
            break;
    }
    if (known_id>=0) {
        for (i=0 ; i<default_num_contexts; i++) {
    d26c:	4f43      	ldr	r7, [pc, #268]	; (d37c <main+0x2fc>)
    d26e:	683d      	ldr	r5, [r7, #0]
    d270:	2d00      	cmp	r5, #0
    d272:	f000 808f 	beq.w	d394 <main+0x314>
    d276:	2400      	movs	r4, #0
    d278:	ee09 9a10 	vmov	s18, r9
    d27c:	f8cd 8010 	str.w	r8, [sp, #16]
    d280:	4691      	mov	r9, r2
    d282:	46a0      	mov	r8, r4
    d284:	468a      	mov	sl, r1
    d286:	e018      	b.n	d2ba <main+0x23a>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
                results[i].err++;
            }
            if ((results[i].execs & ID_STATE) &&
                (results[i].crcstate!=state_known_crc[known_id])) {
    d288:	8fea      	ldrh	r2, [r5, #62]	; 0x3e
            if ((results[i].execs & ID_STATE) &&
    d28a:	9b03      	ldr	r3, [sp, #12]
    d28c:	429a      	cmp	r2, r3
    d28e:	d04d      	beq.n	d32c <main+0x2ac>
                ee_printf("[%u]ERROR! state crc 0x%04x - should be 0x%04x\n",i,results[i].crcstate,state_known_crc[known_id]);
    d290:	465b      	mov	r3, fp
    d292:	483b      	ldr	r0, [pc, #236]	; (d380 <main+0x300>)
    d294:	4641      	mov	r1, r8
    d296:	f000 ff1f 	bl	e0d8 <am_sprintf>
                results[i].err++;
    d29a:	f8b5 3040 	ldrh.w	r3, [r5, #64]	; 0x40
    d29e:	3301      	adds	r3, #1
    d2a0:	b29b      	uxth	r3, r3
    d2a2:	f8a5 3040 	strh.w	r3, [r5, #64]	; 0x40
            }
            total_errors+=results[i].err;
    d2a6:	441c      	add	r4, r3
        for (i=0 ; i<default_num_contexts; i++) {
    d2a8:	f108 0101 	add.w	r1, r8, #1
    d2ac:	683b      	ldr	r3, [r7, #0]
    d2ae:	fa1f f881 	uxth.w	r8, r1
    d2b2:	4598      	cmp	r8, r3
            total_errors+=results[i].err;
    d2b4:	b2a5      	uxth	r5, r4
    d2b6:	b224      	sxth	r4, r4
        for (i=0 ; i<default_num_contexts; i++) {
    d2b8:	d268      	bcs.n	d38c <main+0x30c>
            results[i].err=0;
    d2ba:	ab09      	add	r3, sp, #36	; 0x24
    d2bc:	eb08 1608 	add.w	r6, r8, r8, lsl #4
    d2c0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    d2c4:	2300      	movs	r3, #0
    d2c6:	f8a6 3040 	strh.w	r3, [r6, #64]	; 0x40
            if ((results[i].execs & ID_LIST) &&
    d2ca:	6a33      	ldr	r3, [r6, #32]
    d2cc:	07d9      	lsls	r1, r3, #31
            results[i].err=0;
    d2ce:	ea4f 1508 	mov.w	r5, r8, lsl #4
            if ((results[i].execs & ID_LIST) &&
    d2d2:	d50d      	bpl.n	d2f0 <main+0x270>
                (results[i].crclist!=list_known_crc[known_id])) {
    d2d4:	8f72      	ldrh	r2, [r6, #58]	; 0x3a
            if ((results[i].execs & ID_LIST) &&
    d2d6:	454a      	cmp	r2, r9
    d2d8:	d00a      	beq.n	d2f0 <main+0x270>
                ee_printf("[%u]ERROR! list crc 0x%04x - should be 0x%04x\n",i,results[i].crclist,list_known_crc[known_id]);
    d2da:	ee18 3a10 	vmov	r3, s16
    d2de:	4829      	ldr	r0, [pc, #164]	; (d384 <main+0x304>)
    d2e0:	4641      	mov	r1, r8
    d2e2:	f000 fef9 	bl	e0d8 <am_sprintf>
                results[i].err++;
    d2e6:	f8b6 3040 	ldrh.w	r3, [r6, #64]	; 0x40
    d2ea:	3301      	adds	r3, #1
    d2ec:	f8a6 3040 	strh.w	r3, [r6, #64]	; 0x40
            if ((results[i].execs & ID_MATRIX) &&
    d2f0:	ab09      	add	r3, sp, #36	; 0x24
    d2f2:	eb05 0608 	add.w	r6, r5, r8
    d2f6:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    d2fa:	6a33      	ldr	r3, [r6, #32]
    d2fc:	079a      	lsls	r2, r3, #30
    d2fe:	d50e      	bpl.n	d31e <main+0x29e>
                (results[i].crcmatrix!=matrix_known_crc[known_id])) {
    d300:	8fb2      	ldrh	r2, [r6, #60]	; 0x3c
            if ((results[i].execs & ID_MATRIX) &&
    d302:	4552      	cmp	r2, sl
    d304:	d00b      	beq.n	d31e <main+0x29e>
                ee_printf("[%u]ERROR! matrix crc 0x%04x - should be 0x%04x\n",i,results[i].crcmatrix,matrix_known_crc[known_id]);
    d306:	ee18 3a90 	vmov	r3, s17
    d30a:	481f      	ldr	r0, [pc, #124]	; (d388 <main+0x308>)
    d30c:	4641      	mov	r1, r8
    d30e:	f000 fee3 	bl	e0d8 <am_sprintf>
                results[i].err++;
    d312:	f8b6 3040 	ldrh.w	r3, [r6, #64]	; 0x40
    d316:	3301      	adds	r3, #1
    d318:	f8a6 3040 	strh.w	r3, [r6, #64]	; 0x40
            if ((results[i].execs & ID_STATE) &&
    d31c:	6a33      	ldr	r3, [r6, #32]
                (results[i].crcstate!=state_known_crc[known_id])) {
    d31e:	4445      	add	r5, r8
            if ((results[i].execs & ID_STATE) &&
    d320:	f013 0f04 	tst.w	r3, #4
                (results[i].crcstate!=state_known_crc[known_id])) {
    d324:	ab09      	add	r3, sp, #36	; 0x24
    d326:	eb03 0585 	add.w	r5, r3, r5, lsl #2
            if ((results[i].execs & ID_STATE) &&
    d32a:	d1ad      	bne.n	d288 <main+0x208>
            total_errors+=results[i].err;
    d32c:	f8b5 3040 	ldrh.w	r3, [r5, #64]	; 0x40
    d330:	e7b9      	b.n	d2a6 <main+0x226>
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
    d332:	f9bd 2024 	ldrsh.w	r2, [sp, #36]	; 0x24
    d336:	990c      	ldr	r1, [sp, #48]	; 0x30
    d338:	f7ff fda6 	bl	ce88 <core_list_init>
        if (results[i].execs & ID_MATRIX) {
    d33c:	9b11      	ldr	r3, [sp, #68]	; 0x44
            results[i].list=core_list_init(results[0].size,results[i].memblock[1],results[i].seed1);
    d33e:	9012      	str	r0, [sp, #72]	; 0x48
    d340:	f003 0202 	and.w	r2, r3, #2
        if (results[i].execs & ID_MATRIX) {
    d344:	2a00      	cmp	r2, #0
    d346:	f43f aef7 	beq.w	d138 <main+0xb8>
            core_init_matrix(results[0].size, results[i].memblock[2], (ee_s32)results[i].seed1 | (((ee_s32)results[i].seed2) << 16), &(results[i].mat) );
    d34a:	f9bd 4026 	ldrsh.w	r4, [sp, #38]	; 0x26
    d34e:	f9bd 2024 	ldrsh.w	r2, [sp, #36]	; 0x24
    d352:	990d      	ldr	r1, [sp, #52]	; 0x34
    d354:	980f      	ldr	r0, [sp, #60]	; 0x3c
    d356:	ab13      	add	r3, sp, #76	; 0x4c
    d358:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
    d35c:	f000 fd02 	bl	dd64 <core_init_matrix>
        if (results[i].execs & ID_STATE) {
    d360:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d362:	e6e9      	b.n	d138 <main+0xb8>
    for (i=0; i<iterations; i++) {
    d364:	2f01      	cmp	r7, #1
        if (i==0) res->crclist=res->crc;
    d366:	f8ad 005e 	strh.w	r0, [sp, #94]	; 0x5e
    for (i=0; i<iterations; i++) {
    d36a:	f43f af1e 	beq.w	d1aa <main+0x12a>
    d36e:	2601      	movs	r6, #1
    d370:	e6ff      	b.n	d172 <main+0xf2>
    d372:	bf00      	nop
    d374:	3ff00000 	.word	0x3ff00000
    d378:	000110c0 	.word	0x000110c0
    d37c:	10001000 	.word	0x10001000
    d380:	000111b4 	.word	0x000111b4
    d384:	00011150 	.word	0x00011150
    d388:	00011180 	.word	0x00011180
    d38c:	ee19 9a10 	vmov	r9, s18
    d390:	f8dd 8010 	ldr.w	r8, [sp, #16]
        }
    }
    total_errors+=check_data_types();
    d394:	f001 fb9a 	bl	eacc <check_data_types>
    /* and report results */
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    d398:	990f      	ldr	r1, [sp, #60]	; 0x3c
    total_errors+=check_data_types();
    d39a:	4405      	add	r5, r0
    ee_printf("CoreMark Size    : %lu\n",(ee_u32)results[0].size);
    d39c:	48b1      	ldr	r0, [pc, #708]	; (d664 <main+0x5e4>)
    d39e:	f000 fe9b 	bl	e0d8 <am_sprintf>
    ee_printf("Total ticks      : %llu\n",(ee_u64)total_time);
    d3a2:	464a      	mov	r2, r9
    d3a4:	2300      	movs	r3, #0
    d3a6:	48b0      	ldr	r0, [pc, #704]	; (d668 <main+0x5e8>)
    d3a8:	f000 fe96 	bl	e0d8 <am_sprintf>
#if HAS_FLOAT
    ee_printf("Total time (secs): %f\n",time_in_secs(total_time));
    d3ac:	4648      	mov	r0, r9
    d3ae:	f000 fd8b 	bl	dec8 <time_in_secs>
    d3b2:	48ae      	ldr	r0, [pc, #696]	; (d66c <main+0x5ec>)
    d3b4:	ec53 2b10 	vmov	r2, r3, d0
    d3b8:	f000 fe8e 	bl	e0d8 <am_sprintf>
    if (time_in_secs(total_time) > 0)
    d3bc:	4648      	mov	r0, r9
    d3be:	f000 fd83 	bl	dec8 <time_in_secs>
    d3c2:	2200      	movs	r2, #0
    d3c4:	ec51 0b10 	vmov	r0, r1, d0
    d3c8:	2300      	movs	r3, #0
    total_errors+=check_data_types();
    d3ca:	b2ae      	uxth	r6, r5
    if (time_in_secs(total_time) > 0)
    d3cc:	f7ff fae4 	bl	c998 <__aeabi_dcmpgt>
    d3d0:	b1a8      	cbz	r0, d3fe <main+0x37e>
        ee_printf("Iterations/Sec   : %f\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
    d3d2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d3d4:	6838      	ldr	r0, [r7, #0]
    d3d6:	fb03 f000 	mul.w	r0, r3, r0
    d3da:	f7fe ffd3 	bl	c384 <__aeabi_ui2d>
    d3de:	4604      	mov	r4, r0
    d3e0:	4648      	mov	r0, r9
    d3e2:	460d      	mov	r5, r1
    d3e4:	f000 fd70 	bl	dec8 <time_in_secs>
    d3e8:	4620      	mov	r0, r4
    d3ea:	ec53 2b10 	vmov	r2, r3, d0
    d3ee:	4629      	mov	r1, r5
    d3f0:	f7ff f96c 	bl	c6cc <__aeabi_ddiv>
    d3f4:	4602      	mov	r2, r0
    d3f6:	460b      	mov	r3, r1
    d3f8:	489d      	ldr	r0, [pc, #628]	; (d670 <main+0x5f0>)
    d3fa:	f000 fe6d 	bl	e0d8 <am_sprintf>
#else
    ee_printf("Total time (secs): %d\n",time_in_secs(total_time));
    if (time_in_secs(total_time) > 0)
        ee_printf("Iterations/Sec   : %d\n",default_num_contexts*results[0].iterations/time_in_secs(total_time));
#endif
    if (time_in_secs(total_time) < 10) {
    d3fe:	4648      	mov	r0, r9
    d400:	f000 fd62 	bl	dec8 <time_in_secs>
    d404:	4b9b      	ldr	r3, [pc, #620]	; (d674 <main+0x5f4>)
    d406:	ec51 0b10 	vmov	r0, r1, d0
    d40a:	2200      	movs	r2, #0
    d40c:	f7ff faa6 	bl	c95c <__aeabi_dcmplt>
    d410:	2800      	cmp	r0, #0
    d412:	f040 810d 	bne.w	d630 <main+0x5b0>
    total_errors+=check_data_types();
    d416:	b235      	sxth	r5, r6
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
        total_errors++;
    }

    ee_printf("Iterations       : %lu\n",(ee_u32)default_num_contexts*results[0].iterations);
    d418:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d41a:	6839      	ldr	r1, [r7, #0]
    d41c:	4896      	ldr	r0, [pc, #600]	; (d678 <main+0x5f8>)
    d41e:	fb03 f101 	mul.w	r1, r3, r1
    d422:	f000 fe59 	bl	e0d8 <am_sprintf>
    ee_printf("Compiler version : %s\n",COMPILER_VERSION);
    d426:	4995      	ldr	r1, [pc, #596]	; (d67c <main+0x5fc>)
    d428:	4895      	ldr	r0, [pc, #596]	; (d680 <main+0x600>)
    d42a:	f000 fe55 	bl	e0d8 <am_sprintf>
//  ee_printf("Compiler flags   : %s\n",COMPILER_FLAGS);
#if (MULTITHREAD>1)
    ee_printf("Parallel %s : %d\n",PARALLEL_METHOD,default_num_contexts);
#endif
    ee_printf("Memory location  : %s\n",MEM_LOCATION);
    d42e:	4995      	ldr	r1, [pc, #596]	; (d684 <main+0x604>)
    d430:	4895      	ldr	r0, [pc, #596]	; (d688 <main+0x608>)
    d432:	f000 fe51 	bl	e0d8 <am_sprintf>
    /* output for verification */
    ee_printf("seedcrc          : 0x%04x\n",seedcrc);
    d436:	4895      	ldr	r0, [pc, #596]	; (d68c <main+0x60c>)
    d438:	4641      	mov	r1, r8
    d43a:	f000 fe4d 	bl	e0d8 <am_sprintf>
    if (results[0].execs & ID_LIST)
    d43e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d440:	07d8      	lsls	r0, r3, #31
    d442:	d512      	bpl.n	d46a <main+0x3ea>
        for (i=0 ; i<default_num_contexts; i++)
    d444:	683b      	ldr	r3, [r7, #0]
    d446:	b183      	cbz	r3, d46a <main+0x3ea>
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    d448:	4e91      	ldr	r6, [pc, #580]	; (d690 <main+0x610>)
        for (i=0 ; i<default_num_contexts; i++)
    d44a:	2400      	movs	r4, #0
            ee_printf("[%d]crclist       : 0x%04x\n",i,results[i].crclist);
    d44c:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    d450:	aa09      	add	r2, sp, #36	; 0x24
    d452:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d456:	4621      	mov	r1, r4
    d458:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
    d45a:	4630      	mov	r0, r6
    d45c:	f000 fe3c 	bl	e0d8 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    d460:	3401      	adds	r4, #1
    d462:	683b      	ldr	r3, [r7, #0]
    d464:	b2a4      	uxth	r4, r4
    d466:	429c      	cmp	r4, r3
    d468:	d3f0      	bcc.n	d44c <main+0x3cc>
    if (results[0].execs & ID_MATRIX)
    d46a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d46c:	0799      	lsls	r1, r3, #30
    d46e:	d514      	bpl.n	d49a <main+0x41a>
        for (i=0 ; i<default_num_contexts; i++)
    d470:	683a      	ldr	r2, [r7, #0]
    d472:	2a00      	cmp	r2, #0
    d474:	f000 8154 	beq.w	d720 <main+0x6a0>
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    d478:	4e86      	ldr	r6, [pc, #536]	; (d694 <main+0x614>)
        for (i=0 ; i<default_num_contexts; i++)
    d47a:	2400      	movs	r4, #0
            ee_printf("[%d]crcmatrix     : 0x%04x\n",i,results[i].crcmatrix);
    d47c:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    d480:	aa09      	add	r2, sp, #36	; 0x24
    d482:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d486:	4621      	mov	r1, r4
    d488:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
    d48a:	4630      	mov	r0, r6
    d48c:	f000 fe24 	bl	e0d8 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    d490:	3401      	adds	r4, #1
    d492:	683b      	ldr	r3, [r7, #0]
    d494:	b2a4      	uxth	r4, r4
    d496:	429c      	cmp	r4, r3
    d498:	d3f0      	bcc.n	d47c <main+0x3fc>
    if (results[0].execs & ID_STATE)
    d49a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d49c:	075a      	lsls	r2, r3, #29
    d49e:	d512      	bpl.n	d4c6 <main+0x446>
        for (i=0 ; i<default_num_contexts; i++)
    d4a0:	683b      	ldr	r3, [r7, #0]
    d4a2:	b31b      	cbz	r3, d4ec <main+0x46c>
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    d4a4:	4e7c      	ldr	r6, [pc, #496]	; (d698 <main+0x618>)
        for (i=0 ; i<default_num_contexts; i++)
    d4a6:	2400      	movs	r4, #0
            ee_printf("[%d]crcstate      : 0x%04x\n",i,results[i].crcstate);
    d4a8:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    d4ac:	aa09      	add	r2, sp, #36	; 0x24
    d4ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d4b2:	4621      	mov	r1, r4
    d4b4:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    d4b6:	4630      	mov	r0, r6
    d4b8:	f000 fe0e 	bl	e0d8 <am_sprintf>
        for (i=0 ; i<default_num_contexts; i++)
    d4bc:	3401      	adds	r4, #1
    d4be:	683b      	ldr	r3, [r7, #0]
    d4c0:	b2a4      	uxth	r4, r4
    d4c2:	429c      	cmp	r4, r3
    d4c4:	d3f0      	bcc.n	d4a8 <main+0x428>
    for (i=0 ; i<default_num_contexts; i++)
    d4c6:	683b      	ldr	r3, [r7, #0]
    d4c8:	b183      	cbz	r3, d4ec <main+0x46c>
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    d4ca:	4e74      	ldr	r6, [pc, #464]	; (d69c <main+0x61c>)
    for (i=0 ; i<default_num_contexts; i++)
    d4cc:	2400      	movs	r4, #0
        ee_printf("[%d]crcfinal      : 0x%04x\n",i,results[i].crc);
    d4ce:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    d4d2:	aa09      	add	r2, sp, #36	; 0x24
    d4d4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d4d8:	4621      	mov	r1, r4
    d4da:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
    d4dc:	4630      	mov	r0, r6
    d4de:	f000 fdfb 	bl	e0d8 <am_sprintf>
    for (i=0 ; i<default_num_contexts; i++)
    d4e2:	3401      	adds	r4, #1
    d4e4:	683b      	ldr	r3, [r7, #0]
    d4e6:	b2a4      	uxth	r4, r4
    d4e8:	429c      	cmp	r4, r3
    d4ea:	d3f0      	bcc.n	d4ce <main+0x44e>
    if (total_errors==0) {
    d4ec:	2d00      	cmp	r5, #0
    d4ee:	d070      	beq.n	d5d2 <main+0x552>
            ee_printf("\n");
        }
#endif
    }
    if (total_errors>0)
        ee_printf("Errors detected\n");
    d4f0:	bfcc      	ite	gt
    d4f2:	486b      	ldrgt	r0, [pc, #428]	; (d6a0 <main+0x620>)
    if (total_errors<0)
        ee_printf("Cannot validate operation for these seed values, please compare with results on a known platform.\n");
    d4f4:	486b      	ldrle	r0, [pc, #428]	; (d6a4 <main+0x624>)
    d4f6:	f000 fdef 	bl	e0d8 <am_sprintf>
        portable_free(results[i].memblock[0]);
#endif


#if AM_PRINT_RESULTS
    float CMResult = default_num_contexts*results[0].iterations/time_in_secs(total_time) / (double)AM_CORECLK_MHZ;
    d4fa:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d4fc:	6838      	ldr	r0, [r7, #0]
    d4fe:	fb03 f000 	mul.w	r0, r3, r0
    d502:	f7fe ff3f 	bl	c384 <__aeabi_ui2d>
    d506:	4604      	mov	r4, r0
    d508:	4648      	mov	r0, r9
    d50a:	460d      	mov	r5, r1
    d50c:	f000 fcdc 	bl	dec8 <time_in_secs>
    d510:	4620      	mov	r0, r4
    d512:	ec53 2b10 	vmov	r2, r3, d0
    d516:	4629      	mov	r1, r5
    d518:	f7ff f8d8 	bl	c6cc <__aeabi_ddiv>
    d51c:	4b62      	ldr	r3, [pc, #392]	; (d6a8 <main+0x628>)
    d51e:	2200      	movs	r2, #0
    d520:	f7ff f8d4 	bl	c6cc <__aeabi_ddiv>
    d524:	f7ff fa62 	bl	c9ec <__aeabi_d2f>
    ee_printf("CM/MHz=%.3f.\n", CMResult);
    d528:	f7fe ff4e 	bl	c3c8 <__aeabi_f2d>
    d52c:	4602      	mov	r2, r0
    d52e:	460b      	mov	r3, r1
    d530:	485e      	ldr	r0, [pc, #376]	; (d6ac <main+0x62c>)
    d532:	f000 fdd1 	bl	e0d8 <am_sprintf>

#endif //AM_PRINT_RESULTS

    /* And last call any target specific code for finalizing */
    portable_fini(&(results[0].port));
    d536:	f10d 0066 	add.w	r0, sp, #102	; 0x66
    d53a:	f000 fd43 	bl	dfc4 <portable_fini>

    return MAIN_RETURN_VAL;
}
    d53e:	2000      	movs	r0, #0
    d540:	f60d 0d3c 	addw	sp, sp, #2108	; 0x83c
    d544:	ecbd 8b04 	vpop	{d8-d9}
    d548:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (seedcrc) { /* test known output for common seeds */
    d54c:	f648 2302 	movw	r3, #35330	; 0x8a02
    d550:	4298      	cmp	r0, r3
    d552:	d073      	beq.n	d63c <main+0x5bc>
    d554:	f64e 13f5 	movw	r3, #59893	; 0xe9f5
    d558:	4298      	cmp	r0, r3
    d55a:	f040 80e5 	bne.w	d728 <main+0x6a8>
            ee_printf("2K performance run parameters for coremark.\n");
    d55e:	4854      	ldr	r0, [pc, #336]	; (d6b0 <main+0x630>)
    d560:	f000 fdba 	bl	e0d8 <am_sprintf>
    d564:	f641 73d7 	movw	r3, #8151	; 0x1fd7
    d568:	ee08 3a90 	vmov	s17, r3
    d56c:	f648 6b3a 	movw	fp, #36410	; 0x8e3a
    d570:	f24e 7214 	movw	r2, #59156	; 0xe714
    d574:	4619      	mov	r1, r3
            known_id=3;
    d576:	2303      	movs	r3, #3
            ee_printf("2K performance run parameters for coremark.\n");
    d578:	ee08 2a10 	vmov	s16, r2
    d57c:	f8cd b00c 	str.w	fp, [sp, #12]
            known_id=3;
    d580:	9305      	str	r3, [sp, #20]
    d582:	e673      	b.n	d26c <main+0x1ec>
    if ((results[0].seed1==1) && (results[0].seed2==0) && (results[0].seed3==0)) { /* perfromance run */
    d584:	2b01      	cmp	r3, #1
    d586:	f47f adb0 	bne.w	d0ea <main+0x6a>
    d58a:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
    d58e:	2b00      	cmp	r3, #0
    d590:	f47f adab 	bne.w	d0ea <main+0x6a>
        results[0].seed1=0x3415;
    d594:	4a47      	ldr	r2, [pc, #284]	; (d6b4 <main+0x634>)
    d596:	9209      	str	r2, [sp, #36]	; 0x24
        results[0].seed3=0x66;
    d598:	2366      	movs	r3, #102	; 0x66
    d59a:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    d59e:	e5a4      	b.n	d0ea <main+0x6a>
        results[0].execs=ALL_ALGORITHMS_MASK;
    d5a0:	2307      	movs	r3, #7
    d5a2:	9311      	str	r3, [sp, #68]	; 0x44
    d5a4:	e598      	b.n	d0d8 <main+0x58>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d5a6:	ad1a      	add	r5, sp, #104	; 0x68
    d5a8:	fb00 5101 	mla	r1, r0, r1, r5
    d5ac:	910e      	str	r1, [sp, #56]	; 0x38
        if (results[i].execs & ID_LIST) {
    d5ae:	2c00      	cmp	r4, #0
    d5b0:	f43f adbf 	beq.w	d132 <main+0xb2>
    d5b4:	e6bd      	b.n	d332 <main+0x2b2>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d5b6:	ae1a      	add	r6, sp, #104	; 0x68
    d5b8:	fb00 6601 	mla	r6, r0, r1, r6
            j++;
    d5bc:	3101      	adds	r1, #1
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d5be:	960d      	str	r6, [sp, #52]	; 0x34
            j++;
    d5c0:	b289      	uxth	r1, r1
        if ((1<<(ee_u32)i) & results[0].execs) {
    d5c2:	2d00      	cmp	r5, #0
    d5c4:	f43f adb2 	beq.w	d12c <main+0xac>
    d5c8:	e7ed      	b.n	d5a6 <main+0x526>
        results[0].seed3=0x66;
    d5ca:	2366      	movs	r3, #102	; 0x66
    d5cc:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
    if ((results[0].seed1==1) && (results[0].seed2==0) && (results[0].seed3==0)) { /* perfromance run */
    d5d0:	e58b      	b.n	d0ea <main+0x6a>
        ee_printf("Correct operation validated. See readme.txt for run and reporting rules.\n");
    d5d2:	4839      	ldr	r0, [pc, #228]	; (d6b8 <main+0x638>)
    d5d4:	f000 fd80 	bl	e0d8 <am_sprintf>
        if (known_id==3) {
    d5d8:	9b05      	ldr	r3, [sp, #20]
    d5da:	2b03      	cmp	r3, #3
    d5dc:	d18d      	bne.n	d4fa <main+0x47a>
            ee_printf("CoreMark 1.0 : %f / %s %s",default_num_contexts*results[0].iterations/time_in_secs(total_time),COMPILER_VERSION,COMPILER_FLAGS);
    d5de:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d5e0:	6838      	ldr	r0, [r7, #0]
    d5e2:	fb03 f000 	mul.w	r0, r3, r0
    d5e6:	f7fe fecd 	bl	c384 <__aeabi_ui2d>
    d5ea:	4604      	mov	r4, r0
    d5ec:	4648      	mov	r0, r9
    d5ee:	460d      	mov	r5, r1
    d5f0:	f000 fc6a 	bl	dec8 <time_in_secs>
    d5f4:	4620      	mov	r0, r4
    d5f6:	ec53 2b10 	vmov	r2, r3, d0
    d5fa:	4629      	mov	r1, r5
    d5fc:	f7ff f866 	bl	c6cc <__aeabi_ddiv>
    d600:	460b      	mov	r3, r1
    d602:	492e      	ldr	r1, [pc, #184]	; (d6bc <main+0x63c>)
    d604:	9101      	str	r1, [sp, #4]
    d606:	491d      	ldr	r1, [pc, #116]	; (d67c <main+0x5fc>)
    d608:	9100      	str	r1, [sp, #0]
    d60a:	4602      	mov	r2, r0
    d60c:	482c      	ldr	r0, [pc, #176]	; (d6c0 <main+0x640>)
    d60e:	f000 fd63 	bl	e0d8 <am_sprintf>
            ee_printf(" / %s",MEM_LOCATION);
    d612:	491c      	ldr	r1, [pc, #112]	; (d684 <main+0x604>)
    d614:	482b      	ldr	r0, [pc, #172]	; (d6c4 <main+0x644>)
    d616:	f000 fd5f 	bl	e0d8 <am_sprintf>
            ee_printf("\n");
    d61a:	482b      	ldr	r0, [pc, #172]	; (d6c8 <main+0x648>)
    d61c:	f000 fd5c 	bl	e0d8 <am_sprintf>
    d620:	e76b      	b.n	d4fa <main+0x47a>
                results[ctx].memblock[i+1]=(char *)(results[ctx].memblock[0])+results[0].size*j;
    d622:	a91a      	add	r1, sp, #104	; 0x68
    d624:	910c      	str	r1, [sp, #48]	; 0x30
            j++;
    d626:	2101      	movs	r1, #1
        if ((1<<(ee_u32)i) & results[0].execs) {
    d628:	2a00      	cmp	r2, #0
    d62a:	f43f ad7c 	beq.w	d126 <main+0xa6>
    d62e:	e7c2      	b.n	d5b6 <main+0x536>
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
    d630:	4826      	ldr	r0, [pc, #152]	; (d6cc <main+0x64c>)
        total_errors++;
    d632:	1c75      	adds	r5, r6, #1
        ee_printf("ERROR! Must execute for at least 10 secs for a valid result!\n");
    d634:	f000 fd50 	bl	e0d8 <am_sprintf>
        total_errors++;
    d638:	b22d      	sxth	r5, r5
    d63a:	e6ed      	b.n	d418 <main+0x398>
            ee_printf("6k performance run parameters for coremark.\n");
    d63c:	4824      	ldr	r0, [pc, #144]	; (d6d0 <main+0x650>)
    d63e:	f000 fd4b 	bl	e0d8 <am_sprintf>
    d642:	f64b 6352 	movw	r3, #48722	; 0xbe52
    d646:	ee08 3a90 	vmov	s17, r3
    d64a:	f645 6b47 	movw	fp, #24135	; 0x5e47
    d64e:	f24d 42b0 	movw	r2, #54448	; 0xd4b0
    d652:	4619      	mov	r1, r3
            known_id=0;
    d654:	2300      	movs	r3, #0
            ee_printf("6k performance run parameters for coremark.\n");
    d656:	ee08 2a10 	vmov	s16, r2
    d65a:	f8cd b00c 	str.w	fp, [sp, #12]
            known_id=0;
    d65e:	9305      	str	r3, [sp, #20]
    d660:	e604      	b.n	d26c <main+0x1ec>
    d662:	bf00      	nop
    d664:	000111e4 	.word	0x000111e4
    d668:	000111fc 	.word	0x000111fc
    d66c:	00011218 	.word	0x00011218
    d670:	00011230 	.word	0x00011230
    d674:	40240000 	.word	0x40240000
    d678:	00011288 	.word	0x00011288
    d67c:	000112a0 	.word	0x000112a0
    d680:	000112c0 	.word	0x000112c0
    d684:	000112d8 	.word	0x000112d8
    d688:	000112e0 	.word	0x000112e0
    d68c:	000112f8 	.word	0x000112f8
    d690:	00011314 	.word	0x00011314
    d694:	00011330 	.word	0x00011330
    d698:	0001134c 	.word	0x0001134c
    d69c:	00011368 	.word	0x00011368
    d6a0:	00011400 	.word	0x00011400
    d6a4:	00011414 	.word	0x00011414
    d6a8:	40480000 	.word	0x40480000
    d6ac:	00011478 	.word	0x00011478
    d6b0:	000110f4 	.word	0x000110f4
    d6b4:	34153415 	.word	0x34153415
    d6b8:	00011384 	.word	0x00011384
    d6bc:	000113ec 	.word	0x000113ec
    d6c0:	000113d0 	.word	0x000113d0
    d6c4:	000113f8 	.word	0x000113f8
    d6c8:	00011568 	.word	0x00011568
    d6cc:	00011248 	.word	0x00011248
    d6d0:	00011064 	.word	0x00011064
            ee_printf("6k validation run parameters for coremark.\n");
    d6d4:	4818      	ldr	r0, [pc, #96]	; (d738 <main+0x6b8>)
    d6d6:	f000 fcff 	bl	e0d8 <am_sprintf>
    d6da:	f241 1399 	movw	r3, #4505	; 0x1199
    d6de:	ee08 3a90 	vmov	s17, r3
    d6e2:	f643 1bbf 	movw	fp, #14783	; 0x39bf
    d6e6:	f44f 524d 	mov.w	r2, #13120	; 0x3340
    d6ea:	4619      	mov	r1, r3
            known_id=1;
    d6ec:	2301      	movs	r3, #1
            ee_printf("6k validation run parameters for coremark.\n");
    d6ee:	ee08 2a10 	vmov	s16, r2
    d6f2:	f8cd b00c 	str.w	fp, [sp, #12]
            known_id=1;
    d6f6:	9305      	str	r3, [sp, #20]
    d6f8:	e5b8      	b.n	d26c <main+0x1ec>
            ee_printf("2K validation run parameters for coremark.\n");
    d6fa:	4810      	ldr	r0, [pc, #64]	; (d73c <main+0x6bc>)
    d6fc:	f000 fcec 	bl	e0d8 <am_sprintf>
    d700:	f240 7347 	movw	r3, #1863	; 0x747
    d704:	ee08 3a90 	vmov	s17, r3
    d708:	f648 5b84 	movw	fp, #36228	; 0x8d84
    d70c:	f24e 32c1 	movw	r2, #58305	; 0xe3c1
    d710:	4619      	mov	r1, r3
            known_id=4;
    d712:	2304      	movs	r3, #4
            ee_printf("2K validation run parameters for coremark.\n");
    d714:	ee08 2a10 	vmov	s16, r2
    d718:	f8cd b00c 	str.w	fp, [sp, #12]
            known_id=4;
    d71c:	9305      	str	r3, [sp, #20]
    d71e:	e5a5      	b.n	d26c <main+0x1ec>
    if (results[0].execs & ID_STATE)
    d720:	075b      	lsls	r3, r3, #29
    d722:	f57f aed0 	bpl.w	d4c6 <main+0x446>
    d726:	e6e1      	b.n	d4ec <main+0x46c>
    switch (seedcrc) { /* test known output for common seeds */
    d728:	f04f 33ff 	mov.w	r3, #4294967295
    d72c:	4f04      	ldr	r7, [pc, #16]	; (d740 <main+0x6c0>)
    d72e:	9305      	str	r3, [sp, #20]
    d730:	f64f 75ff 	movw	r5, #65535	; 0xffff
    d734:	e62e      	b.n	d394 <main+0x314>
    d736:	bf00      	nop
    d738:	00011094 	.word	0x00011094
    d73c:	00011124 	.word	0x00011124
    d740:	10001000 	.word	0x10001000

0000d744 <matrix_test>:
    4 - Multiply a matrix by a matrix.
    5 - Add a constant value to all elements of a matrix.

    After the last step, matrix A is back to original contents.
*/
ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {
    d744:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d748:	ed2d 8b02 	vpush	{d8}
    d74c:	b08d      	sub	sp, #52	; 0x34
/* Function: matrix_add_const
    Add a constant value to all elements of a matrix.
*/
void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
    d74e:	4680      	mov	r8, r0
ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {
    d750:	f9bd e060 	ldrsh.w	lr, [sp, #96]	; 0x60
    d754:	9101      	str	r1, [sp, #4]
    d756:	9208      	str	r2, [sp, #32]
    d758:	9304      	str	r3, [sp, #16]
    for (i=0; i<N; i++) {
    d75a:	2800      	cmp	r0, #0
    d75c:	f000 82da 	beq.w	dd14 <matrix_test+0x5d0>
    d760:	ea6f 5b0e 	mvn.w	fp, lr, lsl #20
    d764:	ea6f 5b1b 	mvn.w	fp, fp, lsr #20
    d768:	1e41      	subs	r1, r0, #1
    d76a:	e9cd 1b05 	strd	r1, fp, [sp, #20]
        for (j=0; j<N; j++) {
            A[i*N+j] += val;
    d76e:	f04f 0a00 	mov.w	sl, #0
    d772:	0045      	lsls	r5, r0, #1
    d774:	fa1f f68e 	uxth.w	r6, lr
    d778:	f8cd e01c 	str.w	lr, [sp, #28]
    d77c:	9209      	str	r2, [sp, #36]	; 0x24
    for (i=0; i<N; i++) {
    d77e:	f8cd a008 	str.w	sl, [sp, #8]
    d782:	4691      	mov	r9, r2
    d784:	9503      	str	r5, [sp, #12]
    d786:	4696      	mov	lr, r2
        for (j=0; j<N; j++) {
    d788:	ea4f 0359 	mov.w	r3, r9, lsr #1
    d78c:	425b      	negs	r3, r3
    d78e:	f003 0303 	and.w	r3, r3, #3
    d792:	1cda      	adds	r2, r3, #3
    d794:	2a05      	cmp	r2, #5
    d796:	9905      	ldr	r1, [sp, #20]
    d798:	bf38      	it	cc
    d79a:	2205      	movcc	r2, #5
    d79c:	428a      	cmp	r2, r1
    d79e:	f200 82b7 	bhi.w	dd10 <matrix_test+0x5cc>
    d7a2:	2b00      	cmp	r3, #0
    d7a4:	d076      	beq.n	d894 <matrix_test+0x150>
            A[i*N+j] += val;
    d7a6:	f8b9 2000 	ldrh.w	r2, [r9]
    d7aa:	2b01      	cmp	r3, #1
    d7ac:	4432      	add	r2, r6
    d7ae:	f8a9 2000 	strh.w	r2, [r9]
        for (j=0; j<N; j++) {
    d7b2:	d06f      	beq.n	d894 <matrix_test+0x150>
            A[i*N+j] += val;
    d7b4:	f8b9 2002 	ldrh.w	r2, [r9, #2]
    d7b8:	2b03      	cmp	r3, #3
    d7ba:	4432      	add	r2, r6
    d7bc:	f8a9 2002 	strh.w	r2, [r9, #2]
        for (j=0; j<N; j++) {
    d7c0:	d16a      	bne.n	d898 <matrix_test+0x154>
            A[i*N+j] += val;
    d7c2:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    d7c6:	4432      	add	r2, r6
    d7c8:	f8a9 2004 	strh.w	r2, [r9, #4]
        for (j=0; j<N; j++) {
    d7cc:	461f      	mov	r7, r3
    d7ce:	eba8 0b03 	sub.w	fp, r8, r3
    d7d2:	4453      	add	r3, sl
    d7d4:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
    d7d8:	ea4f 0c9b 	mov.w	ip, fp, lsr #2
    d7dc:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
            A[i*N+j] += val;
    d7e0:	e9d3 0200 	ldrd	r0, r2, [r3]
    d7e4:	2100      	movs	r1, #0
    d7e6:	1835      	adds	r5, r6, r0
    d7e8:	460c      	mov	r4, r1
    d7ea:	eb06 4010 	add.w	r0, r6, r0, lsr #16
    d7ee:	f365 010f 	bfi	r1, r5, #0, #16
    d7f2:	f360 411f 	bfi	r1, r0, #16, #16
    d7f6:	6019      	str	r1, [r3, #0]
    d7f8:	18b1      	adds	r1, r6, r2
    d7fa:	f361 040f 	bfi	r4, r1, #0, #16
    d7fe:	eb06 4212 	add.w	r2, r6, r2, lsr #16
    d802:	f362 441f 	bfi	r4, r2, #16, #16
    d806:	605c      	str	r4, [r3, #4]
        for (j=0; j<N; j++) {
    d808:	3308      	adds	r3, #8
    d80a:	4563      	cmp	r3, ip
    d80c:	d1e8      	bne.n	d7e0 <matrix_test+0x9c>
    d80e:	f02b 0203 	bic.w	r2, fp, #3
    d812:	455a      	cmp	r2, fp
    d814:	eb02 0307 	add.w	r3, r2, r7
    d818:	d033      	beq.n	d882 <matrix_test+0x13e>
            A[i*N+j] += val;
    d81a:	eb03 010a 	add.w	r1, r3, sl
        for (j=0; j<N; j++) {
    d81e:	1c5a      	adds	r2, r3, #1
            A[i*N+j] += val;
    d820:	f83e 0011 	ldrh.w	r0, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    d824:	4590      	cmp	r8, r2
            A[i*N+j] += val;
    d826:	4430      	add	r0, r6
    d828:	f82e 0011 	strh.w	r0, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    d82c:	d929      	bls.n	d882 <matrix_test+0x13e>
            A[i*N+j] += val;
    d82e:	4452      	add	r2, sl
        for (j=0; j<N; j++) {
    d830:	1c99      	adds	r1, r3, #2
            A[i*N+j] += val;
    d832:	f83e 0012 	ldrh.w	r0, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    d836:	4588      	cmp	r8, r1
            A[i*N+j] += val;
    d838:	4430      	add	r0, r6
    d83a:	f82e 0012 	strh.w	r0, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    d83e:	d920      	bls.n	d882 <matrix_test+0x13e>
            A[i*N+j] += val;
    d840:	4451      	add	r1, sl
        for (j=0; j<N; j++) {
    d842:	1cda      	adds	r2, r3, #3
            A[i*N+j] += val;
    d844:	f83e 0011 	ldrh.w	r0, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    d848:	4590      	cmp	r8, r2
            A[i*N+j] += val;
    d84a:	4430      	add	r0, r6
    d84c:	f82e 0011 	strh.w	r0, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    d850:	d917      	bls.n	d882 <matrix_test+0x13e>
            A[i*N+j] += val;
    d852:	4452      	add	r2, sl
        for (j=0; j<N; j++) {
    d854:	1d19      	adds	r1, r3, #4
            A[i*N+j] += val;
    d856:	f83e 0012 	ldrh.w	r0, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    d85a:	4588      	cmp	r8, r1
            A[i*N+j] += val;
    d85c:	4430      	add	r0, r6
    d85e:	f82e 0012 	strh.w	r0, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    d862:	d90e      	bls.n	d882 <matrix_test+0x13e>
            A[i*N+j] += val;
    d864:	4451      	add	r1, sl
        for (j=0; j<N; j++) {
    d866:	3305      	adds	r3, #5
            A[i*N+j] += val;
    d868:	f83e 2011 	ldrh.w	r2, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    d86c:	4598      	cmp	r8, r3
            A[i*N+j] += val;
    d86e:	4432      	add	r2, r6
    d870:	f82e 2011 	strh.w	r2, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    d874:	d905      	bls.n	d882 <matrix_test+0x13e>
            A[i*N+j] += val;
    d876:	4453      	add	r3, sl
    d878:	f83e 2013 	ldrh.w	r2, [lr, r3, lsl #1]
    d87c:	4432      	add	r2, r6
    d87e:	f82e 2013 	strh.w	r2, [lr, r3, lsl #1]
    for (i=0; i<N; i++) {
    d882:	9b03      	ldr	r3, [sp, #12]
    d884:	4499      	add	r9, r3
    d886:	9b02      	ldr	r3, [sp, #8]
    d888:	1c5c      	adds	r4, r3, #1
    d88a:	45a0      	cmp	r8, r4
    d88c:	44c2      	add	sl, r8
    d88e:	d005      	beq.n	d89c <matrix_test+0x158>
    d890:	9402      	str	r4, [sp, #8]
    d892:	e779      	b.n	d788 <matrix_test+0x44>
        for (j=0; j<N; j++) {
    d894:	461f      	mov	r7, r3
    d896:	e79a      	b.n	d7ce <matrix_test+0x8a>
    d898:	2702      	movs	r7, #2
    d89a:	e798      	b.n	d7ce <matrix_test+0x8a>
    d89c:	9d03      	ldr	r5, [sp, #12]
    d89e:	f8dd e01c 	ldr.w	lr, [sp, #28]
    d8a2:	9607      	str	r6, [sp, #28]
    d8a4:	4698      	mov	r8, r3
    d8a6:	9b08      	ldr	r3, [sp, #32]
    d8a8:	1958      	adds	r0, r3, r5
    d8aa:	9b01      	ldr	r3, [sp, #4]
    d8ac:	ebc4 79c4 	rsb	r9, r4, r4, lsl #31
    d8b0:	3b04      	subs	r3, #4
    for (i=0; i<N; i++) {
    d8b2:	2700      	movs	r7, #0
    for (i=0; i<N; i++) {
    d8b4:	ebc4 7a84 	rsb	sl, r4, r4, lsl #30
    d8b8:	ea4f 0949 	mov.w	r9, r9, lsl #1
    d8bc:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
    for (i=0; i<N; i++) {
    d8c0:	46bc      	mov	ip, r7
    d8c2:	9303      	str	r3, [sp, #12]
    d8c4:	469b      	mov	fp, r3
        for (j=0; j<N; j++) {
    d8c6:	eb00 0609 	add.w	r6, r0, r9
    d8ca:	eb0b 0187 	add.w	r1, fp, r7, lsl #2
        for (j=0; j<N; j++) {
    d8ce:	4632      	mov	r2, r6
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    d8d0:	f932 3b02 	ldrsh.w	r3, [r2], #2
    d8d4:	fb03 f30e 	mul.w	r3, r3, lr
        for (j=0; j<N; j++) {
    d8d8:	4282      	cmp	r2, r0
            C[i*N+j]=(MATRES)A[i*N+j] * (MATRES)val;
    d8da:	f841 3f04 	str.w	r3, [r1, #4]!
        for (j=0; j<N; j++) {
    d8de:	d1f7      	bne.n	d8d0 <matrix_test+0x18c>
    for (i=0; i<N; i++) {
    d8e0:	45c4      	cmp	ip, r8
    d8e2:	4427      	add	r7, r4
    d8e4:	eba6 000a 	sub.w	r0, r6, sl
    d8e8:	f10c 0301 	add.w	r3, ip, #1
    d8ec:	d001      	beq.n	d8f2 <matrix_test+0x1ae>
    d8ee:	469c      	mov	ip, r3
    d8f0:	e7e9      	b.n	d8c6 <matrix_test+0x182>
            if (tmp>clipval) {
    d8f2:	e9dd b606 	ldrd	fp, r6, [sp, #24]
    d8f6:	9901      	ldr	r1, [sp, #4]
    d8f8:	f8dd c008 	ldr.w	ip, [sp, #8]
    d8fc:	00a3      	lsls	r3, r4, #2
    d8fe:	eb01 0784 	add.w	r7, r1, r4, lsl #2
    d902:	9307      	str	r3, [sp, #28]
    d904:	e9cd 650a 	strd	r6, r5, [sp, #40]	; 0x28
    d908:	f04f 0900 	mov.w	r9, #0
    d90c:	46b8      	mov	r8, r7
    d90e:	9706      	str	r7, [sp, #24]
    d910:	9f07      	ldr	r7, [sp, #28]
    d912:	4648      	mov	r0, r9
    d914:	464a      	mov	r2, r9
    d916:	464b      	mov	r3, r9
    d918:	46ca      	mov	sl, r9
    d91a:	468e      	mov	lr, r1
        for (j=0; j<N; j++) {
    d91c:	eb0e 0189 	add.w	r1, lr, r9, lsl #2
    d920:	e005      	b.n	d92e <matrix_test+0x1ea>
                ret += (cur>prev) ? 1 : 0;
    d922:	42aa      	cmp	r2, r5
    d924:	bfc8      	it	gt
    d926:	3001      	addgt	r0, #1
        for (j=0; j<N; j++) {
    d928:	4588      	cmp	r8, r1
                ret += (cur>prev) ? 1 : 0;
    d92a:	b200      	sxth	r0, r0
        for (j=0; j<N; j++) {
    d92c:	d00c      	beq.n	d948 <matrix_test+0x204>
                ret+=10;
    d92e:	4615      	mov	r5, r2
            cur=C[i*N+j];
    d930:	f851 2b04 	ldr.w	r2, [r1], #4
            tmp+=cur;
    d934:	4413      	add	r3, r2
            if (tmp>clipval) {
    d936:	455b      	cmp	r3, fp
                ret+=10;
    d938:	f100 060a 	add.w	r6, r0, #10
            if (tmp>clipval) {
    d93c:	ddf1      	ble.n	d922 <matrix_test+0x1de>
        for (j=0; j<N; j++) {
    d93e:	4588      	cmp	r8, r1
                ret+=10;
    d940:	b230      	sxth	r0, r6
                tmp=0;
    d942:	f04f 0300 	mov.w	r3, #0
        for (j=0; j<N; j++) {
    d946:	d1f2      	bne.n	d92e <matrix_test+0x1ea>
    for (i=0; i<N; i++) {
    d948:	45d4      	cmp	ip, sl
    d94a:	44b8      	add	r8, r7
    d94c:	44a1      	add	r9, r4
    d94e:	f10a 0101 	add.w	r1, sl, #1
    d952:	d001      	beq.n	d958 <matrix_test+0x214>
    d954:	468a      	mov	sl, r1
    d956:	e7e1      	b.n	d91c <matrix_test+0x1d8>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    d958:	2100      	movs	r1, #0
    d95a:	e9dd 650a 	ldrd	r6, r5, [sp, #40]	; 0x28
    return ret;
    d95e:	9f06      	ldr	r7, [sp, #24]
    crc=crc16(matrix_sum(N,C,clipval),crc);
    d960:	f001 f816 	bl	e990 <crc16>
    This is common in many simple filters (e.g. fir where a vector of coefficients is applied to the matrix.)
*/
void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
    ee_u32 i,j;
    for (i=0; i<N; i++) {
        C[i]=0;
    d964:	f8dd 801c 	ldr.w	r8, [sp, #28]
    d968:	2100      	movs	r1, #0
    d96a:	4642      	mov	r2, r8
    crc=crc16(matrix_sum(N,C,clipval),crc);
    d96c:	ee08 0a10 	vmov	s16, r0
        C[i]=0;
    d970:	9801      	ldr	r0, [sp, #4]
    d972:	f001 ff8d 	bl	f890 <memset>
    d976:	9b08      	ldr	r3, [sp, #32]
    d978:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
    d97c:	1e99      	subs	r1, r3, #2
    d97e:	9b04      	ldr	r3, [sp, #16]
    d980:	9106      	str	r1, [sp, #24]
    d982:	1e9a      	subs	r2, r3, #2
    d984:	9b03      	ldr	r3, [sp, #12]
    d986:	930a      	str	r3, [sp, #40]	; 0x28
    d988:	eb08 0a03 	add.w	sl, r8, r3
    d98c:	4689      	mov	r9, r1
    d98e:	eb02 0e05 	add.w	lr, r2, r5
    d992:	4698      	mov	r8, r3
    d994:	4693      	mov	fp, r2
        for (j=0; j<N; j++) {
    d996:	465b      	mov	r3, fp
        C[i]=0;
    d998:	4649      	mov	r1, r9
    d99a:	2200      	movs	r2, #0
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    d99c:	f833 0f02 	ldrh.w	r0, [r3, #2]!
    d9a0:	f831 cf02 	ldrh.w	ip, [r1, #2]!
        for (j=0; j<N; j++) {
    d9a4:	459e      	cmp	lr, r3
            C[i]+=(MATRES)A[i*N+j] * (MATRES)B[j];
    d9a6:	fb1c 2200 	smlabb	r2, ip, r0, r2
        for (j=0; j<N; j++) {
    d9aa:	d1f7      	bne.n	d99c <matrix_test+0x258>
    d9ac:	f848 2f04 	str.w	r2, [r8, #4]!
    for (i=0; i<N; i++) {
    d9b0:	45c2      	cmp	sl, r8
    d9b2:	44a9      	add	r9, r5
    d9b4:	d1ef      	bne.n	d996 <matrix_test+0x252>
    d9b6:	f04f 0800 	mov.w	r8, #0
    d9ba:	f8dd c01c 	ldr.w	ip, [sp, #28]
    d9be:	f8dd a004 	ldr.w	sl, [sp, #4]
    d9c2:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
    d9c6:	f8dd e008 	ldr.w	lr, [sp, #8]
    d9ca:	950b      	str	r5, [sp, #44]	; 0x2c
    d9cc:	4640      	mov	r0, r8
    d9ce:	4642      	mov	r2, r8
    d9d0:	4643      	mov	r3, r8
    d9d2:	46c1      	mov	r9, r8
    d9d4:	9602      	str	r6, [sp, #8]
        for (j=0; j<N; j++) {
    d9d6:	eb0a 0188 	add.w	r1, sl, r8, lsl #2
    d9da:	e005      	b.n	d9e8 <matrix_test+0x2a4>
                ret += (cur>prev) ? 1 : 0;
    d9dc:	42aa      	cmp	r2, r5
    d9de:	bfc8      	it	gt
    d9e0:	3001      	addgt	r0, #1
        for (j=0; j<N; j++) {
    d9e2:	42b9      	cmp	r1, r7
                ret += (cur>prev) ? 1 : 0;
    d9e4:	b200      	sxth	r0, r0
        for (j=0; j<N; j++) {
    d9e6:	d00c      	beq.n	da02 <matrix_test+0x2be>
                ret+=10;
    d9e8:	4615      	mov	r5, r2
            cur=C[i*N+j];
    d9ea:	f851 2b04 	ldr.w	r2, [r1], #4
            tmp+=cur;
    d9ee:	4413      	add	r3, r2
            if (tmp>clipval) {
    d9f0:	455b      	cmp	r3, fp
                ret+=10;
    d9f2:	f100 060a 	add.w	r6, r0, #10
            if (tmp>clipval) {
    d9f6:	ddf1      	ble.n	d9dc <matrix_test+0x298>
        for (j=0; j<N; j++) {
    d9f8:	42b9      	cmp	r1, r7
                ret+=10;
    d9fa:	b230      	sxth	r0, r6
                tmp=0;
    d9fc:	f04f 0300 	mov.w	r3, #0
        for (j=0; j<N; j++) {
    da00:	d1f2      	bne.n	d9e8 <matrix_test+0x2a4>
    for (i=0; i<N; i++) {
    da02:	45ce      	cmp	lr, r9
    da04:	eb01 070c 	add.w	r7, r1, ip
    da08:	44a0      	add	r8, r4
    da0a:	f109 0101 	add.w	r1, r9, #1
    da0e:	d001      	beq.n	da14 <matrix_test+0x2d0>
    da10:	4689      	mov	r9, r1
    da12:	e7e0      	b.n	d9d6 <matrix_test+0x292>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    da14:	ee18 1a10 	vmov	r1, s16
    da18:	9e02      	ldr	r6, [sp, #8]
    da1a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    da1c:	f000 ffb8 	bl	e990 <crc16>
*/
void matrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
    ee_u32 i,j,k;
    for (i=0; i<N; i++) {
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
    da20:	9a07      	ldr	r2, [sp, #28]
    da22:	f8cd b008 	str.w	fp, [sp, #8]
    da26:	2c00      	cmp	r4, #0
    da28:	bf08      	it	eq
    da2a:	2204      	moveq	r2, #4
    da2c:	2300      	movs	r3, #0
    crc=crc16(matrix_sum(N,C,clipval),crc);
    da2e:	ee08 0a90 	vmov	s17, r0
            C[i*N+j]=0;
    da32:	ee08 2a10 	vmov	s16, r2
    da36:	461f      	mov	r7, r3
    da38:	4698      	mov	r8, r3
    da3a:	960b      	str	r6, [sp, #44]	; 0x2c
    da3c:	9b01      	ldr	r3, [sp, #4]
    da3e:	ee18 2a10 	vmov	r2, s16
    da42:	eb03 0087 	add.w	r0, r3, r7, lsl #2
    da46:	2100      	movs	r1, #0
    da48:	f001 ff22 	bl	f890 <memset>
    da4c:	9b03      	ldr	r3, [sp, #12]
    da4e:	f8dd 9010 	ldr.w	r9, [sp, #16]
    da52:	ea4f 0a87 	mov.w	sl, r7, lsl #2
    da56:	449a      	add	sl, r3
    da58:	9b06      	ldr	r3, [sp, #24]
        for (j=0; j<N; j++) {
    da5a:	f04f 0e00 	mov.w	lr, #0
    da5e:	eb03 0b47 	add.w	fp, r3, r7, lsl #1
    da62:	2100      	movs	r1, #0
    da64:	464a      	mov	r2, r9
    da66:	4658      	mov	r0, fp
            for(k=0;k<N;k++)
    da68:	460b      	mov	r3, r1
            {
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    da6a:	8816      	ldrh	r6, [r2, #0]
    da6c:	f830 cf02 	ldrh.w	ip, [r0, #2]!
            for(k=0;k<N;k++)
    da70:	3301      	adds	r3, #1
    da72:	429c      	cmp	r4, r3
    da74:	442a      	add	r2, r5
                C[i*N+j]+=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    da76:	fb1c 1106 	smlabb	r1, ip, r6, r1
            for(k=0;k<N;k++)
    da7a:	d8f6      	bhi.n	da6a <matrix_test+0x326>
        for (j=0; j<N; j++) {
    da7c:	f10e 0e01 	add.w	lr, lr, #1
    da80:	4574      	cmp	r4, lr
    da82:	f84a 1f04 	str.w	r1, [sl, #4]!
    da86:	f109 0902 	add.w	r9, r9, #2
    da8a:	d8ea      	bhi.n	da62 <matrix_test+0x31e>
    for (i=0; i<N; i++) {
    da8c:	f108 0801 	add.w	r8, r8, #1
    da90:	4544      	cmp	r4, r8
    da92:	4427      	add	r7, r4
    da94:	d8d2      	bhi.n	da3c <matrix_test+0x2f8>
    da96:	2000      	movs	r0, #0
    da98:	f8dd b008 	ldr.w	fp, [sp, #8]
    da9c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    da9e:	f8dd 900c 	ldr.w	r9, [sp, #12]
    daa2:	f8dd e01c 	ldr.w	lr, [sp, #28]
    daa6:	4602      	mov	r2, r0
    daa8:	4603      	mov	r3, r0
    daaa:	4680      	mov	r8, r0
        for (j=0; j<N; j++) {
    daac:	464f      	mov	r7, r9
    daae:	2100      	movs	r1, #0
    dab0:	e006      	b.n	dac0 <matrix_test+0x37c>
    dab2:	3101      	adds	r1, #1
                ret += (cur>prev) ? 1 : 0;
    dab4:	4562      	cmp	r2, ip
    dab6:	bfc8      	it	gt
    dab8:	3001      	addgt	r0, #1
        for (j=0; j<N; j++) {
    daba:	428c      	cmp	r4, r1
                ret += (cur>prev) ? 1 : 0;
    dabc:	b200      	sxth	r0, r0
        for (j=0; j<N; j++) {
    dabe:	d90e      	bls.n	dade <matrix_test+0x39a>
                ret+=10;
    dac0:	4694      	mov	ip, r2
            cur=C[i*N+j];
    dac2:	f857 2f04 	ldr.w	r2, [r7, #4]!
            tmp+=cur;
    dac6:	4413      	add	r3, r2
            if (tmp>clipval) {
    dac8:	455b      	cmp	r3, fp
                ret+=10;
    daca:	f100 0a0a 	add.w	sl, r0, #10
            if (tmp>clipval) {
    dace:	ddf0      	ble.n	dab2 <matrix_test+0x36e>
        for (j=0; j<N; j++) {
    dad0:	3101      	adds	r1, #1
    dad2:	428c      	cmp	r4, r1
                ret+=10;
    dad4:	fa0f f08a 	sxth.w	r0, sl
                tmp=0;
    dad8:	f04f 0300 	mov.w	r3, #0
        for (j=0; j<N; j++) {
    dadc:	d8f0      	bhi.n	dac0 <matrix_test+0x37c>
    for (i=0; i<N; i++) {
    dade:	f108 0801 	add.w	r8, r8, #1
    dae2:	4544      	cmp	r4, r8
    dae4:	44f1      	add	r9, lr
    dae6:	d8e1      	bhi.n	daac <matrix_test+0x368>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dae8:	ee18 1a90 	vmov	r1, s17
    daec:	f000 ff50 	bl	e990 <crc16>
    daf0:	2700      	movs	r7, #0
    daf2:	ee08 0a90 	vmov	s17, r0
    Multiply a matrix by a matrix, and extract some bits from the result.
    Basic code is used in many algorithms, mostly with minor changes such as scaling.
*/
void matrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {
    ee_u32 i,j,k;
    for (i=0; i<N; i++) {
    daf6:	f8cd b008 	str.w	fp, [sp, #8]
    dafa:	46b8      	mov	r8, r7
    dafc:	960b      	str	r6, [sp, #44]	; 0x2c
        for (j=0; j<N; j++) {
            C[i*N+j]=0;
    dafe:	9b01      	ldr	r3, [sp, #4]
    db00:	ee18 2a10 	vmov	r2, s16
    db04:	eb03 0087 	add.w	r0, r3, r7, lsl #2
    db08:	2100      	movs	r1, #0
    db0a:	f001 fec1 	bl	f890 <memset>
    db0e:	9b03      	ldr	r3, [sp, #12]
    db10:	f8dd 9010 	ldr.w	r9, [sp, #16]
    db14:	ea4f 0a87 	mov.w	sl, r7, lsl #2
    db18:	449a      	add	sl, r3
    db1a:	9b06      	ldr	r3, [sp, #24]
        for (j=0; j<N; j++) {
    db1c:	f04f 0e00 	mov.w	lr, #0
    db20:	eb03 0b47 	add.w	fp, r3, r7, lsl #1
    db24:	2000      	movs	r0, #0
    db26:	4649      	mov	r1, r9
    db28:	465e      	mov	r6, fp
            for(k=0;k<N;k++)
    db2a:	4602      	mov	r2, r0
            {
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    db2c:	f8b1 c000 	ldrh.w	ip, [r1]
    db30:	f836 3f02 	ldrh.w	r3, [r6, #2]!
            for(k=0;k<N;k++)
    db34:	3201      	adds	r2, #1
                MATRES tmp=(MATRES)A[i*N+k] * (MATRES)B[k*N+j];
    db36:	fb13 f30c 	smulbb	r3, r3, ip
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    db3a:	f3c3 0c83 	ubfx	ip, r3, #2, #4
            for(k=0;k<N;k++)
    db3e:	4294      	cmp	r4, r2
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    db40:	f3c3 1346 	ubfx	r3, r3, #5, #7
            for(k=0;k<N;k++)
    db44:	4429      	add	r1, r5
                C[i*N+j]+=bit_extract(tmp,2,4)*bit_extract(tmp,5,7);
    db46:	fb03 000c 	mla	r0, r3, ip, r0
            for(k=0;k<N;k++)
    db4a:	d8ef      	bhi.n	db2c <matrix_test+0x3e8>
        for (j=0; j<N; j++) {
    db4c:	f10e 0e01 	add.w	lr, lr, #1
    db50:	4574      	cmp	r4, lr
    db52:	f84a 0f04 	str.w	r0, [sl, #4]!
    db56:	f109 0902 	add.w	r9, r9, #2
    db5a:	d8e3      	bhi.n	db24 <matrix_test+0x3e0>
    for (i=0; i<N; i++) {
    db5c:	f108 0801 	add.w	r8, r8, #1
    db60:	4544      	cmp	r4, r8
    db62:	4427      	add	r7, r4
    db64:	d8cb      	bhi.n	dafe <matrix_test+0x3ba>
    db66:	2000      	movs	r0, #0
    db68:	f8dd b008 	ldr.w	fp, [sp, #8]
    db6c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    db6e:	f8dd 901c 	ldr.w	r9, [sp, #28]
    db72:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
    db76:	4602      	mov	r2, r0
    db78:	4603      	mov	r3, r0
    db7a:	4680      	mov	r8, r0
        for (j=0; j<N; j++) {
    db7c:	4677      	mov	r7, lr
    db7e:	2100      	movs	r1, #0
    db80:	e006      	b.n	db90 <matrix_test+0x44c>
    db82:	3101      	adds	r1, #1
                ret += (cur>prev) ? 1 : 0;
    db84:	4562      	cmp	r2, ip
    db86:	bfc8      	it	gt
    db88:	3001      	addgt	r0, #1
        for (j=0; j<N; j++) {
    db8a:	428c      	cmp	r4, r1
                ret += (cur>prev) ? 1 : 0;
    db8c:	b200      	sxth	r0, r0
        for (j=0; j<N; j++) {
    db8e:	d90e      	bls.n	dbae <matrix_test+0x46a>
                ret+=10;
    db90:	4694      	mov	ip, r2
            cur=C[i*N+j];
    db92:	f857 2f04 	ldr.w	r2, [r7, #4]!
            tmp+=cur;
    db96:	4413      	add	r3, r2
            if (tmp>clipval) {
    db98:	455b      	cmp	r3, fp
                ret+=10;
    db9a:	f100 0a0a 	add.w	sl, r0, #10
            if (tmp>clipval) {
    db9e:	ddf0      	ble.n	db82 <matrix_test+0x43e>
        for (j=0; j<N; j++) {
    dba0:	3101      	adds	r1, #1
    dba2:	428c      	cmp	r4, r1
                ret+=10;
    dba4:	fa0f f08a 	sxth.w	r0, sl
                tmp=0;
    dba8:	f04f 0300 	mov.w	r3, #0
        for (j=0; j<N; j++) {
    dbac:	d8f0      	bhi.n	db90 <matrix_test+0x44c>
    for (i=0; i<N; i++) {
    dbae:	f108 0801 	add.w	r8, r8, #1
    dbb2:	4544      	cmp	r4, r8
    dbb4:	44ce      	add	lr, r9
    dbb6:	d8e1      	bhi.n	db7c <matrix_test+0x438>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dbb8:	ee18 1a90 	vmov	r1, s17
    dbbc:	f000 fee8 	bl	e990 <crc16>
    dbc0:	f04f 0900 	mov.w	r9, #0
    dbc4:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    dbc8:	f8dd e020 	ldr.w	lr, [sp, #32]
    dbcc:	9003      	str	r0, [sp, #12]
    dbce:	46cb      	mov	fp, r9
    dbd0:	9502      	str	r5, [sp, #8]
        for (j=0; j<N; j++) {
    dbd2:	ea4f 0358 	mov.w	r3, r8, lsr #1
    dbd6:	425b      	negs	r3, r3
    dbd8:	f003 0303 	and.w	r3, r3, #3
    dbdc:	2c00      	cmp	r4, #0
    dbde:	f103 0203 	add.w	r2, r3, #3
    dbe2:	bf14      	ite	ne
    dbe4:	46a2      	movne	sl, r4
    dbe6:	f04f 0a01 	moveq.w	sl, #1
    dbea:	2a05      	cmp	r2, #5
    dbec:	9905      	ldr	r1, [sp, #20]
    dbee:	bf38      	it	cc
    dbf0:	2205      	movcc	r2, #5
    dbf2:	2c00      	cmp	r4, #0
    dbf4:	bf08      	it	eq
    dbf6:	2100      	moveq	r1, #0
    dbf8:	428a      	cmp	r2, r1
    dbfa:	f200 8087 	bhi.w	dd0c <matrix_test+0x5c8>
    dbfe:	2b00      	cmp	r3, #0
    dc00:	d07f      	beq.n	dd02 <matrix_test+0x5be>
            A[i*N+j] += val;
    dc02:	f8b8 2000 	ldrh.w	r2, [r8]
    dc06:	2b01      	cmp	r3, #1
    dc08:	eba2 0206 	sub.w	r2, r2, r6
    dc0c:	f8a8 2000 	strh.w	r2, [r8]
        for (j=0; j<N; j++) {
    dc10:	d077      	beq.n	dd02 <matrix_test+0x5be>
            A[i*N+j] += val;
    dc12:	f8b8 2002 	ldrh.w	r2, [r8, #2]
    dc16:	2b03      	cmp	r3, #3
    dc18:	eba2 0206 	sub.w	r2, r2, r6
    dc1c:	f8a8 2002 	strh.w	r2, [r8, #2]
        for (j=0; j<N; j++) {
    dc20:	d171      	bne.n	dd06 <matrix_test+0x5c2>
            A[i*N+j] += val;
    dc22:	f8b8 2004 	ldrh.w	r2, [r8, #4]
        for (j=0; j<N; j++) {
    dc26:	9301      	str	r3, [sp, #4]
            A[i*N+j] += val;
    dc28:	1b92      	subs	r2, r2, r6
    dc2a:	f8a8 2004 	strh.w	r2, [r8, #4]
        for (j=0; j<N; j++) {
    dc2e:	ebaa 0a03 	sub.w	sl, sl, r3
    dc32:	444b      	add	r3, r9
    dc34:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
    dc38:	ea4f 0c9a 	mov.w	ip, sl, lsr #2
    dc3c:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
            A[i*N+j] += val;
    dc40:	e9d3 0200 	ldrd	r0, r2, [r3]
    dc44:	2100      	movs	r1, #0
    dc46:	1b87      	subs	r7, r0, r6
    dc48:	460d      	mov	r5, r1
    dc4a:	ebc6 4010 	rsb	r0, r6, r0, lsr #16
    dc4e:	f367 010f 	bfi	r1, r7, #0, #16
    dc52:	f360 411f 	bfi	r1, r0, #16, #16
    dc56:	6019      	str	r1, [r3, #0]
    dc58:	1b91      	subs	r1, r2, r6
    dc5a:	f361 050f 	bfi	r5, r1, #0, #16
    dc5e:	ebc6 4212 	rsb	r2, r6, r2, lsr #16
    dc62:	f362 451f 	bfi	r5, r2, #16, #16
    dc66:	605d      	str	r5, [r3, #4]
        for (j=0; j<N; j++) {
    dc68:	3308      	adds	r3, #8
    dc6a:	4563      	cmp	r3, ip
    dc6c:	d1e8      	bne.n	dc40 <matrix_test+0x4fc>
    dc6e:	f02a 0203 	bic.w	r2, sl, #3
    dc72:	9b01      	ldr	r3, [sp, #4]
    dc74:	4552      	cmp	r2, sl
    dc76:	4413      	add	r3, r2
    dc78:	d034      	beq.n	dce4 <matrix_test+0x5a0>
            A[i*N+j] += val;
    dc7a:	eb03 0109 	add.w	r1, r3, r9
    dc7e:	f83e 2011 	ldrh.w	r2, [lr, r1, lsl #1]
    dc82:	1b92      	subs	r2, r2, r6
    dc84:	f82e 2011 	strh.w	r2, [lr, r1, lsl #1]
        for (j=0; j<N; j++) {
    dc88:	1c5a      	adds	r2, r3, #1
    dc8a:	4294      	cmp	r4, r2
    dc8c:	d92a      	bls.n	dce4 <matrix_test+0x5a0>
            A[i*N+j] += val;
    dc8e:	444a      	add	r2, r9
    dc90:	f83e 1012 	ldrh.w	r1, [lr, r2, lsl #1]
    dc94:	1b89      	subs	r1, r1, r6
    dc96:	f82e 1012 	strh.w	r1, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    dc9a:	1c9a      	adds	r2, r3, #2
    dc9c:	42a2      	cmp	r2, r4
    dc9e:	d221      	bcs.n	dce4 <matrix_test+0x5a0>
            A[i*N+j] += val;
    dca0:	444a      	add	r2, r9
    dca2:	f83e 1012 	ldrh.w	r1, [lr, r2, lsl #1]
    dca6:	1b89      	subs	r1, r1, r6
    dca8:	f82e 1012 	strh.w	r1, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    dcac:	1cda      	adds	r2, r3, #3
    dcae:	4294      	cmp	r4, r2
    dcb0:	d918      	bls.n	dce4 <matrix_test+0x5a0>
            A[i*N+j] += val;
    dcb2:	444a      	add	r2, r9
    dcb4:	f83e 1012 	ldrh.w	r1, [lr, r2, lsl #1]
    dcb8:	1b89      	subs	r1, r1, r6
    dcba:	f82e 1012 	strh.w	r1, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    dcbe:	1d1a      	adds	r2, r3, #4
    dcc0:	4294      	cmp	r4, r2
    dcc2:	d90f      	bls.n	dce4 <matrix_test+0x5a0>
            A[i*N+j] += val;
    dcc4:	444a      	add	r2, r9
        for (j=0; j<N; j++) {
    dcc6:	3305      	adds	r3, #5
            A[i*N+j] += val;
    dcc8:	f83e 1012 	ldrh.w	r1, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    dccc:	429c      	cmp	r4, r3
            A[i*N+j] += val;
    dcce:	eba1 0106 	sub.w	r1, r1, r6
    dcd2:	f82e 1012 	strh.w	r1, [lr, r2, lsl #1]
        for (j=0; j<N; j++) {
    dcd6:	d905      	bls.n	dce4 <matrix_test+0x5a0>
            A[i*N+j] += val;
    dcd8:	444b      	add	r3, r9
    dcda:	f83e 2013 	ldrh.w	r2, [lr, r3, lsl #1]
    dcde:	1b92      	subs	r2, r2, r6
    dce0:	f82e 2013 	strh.w	r2, [lr, r3, lsl #1]
    for (i=0; i<N; i++) {
    dce4:	9b02      	ldr	r3, [sp, #8]
    dce6:	f10b 0b01 	add.w	fp, fp, #1
    dcea:	45a3      	cmp	fp, r4
    dcec:	4498      	add	r8, r3
    dcee:	44a1      	add	r9, r4
    dcf0:	f4ff af6f 	bcc.w	dbd2 <matrix_test+0x48e>
    return crc;
    dcf4:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
}
    dcf8:	b00d      	add	sp, #52	; 0x34
    dcfa:	ecbd 8b02 	vpop	{d8}
    dcfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (j=0; j<N; j++) {
    dd02:	9301      	str	r3, [sp, #4]
    dd04:	e793      	b.n	dc2e <matrix_test+0x4ea>
    dd06:	2202      	movs	r2, #2
    dd08:	9201      	str	r2, [sp, #4]
    dd0a:	e790      	b.n	dc2e <matrix_test+0x4ea>
    dd0c:	2300      	movs	r3, #0
    dd0e:	e7b4      	b.n	dc7a <matrix_test+0x536>
    dd10:	2300      	movs	r3, #0
    dd12:	e582      	b.n	d81a <matrix_test+0xd6>
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dd14:	4601      	mov	r1, r0
    dd16:	f000 fe3b 	bl	e990 <crc16>
    dd1a:	4601      	mov	r1, r0
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dd1c:	4640      	mov	r0, r8
    dd1e:	f000 fe37 	bl	e990 <crc16>
    dd22:	4601      	mov	r1, r0
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dd24:	4640      	mov	r0, r8
    dd26:	f000 fe33 	bl	e990 <crc16>
    dd2a:	4601      	mov	r1, r0
    crc=crc16(matrix_sum(N,C,clipval),crc);
    dd2c:	4640      	mov	r0, r8
    dd2e:	f000 fe2f 	bl	e990 <crc16>
    dd32:	9003      	str	r0, [sp, #12]
    return crc;
    dd34:	f9bd 000c 	ldrsh.w	r0, [sp, #12]
}
    dd38:	b00d      	add	sp, #52	; 0x34
    dd3a:	ecbd 8b02 	vpop	{d8}
    dd3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd42:	bf00      	nop

0000dd44 <core_bench_matrix>:
ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {
    dd44:	b510      	push	{r4, lr}
    dd46:	b082      	sub	sp, #8
    dd48:	4614      	mov	r4, r2
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    dd4a:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
    dd4e:	9100      	str	r1, [sp, #0]
    dd50:	68c1      	ldr	r1, [r0, #12]
    dd52:	6800      	ldr	r0, [r0, #0]
    dd54:	f7ff fcf6 	bl	d744 <matrix_test>
    dd58:	4621      	mov	r1, r4
}
    dd5a:	b002      	add	sp, #8
    dd5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    crc=crc16(matrix_test(N,C,A,B,val),crc);
    dd60:	f000 be16 	b.w	e990 <crc16>

0000dd64 <core_init_matrix>:
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    dd64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dd68:	b085      	sub	sp, #20
        seed=1;
    dd6a:	2a00      	cmp	r2, #0
ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {
    dd6c:	9302      	str	r3, [sp, #8]
        seed=1;
    dd6e:	bf08      	it	eq
    dd70:	2201      	moveq	r2, #1
    while (j<blksize) {
    dd72:	2800      	cmp	r0, #0
    dd74:	d055      	beq.n	de22 <core_init_matrix+0xbe>
    dd76:	4605      	mov	r5, r0
    dd78:	2300      	movs	r3, #0
        i++;
    dd7a:	4618      	mov	r0, r3
    dd7c:	3301      	adds	r3, #1
        j=i*i*2*4;
    dd7e:	fb03 f403 	mul.w	r4, r3, r3
    while (j<blksize) {
    dd82:	ebb5 0fc4 	cmp.w	r5, r4, lsl #3
    dd86:	d8f8      	bhi.n	dd7a <core_init_matrix+0x16>
    A=(MATDAT *)align_mem(memblk);
    dd88:	3901      	subs	r1, #1
    B=A+N*N;
    dd8a:	fb00 f900 	mul.w	r9, r0, r0
    A=(MATDAT *)align_mem(memblk);
    dd8e:	f021 0a03 	bic.w	sl, r1, #3
    B=A+N*N;
    dd92:	ea4f 0349 	mov.w	r3, r9, lsl #1
    A=(MATDAT *)align_mem(memblk);
    dd96:	f10a 0a04 	add.w	sl, sl, #4
    B=A+N*N;
    dd9a:	9301      	str	r3, [sp, #4]
    dd9c:	eb0a 0949 	add.w	r9, sl, r9, lsl #1
    p->N=N;
    dda0:	9003      	str	r0, [sp, #12]
    for (i=0; i<N; i++) {
    dda2:	b370      	cbz	r0, de02 <core_init_matrix+0x9e>
    dda4:	1e43      	subs	r3, r0, #1
    dda6:	ea4f 0b40 	mov.w	fp, r0, lsl #1
    B=A+N*N;
    ddaa:	f06f 0701 	mvn.w	r7, #1
    ddae:	f04f 0800 	mov.w	r8, #0
    ddb2:	2601      	movs	r6, #1
    ddb4:	9300      	str	r3, [sp, #0]
        for (j=0; j<N; j++) {
    ddb6:	eb09 0e07 	add.w	lr, r9, r7
    ddba:	eb0a 0c07 	add.w	ip, sl, r7
        seed=1;
    ddbe:	4634      	mov	r4, r6
        for (j=0; j<N; j++) {
    ddc0:	2500      	movs	r5, #0
            seed = ( ( order * seed ) % 65536 );
    ddc2:	fb04 f202 	mul.w	r2, r4, r2
    ddc6:	4253      	negs	r3, r2
    ddc8:	b29b      	uxth	r3, r3
    ddca:	b292      	uxth	r2, r2
    ddcc:	bf58      	it	pl
    ddce:	425a      	negpl	r2, r3
            val = (seed + order);
    ddd0:	b2a3      	uxth	r3, r4
    ddd2:	1899      	adds	r1, r3, r2
    ddd4:	b289      	uxth	r1, r1
        for (j=0; j<N; j++) {
    ddd6:	3501      	adds	r5, #1
            val =  (val + order);
    ddd8:	440b      	add	r3, r1
            val=matrix_clip(val,1);
    ddda:	b2db      	uxtb	r3, r3
        for (j=0; j<N; j++) {
    dddc:	4285      	cmp	r5, r0
            B[i*N+j] = val;
    ddde:	f82e 1f02 	strh.w	r1, [lr, #2]!
            val = (seed + order);
    dde2:	f104 0401 	add.w	r4, r4, #1
            A[i*N+j] = val;
    dde6:	f82c 3f02 	strh.w	r3, [ip, #2]!
        for (j=0; j<N; j++) {
    ddea:	d3ea      	bcc.n	ddc2 <core_init_matrix+0x5e>
            order++;
    ddec:	9b00      	ldr	r3, [sp, #0]
    ddee:	2800      	cmp	r0, #0
    for (i=0; i<N; i++) {
    ddf0:	f108 0801 	add.w	r8, r8, #1
            order++;
    ddf4:	bf08      	it	eq
    ddf6:	2300      	moveq	r3, #0
    ddf8:	3601      	adds	r6, #1
    for (i=0; i<N; i++) {
    ddfa:	4580      	cmp	r8, r0
            order++;
    ddfc:	441e      	add	r6, r3
    for (i=0; i<N; i++) {
    ddfe:	445f      	add	r7, fp
    de00:	d3d9      	bcc.n	ddb6 <core_init_matrix+0x52>
    p->C=(MATRES *)align_mem(B+N*N);
    de02:	9b01      	ldr	r3, [sp, #4]
    p->A=A;
    de04:	9a02      	ldr	r2, [sp, #8]
    p->C=(MATRES *)align_mem(B+N*N);
    de06:	444b      	add	r3, r9
    de08:	3b01      	subs	r3, #1
    de0a:	f023 0303 	bic.w	r3, r3, #3
    de0e:	3304      	adds	r3, #4
    de10:	e9c2 9302 	strd	r9, r3, [r2, #8]
    p->N=N;
    de14:	9b03      	ldr	r3, [sp, #12]
    p->A=A;
    de16:	f8c2 a004 	str.w	sl, [r2, #4]
    p->N=N;
    de1a:	6013      	str	r3, [r2, #0]
}
    de1c:	b005      	add	sp, #20
    de1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    B=A+N*N;
    de22:	f04f 33ff 	mov.w	r3, #4294967295
    A=(MATDAT *)align_mem(memblk);
    de26:	3901      	subs	r1, #1
    de28:	f021 0903 	bic.w	r9, r1, #3
    B=A+N*N;
    de2c:	9303      	str	r3, [sp, #12]
    N=i-1;
    de2e:	4618      	mov	r0, r3
    B=A+N*N;
    de30:	2302      	movs	r3, #2
    A=(MATDAT *)align_mem(memblk);
    de32:	f109 0a04 	add.w	sl, r9, #4
    B=A+N*N;
    de36:	9301      	str	r3, [sp, #4]
    de38:	f109 0906 	add.w	r9, r9, #6
    for (i=0; i<N; i++) {
    de3c:	e7b2      	b.n	dda4 <core_init_matrix+0x40>
    de3e:	bf00      	nop

0000de40 <start_time>:
    This function will be called right before starting the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or zeroing some system parameters - e.g. setting the cpu clocks cycles to 0.
*/
void start_time(void) {
    de40:	b508      	push	{r3, lr}
    am_hal_systick_load(0x00FFFFFF);
    de42:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
    de46:	f002 fc9f 	bl	10788 <am_hal_systick_load>
    am_hal_systick_int_enable();
    de4a:	f002 fc95 	bl	10778 <am_hal_systick_int_enable>
    am_hal_systick_start();
    de4e:	f002 fc83 	bl	10758 <am_hal_systick_start>
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    de52:	ed9f 7b05 	vldr	d7, [pc, #20]	; de68 <start_time+0x28>
    de56:	4906      	ldr	r1, [pc, #24]	; (de70 <start_time+0x30>)
    START_PA_DUMP = 0x1;
    de58:	4b06      	ldr	r3, [pc, #24]	; (de74 <start_time+0x34>)
    de5a:	2201      	movs	r2, #1
    start_time_val = 0; // GETMYTIME could be used - but there should be very small change anyways, as we just started
    de5c:	ed81 7b00 	vstr	d7, [r1]
    START_PA_DUMP = 0x1;
    de60:	615a      	str	r2, [r3, #20]
}
    de62:	bd08      	pop	{r3, pc}
    de64:	f3af 8000 	nop.w
	...
    de70:	10001458 	.word	0x10001458
    de74:	4ffff000 	.word	0x4ffff000

0000de78 <stop_time>:
    This function will be called right after ending the timed portion of the benchmark.

    Implementation may be capturing a system timer (as implemented in the example code)
    or other system parameters - e.g. reading the current value of cpu cycles counter.
*/
void stop_time(void) {
    de78:	b538      	push	{r3, r4, r5, lr}
    am_hal_systick_stop();
    de7a:	f002 fc75 	bl	10768 <am_hal_systick_stop>
    stop_time_val = GETMYTIME;
    de7e:	f002 fc89 	bl	10794 <am_hal_systick_count>
    de82:	4b09      	ldr	r3, [pc, #36]	; (dea8 <stop_time+0x30>)
    de84:	4a09      	ldr	r2, [pc, #36]	; (deac <stop_time+0x34>)
    de86:	681c      	ldr	r4, [r3, #0]
    de88:	f1c0 10ff 	rsb	r0, r0, #16711935	; 0xff00ff
    de8c:	2300      	movs	r3, #0
    de8e:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    de92:	f500 407f 	add.w	r0, r0, #65280	; 0xff00
    de96:	461d      	mov	r5, r3
    de98:	fbe4 0501 	umlal	r0, r5, r4, r1
    START_PA_DUMP = 0x0;
    de9c:	4904      	ldr	r1, [pc, #16]	; (deb0 <stop_time+0x38>)
    stop_time_val = GETMYTIME;
    de9e:	e9c2 0500 	strd	r0, r5, [r2]
    START_PA_DUMP = 0x0;
    dea2:	614b      	str	r3, [r1, #20]
}
    dea4:	bd38      	pop	{r3, r4, r5, pc}
    dea6:	bf00      	nop
    dea8:	10001040 	.word	0x10001040
    deac:	10001460 	.word	0x10001460
    deb0:	4ffff000 	.word	0x4ffff000

0000deb4 <get_time>:
    This methodology is taken to accomodate any hardware or simulated platform.
    The sample implementation returns millisecs by default,
    and the resolution is controlled by <TIMER_RES_DIVIDER>
*/
CORE_TICKS get_time(void) {
    CORE_TICKS elapsed=(CORE_TICKS)(MYTIMEDIFF(stop_time_val, start_time_val));
    deb4:	4a02      	ldr	r2, [pc, #8]	; (dec0 <get_time+0xc>)
    deb6:	4b03      	ldr	r3, [pc, #12]	; (dec4 <get_time+0x10>)
    deb8:	6810      	ldr	r0, [r2, #0]
    deba:	681b      	ldr	r3, [r3, #0]
    return elapsed;
}
    debc:	1ac0      	subs	r0, r0, r3
    debe:	4770      	bx	lr
    dec0:	10001460 	.word	0x10001460
    dec4:	10001458 	.word	0x10001458

0000dec8 <time_in_secs>:
    Convert the value returned by get_time to seconds.

    The <secs_ret> type is used to accomodate systems with no support for floating point.
    Default implementation implemented by the EE_TICKS_PER_SEC macro above.
*/
secs_ret time_in_secs(CORE_TICKS ticks) {
    dec8:	b508      	push	{r3, lr}
    secs_ret retval=((secs_ret)ticks) / (secs_ret)EE_TICKS_PER_SEC;
    deca:	f7fe fa5b 	bl	c384 <__aeabi_ui2d>
    dece:	a304      	add	r3, pc, #16	; (adr r3, dee0 <time_in_secs+0x18>)
    ded0:	e9d3 2300 	ldrd	r2, r3, [r3]
    ded4:	f7fe fbfa 	bl	c6cc <__aeabi_ddiv>
    return retval;
}
    ded8:	ec41 0b10 	vmov	d0, r0, r1
    dedc:	bd08      	pop	{r3, pc}
    dede:	bf00      	nop
    dee0:	00000000 	.word	0x00000000
    dee4:	4186e360 	.word	0x4186e360

0000dee8 <portable_init>:
    Target specific initialization code
    Test for some common mistakes.
*/

void portable_init(core_portable *p, int *argc, char *argv[])
{
    dee8:	b530      	push	{r4, r5, lr}

#if AM_PRINT_RESULTS
    // Initialize our printf buffer.
    for(i = 0; i < PRTBUFSIZE; i++)
    {
        am_prtbuf[i] = 0x00;
    deea:	4b2d      	ldr	r3, [pc, #180]	; (dfa0 <portable_init+0xb8>)
    p->portable_id=1;
    deec:	2401      	movs	r4, #1
{
    deee:	b083      	sub	sp, #12
        am_prtbuf[i] = 0x00;
    def0:	f44f 6280 	mov.w	r2, #1024	; 0x400
    def4:	2100      	movs	r1, #0
    p->portable_id=1;
    def6:	7004      	strb	r4, [r0, #0]
        am_prtbuf[i] = 0x00;
    def8:	4618      	mov	r0, r3
    defa:	f001 fcc9 	bl	f890 <memset>
    defe:	4603      	mov	r3, r0
    }
    am_pcBuf = am_prtbuf;
    df00:	4828      	ldr	r0, [pc, #160]	; (dfa4 <portable_init+0xbc>)
    am_bufcnt = 0;
    df02:	4a29      	ldr	r2, [pc, #164]	; (dfa8 <portable_init+0xc0>)
    am_pcBuf = am_prtbuf;
    df04:	6003      	str	r3, [r0, #0]
    am_bufcnt = 0;
    df06:	2100      	movs	r1, #0
#endif // AM_PRINT_RESULTS

    //
    // Set the system clock to maximum frequency.
    //
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    df08:	4608      	mov	r0, r1
    am_bufcnt = 0;
    df0a:	6011      	str	r1, [r2, #0]
    am_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);
    df0c:	f001 ff50 	bl	fdb0 <am_hal_clkgen_control>

    //
    // Set the default cache configuration
    //
const am_hal_cachectrl_config_t am_hal_cachectrl_benchmark =
    df10:	4b26      	ldr	r3, [pc, #152]	; (dfac <portable_init+0xc4>)
    df12:	681b      	ldr	r3, [r3, #0]
    df14:	f8ad 3004 	strh.w	r3, [sp, #4]
{
    .bLRU                       = 0,
    .eDescript                  = AM_HAL_CACHECTRL_DESCR_1WAY_128B_512E,
    .eMode                      = AM_HAL_CACHECTRL_CONFIG_MODE_INSTR,
};
    am_hal_cachectrl_config(&am_hal_cachectrl_benchmark);
    df18:	a801      	add	r0, sp, #4
const am_hal_cachectrl_config_t am_hal_cachectrl_benchmark =
    df1a:	0c1b      	lsrs	r3, r3, #16
    df1c:	f88d 3006 	strb.w	r3, [sp, #6]
    am_hal_cachectrl_config(&am_hal_cachectrl_benchmark);
    df20:	f001 fd9e 	bl	fa60 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    df24:	f001 fdc0 	bl	faa8 <am_hal_cachectrl_enable>

    //
    // Enable the cache for LPMMODE and aggressive settings.
    // This must be done after am_hal_cachectrl_enable().
    //
    if ( am_hal_cachectrl_control(AM_HAL_CACHECTRL_CONTROL_LPMMODE_AGGRESSIVE, 0) )
    df28:	2100      	movs	r1, #0
    df2a:	200d      	movs	r0, #13
    df2c:	f001 fdc6 	bl	fabc <am_hal_cachectrl_control>
    df30:	b118      	cbz	r0, df3a <portable_init+0x52>
    {
        am_util_stdio_printf("Failed to set cache into LPMMODE_AGGRESSIVE.\n");
    df32:	481f      	ldr	r0, [pc, #124]	; (dfb0 <portable_init+0xc8>)
    df34:	f001 fc52 	bl	f7dc <am_util_stdio_printf>
        while(1);
    df38:	e7fe      	b.n	df38 <portable_init+0x50>
#ifndef NOFPU
    //
    // Enable the floating point module, and configure the core for lazy
    // stacking.
    //
    am_hal_sysctrl_fpu_enable();
    df3a:	f002 fbeb 	bl	10714 <am_hal_sysctrl_fpu_enable>
    am_hal_sysctrl_fpu_stacking_enable(true);
    df3e:	4620      	mov	r0, r4
    df40:	f002 fbf0 	bl	10724 <am_hal_sysctrl_fpu_stacking_enable>

#if (defined(AM_PART_APOLLO3) || defined(AM_PART_APOLLO3P))
    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();
    df44:	f001 fd1c 	bl	f980 <am_bsp_low_power_init>

    //
    // Initialize the printf interface for UART output.
    //
    am_bsp_uart_printf_enable();
    df48:	f001 fd3a 	bl	f9c0 <am_bsp_uart_printf_enable>

    //
    // Turn off unneeded flash
    //
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_FLASH_MIN) )
    df4c:	200e      	movs	r0, #14
    df4e:	f002 faad 	bl	104ac <am_hal_pwrctrl_memory_enable>
    df52:	b118      	cbz	r0, df5c <portable_init+0x74>
    {
        am_util_stdio_printf("Failed to reconfigure Flash for minimum.\n");
    df54:	4817      	ldr	r0, [pc, #92]	; (dfb4 <portable_init+0xcc>)
    df56:	f001 fc41 	bl	f7dc <am_util_stdio_printf>
        while(1);
    df5a:	e7fe      	b.n	df5a <portable_init+0x72>
    }

    //
    // Turn off unneeded SRAM
    //
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_SRAM_8K_DTCM) )
    df5c:	4620      	mov	r0, r4
    df5e:	f002 faa5 	bl	104ac <am_hal_pwrctrl_memory_enable>
    df62:	4605      	mov	r5, r0
    df64:	b118      	cbz	r0, df6e <portable_init+0x86>
    {
      am_util_stdio_printf("Failed to reconfigure SRAM.\n");
    df66:	4814      	ldr	r0, [pc, #80]	; (dfb8 <portable_init+0xd0>)
    df68:	f001 fc38 	bl	f7dc <am_util_stdio_printf>
      while(1);
    df6c:	e7fe      	b.n	df6c <portable_init+0x84>
    }

    am_hal_gpio_pinconfig(COREMARK_GPIO, g_AM_HAL_GPIO_OUTPUT);
    df6e:	4b13      	ldr	r3, [pc, #76]	; (dfbc <portable_init+0xd4>)
    df70:	6819      	ldr	r1, [r3, #0]
    df72:	f002 f827 	bl	ffc4 <am_hal_gpio_pinconfig>

    //
    // Clear the terminal and print the banner.
    //
    am_util_stdio_terminal_clear();
    df76:	f001 fc4b 	bl	f810 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("Ambiq Micro Coremark test...\n\n");
    df7a:	4811      	ldr	r0, [pc, #68]	; (dfc0 <portable_init+0xd8>)
    df7c:	f001 fc2e 	bl	f7dc <am_util_stdio_printf>
            am_util_stdio_printf("Failed to Enable Burst Mode operation\n");
        }
    }
#endif // ENABLE_BURST_MODE

    am_hal_gpio_state_write(COREMARK_GPIO,AM_HAL_GPIO_OUTPUT_SET);
    df80:	4621      	mov	r1, r4
    df82:	4628      	mov	r0, r5
    df84:	f002 f954 	bl	10230 <am_hal_gpio_state_write>
    am_hal_flash_delay(FLASH_CYCLES_US(10));
    df88:	20a0      	movs	r0, #160	; 0xa0
    df8a:	f001 ffcb 	bl	ff24 <am_hal_flash_delay>
    am_hal_gpio_state_write(COREMARK_GPIO,AM_HAL_GPIO_OUTPUT_CLEAR);
    df8e:	4629      	mov	r1, r5
    df90:	4628      	mov	r0, r5
    df92:	f002 f94d 	bl	10230 <am_hal_gpio_state_write>
#endif // AM_PART_APOLLO3 || AM_PART_APOLLO3P
    //
    // To minimize power during the run, disable the UART.
    //
    am_bsp_uart_printf_disable();
    df96:	f001 fd41 	bl	fa1c <am_bsp_uart_printf_disable>
}
    df9a:	b003      	add	sp, #12
    df9c:	bd30      	pop	{r4, r5, pc}
    df9e:	bf00      	nop
    dfa0:	1000104c 	.word	0x1000104c
    dfa4:	10001048 	.word	0x10001048
    dfa8:	10001044 	.word	0x10001044
    dfac:	00011060 	.word	0x00011060
    dfb0:	00011488 	.word	0x00011488
    dfb4:	000114b8 	.word	0x000114b8
    dfb8:	000114e4 	.word	0x000114e4
    dfbc:	000116d0 	.word	0x000116d0
    dfc0:	00011504 	.word	0x00011504

0000dfc4 <portable_fini>:

/* Function : portable_fini
    Target specific final code
*/
void portable_fini(core_portable *p)
{
    dfc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    p->portable_id=0;
    dfc6:	2400      	movs	r4, #0

#if defined(AM_PART_APOLLO3)
    am_hal_gpio_state_write(COREMARK_GPIO, AM_HAL_GPIO_OUTPUT_SET);
    dfc8:	2101      	movs	r1, #1
    p->portable_id=0;
    dfca:	7004      	strb	r4, [r0, #0]
    am_hal_gpio_state_write(COREMARK_GPIO, AM_HAL_GPIO_OUTPUT_SET);
    dfcc:	4620      	mov	r0, r4
    dfce:	f002 f92f 	bl	10230 <am_hal_gpio_state_write>
    am_hal_flash_delay(FLASH_CYCLES_US(10));
    dfd2:	20a0      	movs	r0, #160	; 0xa0
    dfd4:	f001 ffa6 	bl	ff24 <am_hal_flash_delay>
    am_hal_gpio_state_write(COREMARK_GPIO, AM_HAL_GPIO_OUTPUT_CLEAR);
    dfd8:	4621      	mov	r1, r4
    dfda:	4620      	mov	r0, r4
    dfdc:	f002 f928 	bl	10230 <am_hal_gpio_state_write>
    //
    // Now that we're done, turn all memory back on.
    //
    if ( am_hal_pwrctrl_memory_enable(AM_HAL_PWRCTRL_MEM_ALL) )
    dfe0:	2011      	movs	r0, #17
    dfe2:	f002 fa63 	bl	104ac <am_hal_pwrctrl_memory_enable>
    dfe6:	b118      	cbz	r0, dff0 <portable_fini+0x2c>
    {
      am_util_stdio_printf("Failed to re-enable all memory\n");
    dfe8:	4835      	ldr	r0, [pc, #212]	; (e0c0 <portable_fini+0xfc>)
    dfea:	f001 fbf7 	bl	f7dc <am_util_stdio_printf>
      while(1);
    dfee:	e7fe      	b.n	dfee <portable_fini+0x2a>
    //
    // Now, let's go parse the buffer and print it out!
    //
    pcBuf = am_prtbuf;
    iCnt = 0;
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    dff0:	4c34      	ldr	r4, [pc, #208]	; (e0c4 <portable_fini+0x100>)
    dff2:	4605      	mov	r5, r0
    am_hal_cachectrl_config(&am_hal_cachectrl_defaults);
    dff4:	4834      	ldr	r0, [pc, #208]	; (e0c8 <portable_fini+0x104>)
    dff6:	f001 fd33 	bl	fa60 <am_hal_cachectrl_config>
    am_hal_cachectrl_enable();
    dffa:	f001 fd55 	bl	faa8 <am_hal_cachectrl_enable>
    am_bsp_uart_printf_enable();
    dffe:	f001 fcdf 	bl	f9c0 <am_bsp_uart_printf_enable>
    am_util_stdio_terminal_clear();
    e002:	f001 fc05 	bl	f810 <am_util_stdio_terminal_clear>
    am_util_stdio_printf("\nAmbiq Micro Coremark run finished!\n\n");
    e006:	4831      	ldr	r0, [pc, #196]	; (e0cc <portable_fini+0x108>)
    e008:	f001 fbe8 	bl	f7dc <am_util_stdio_printf>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    e00c:	7823      	ldrb	r3, [r4, #0]
    e00e:	b1ab      	cbz	r3, e03c <portable_fini+0x78>
    iCnt = 0;
    e010:	462e      	mov	r6, r5
    {
        am_util_stdio_printf(pcBuf);
    e012:	4620      	mov	r0, r4
    e014:	f001 fbe2 	bl	f7dc <am_util_stdio_printf>
        while ( *pcBuf != 0x00 )
    e018:	7823      	ldrb	r3, [r4, #0]
    e01a:	2b00      	cmp	r3, #0
    e01c:	d04c      	beq.n	e0b8 <portable_fini+0xf4>
    e01e:	1c63      	adds	r3, r4, #1
    e020:	1b34      	subs	r4, r6, r4
    e022:	7819      	ldrb	r1, [r3, #0]
        {
            pcBuf++;
    e024:	461a      	mov	r2, r3
            iCnt++;
    e026:	18e0      	adds	r0, r4, r3
        while ( *pcBuf != 0x00 )
    e028:	3301      	adds	r3, #1
    e02a:	2900      	cmp	r1, #0
    e02c:	d1f9      	bne.n	e022 <portable_fini+0x5e>
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    e02e:	7853      	ldrb	r3, [r2, #1]
        }
        iCnt++;     // Account for the NULL terminator
    e030:	1c46      	adds	r6, r0, #1
        pcBuf++;    // Point after the NULL terminator to the next string
    e032:	1c54      	adds	r4, r2, #1
    while ( (*pcBuf != 0x00)  &&  (iCnt<PRTBUFSIZE) )
    e034:	b113      	cbz	r3, e03c <portable_fini+0x78>
    e036:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
    e03a:	dbea      	blt.n	e012 <portable_fini+0x4e>
    }

    //
    // Disable the UART.
    //
    am_bsp_uart_printf_disable();
    e03c:	f001 fcee 	bl	fa1c <am_bsp_uart_printf_disable>
#if AM_BSP_NUM_LEDS
void set_leds(uint32_t mask, uint32_t delay);   // Function prototype
    //
    // Now for the grand finale, do a little something with the LEDs.
    //
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    e040:	4823      	ldr	r0, [pc, #140]	; (e0d0 <portable_fini+0x10c>)

    uint32_t ux, umask, umod;
    for (ux = 0; ux < (AM_BSP_NUM_LEDS * 4); ux++ )
    {
        umod = (ux % (AM_BSP_NUM_LEDS * 2));
    e042:	4e24      	ldr	r6, [pc, #144]	; (e0d4 <portable_fini+0x110>)
}

#if AM_BSP_NUM_LEDS
void set_leds(uint32_t mask, uint32_t delay)
{
    am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS, mask);
    e044:	4c22      	ldr	r4, [pc, #136]	; (e0d0 <portable_fini+0x10c>)
    am_devices_led_array_init(am_bsp_psLEDs, AM_BSP_NUM_LEDS);
    e046:	2105      	movs	r1, #5
    e048:	f000 fd42 	bl	ead0 <am_devices_led_array_init>
            umask = (1 << (AM_BSP_NUM_LEDS - 1)) >> (umod - AM_BSP_NUM_LEDS);
    e04c:	2710      	movs	r7, #16
        umod = (ux % (AM_BSP_NUM_LEDS * 2));
    e04e:	fba6 2305 	umull	r2, r3, r6, r5
    e052:	08db      	lsrs	r3, r3, #3
    e054:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    e058:	eba5 0343 	sub.w	r3, r5, r3, lsl #1
        if ( umod < AM_BSP_NUM_LEDS )
    e05c:	2b04      	cmp	r3, #4
            umask = (1 << (AM_BSP_NUM_LEDS - 1)) >> (umod - AM_BSP_NUM_LEDS);
    e05e:	f1a3 0c05 	sub.w	ip, r3, #5
            umask = 1 << umod;
    e062:	f04f 0201 	mov.w	r2, #1
    am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS, mask);
    e066:	f04f 0105 	mov.w	r1, #5
    e06a:	4620      	mov	r0, r4
    e06c:	fa02 f203 	lsl.w	r2, r2, r3
    e070:	bf82      	ittt	hi
    e072:	4620      	movhi	r0, r4
    e074:	fa47 f20c 	asrhi.w	r2, r7, ip
    e078:	2105      	movhi	r1, #5
    e07a:	f000 fd5b 	bl	eb34 <am_devices_led_array_out>
    for (ux = 0; ux < (AM_BSP_NUM_LEDS * 4); ux++ )
    e07e:	3501      	adds	r5, #1
    am_util_delay_ms(delay);
    e080:	20c8      	movs	r0, #200	; 0xc8
    e082:	f000 fdb5 	bl	ebf0 <am_util_delay_ms>
    for (ux = 0; ux < (AM_BSP_NUM_LEDS * 4); ux++ )
    e086:	2d14      	cmp	r5, #20
    e088:	d1e1      	bne.n	e04e <portable_fini+0x8a>
    am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS, mask);
    e08a:	4d11      	ldr	r5, [pc, #68]	; (e0d0 <portable_fini+0x10c>)
        while ( *pcBuf != 0x00 )
    e08c:	2403      	movs	r4, #3
    am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS, mask);
    e08e:	221f      	movs	r2, #31
    e090:	2105      	movs	r1, #5
    e092:	4628      	mov	r0, r5
    e094:	f000 fd4e 	bl	eb34 <am_devices_led_array_out>
    am_util_delay_ms(delay);
    e098:	f44f 7096 	mov.w	r0, #300	; 0x12c
    e09c:	f000 fda8 	bl	ebf0 <am_util_delay_ms>
    am_devices_led_array_out(am_bsp_psLEDs, AM_BSP_NUM_LEDS, mask);
    e0a0:	4628      	mov	r0, r5
    e0a2:	2200      	movs	r2, #0
    e0a4:	2105      	movs	r1, #5
    e0a6:	f000 fd45 	bl	eb34 <am_devices_led_array_out>
    am_util_delay_ms(delay);
    e0aa:	f44f 7096 	mov.w	r0, #300	; 0x12c
    e0ae:	f000 fd9f 	bl	ebf0 <am_util_delay_ms>
    for (ux = 0; ux < 3; ux++ )
    e0b2:	3c01      	subs	r4, #1
    e0b4:	d1eb      	bne.n	e08e <portable_fini+0xca>
}
    e0b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        while ( *pcBuf != 0x00 )
    e0b8:	4622      	mov	r2, r4
    e0ba:	4630      	mov	r0, r6
    e0bc:	e7b7      	b.n	e02e <portable_fini+0x6a>
    e0be:	bf00      	nop
    e0c0:	00011524 	.word	0x00011524
    e0c4:	1000104c 	.word	0x1000104c
    e0c8:	000116c8 	.word	0x000116c8
    e0cc:	00011544 	.word	0x00011544
    e0d0:	1000100c 	.word	0x1000100c
    e0d4:	cccccccd 	.word	0xcccccccd

0000e0d8 <am_sprintf>:
}
#endif // AM_BSP_NUM_LEDS

#if AM_PRINT_RESULTS
int am_sprintf(char *pcFmt, ...)
{
    e0d8:	b40f      	push	{r0, r1, r2, r3}
    e0da:	b570      	push	{r4, r5, r6, lr}
    uint32_t ui32NumChars;
    int iRet = 0;

    va_list pArgs;

    if ( am_bufcnt < PRTBUFSIZE )
    e0dc:	4c1d      	ldr	r4, [pc, #116]	; (e154 <am_sprintf+0x7c>)
    e0de:	6823      	ldr	r3, [r4, #0]
    e0e0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
{
    e0e4:	b082      	sub	sp, #8
    if ( am_bufcnt < PRTBUFSIZE )
    e0e6:	d305      	bcc.n	e0f4 <am_sprintf+0x1c>
    int iRet = 0;
    e0e8:	2000      	movs	r0, #0
        }
    } // if (am_bufcnt)

    return iRet;

} // am_sprintf()
    e0ea:	b002      	add	sp, #8
    e0ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e0f0:	b004      	add	sp, #16
    e0f2:	4770      	bx	lr
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    e0f4:	4d18      	ldr	r5, [pc, #96]	; (e158 <am_sprintf+0x80>)
    e0f6:	9906      	ldr	r1, [sp, #24]
    e0f8:	6828      	ldr	r0, [r5, #0]
        va_start(pArgs, pcFmt);
    e0fa:	aa07      	add	r2, sp, #28
    e0fc:	9201      	str	r2, [sp, #4]
        ui32NumChars = am_util_stdio_vsprintf(am_pcBuf, pcFmt, pArgs);
    e0fe:	f000 fee3 	bl	eec8 <am_util_stdio_vsprintf>
        if ( (am_bufcnt+ui32NumChars) >= PRTBUFSIZE )
    e102:	6823      	ldr	r3, [r4, #0]
    e104:	4403      	add	r3, r0
    e106:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    e10a:	d20e      	bcs.n	e12a <am_sprintf+0x52>
            am_bufcnt += ui32NumChars;
    e10c:	6821      	ldr	r1, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    e10e:	682b      	ldr	r3, [r5, #0]
            am_bufcnt += ui32NumChars;
    e110:	4401      	add	r1, r0
    e112:	6021      	str	r1, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    e114:	1c42      	adds	r2, r0, #1
    e116:	441a      	add	r2, r3
            am_bufcnt++;                // Include NULL terminator
    e118:	6823      	ldr	r3, [r4, #0]
            am_pcBuf++;                 // Skip NULL terminator
    e11a:	602a      	str	r2, [r5, #0]
            am_bufcnt++;                // Include NULL terminator
    e11c:	3301      	adds	r3, #1
    e11e:	6023      	str	r3, [r4, #0]
} // am_sprintf()
    e120:	b002      	add	sp, #8
    e122:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e126:	b004      	add	sp, #16
    e128:	4770      	bx	lr
            am_util_stdio_sprintf(&am_prtbuf[PRTBUFSIZE-(40+1)], "BUFFER OVERFLOWED! Increase PRTBUFSIZE\n");
    e12a:	4e0c      	ldr	r6, [pc, #48]	; (e15c <am_sprintf+0x84>)
    e12c:	490c      	ldr	r1, [pc, #48]	; (e160 <am_sprintf+0x88>)
    e12e:	f206 30d7 	addw	r0, r6, #983	; 0x3d7
    e132:	f001 fb45 	bl	f7c0 <am_util_stdio_sprintf>
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    e136:	f506 6380 	add.w	r3, r6, #1024	; 0x400
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    e13a:	2000      	movs	r0, #0
            am_pcBuf = &am_prtbuf[PRTBUFSIZE];  // Don't allow any further printing
    e13c:	602b      	str	r3, [r5, #0]
            am_bufcnt = PRTBUFSIZE;             //  "
    e13e:	f44f 6380 	mov.w	r3, #1024	; 0x400
            am_prtbuf[PRTBUFSIZE-1] = 0x00;     // Double terminate the buffer
    e142:	f886 03ff 	strb.w	r0, [r6, #1023]	; 0x3ff
            am_bufcnt = PRTBUFSIZE;             //  "
    e146:	6023      	str	r3, [r4, #0]
} // am_sprintf()
    e148:	b002      	add	sp, #8
    e14a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e14e:	b004      	add	sp, #16
    e150:	4770      	bx	lr
    e152:	bf00      	nop
    e154:	10001044 	.word	0x10001044
    e158:	10001048 	.word	0x10001048
    e15c:	1000104c 	.word	0x1000104c
    e160:	0001156c 	.word	0x0001156c

0000e164 <core_init_state>:
    Actual patterns chosen depend on the seed parameter.

    Note:
    The seed parameter MUST be supplied from a source that cannot be determined at compile time
*/
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    e164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee_u8 *buf=0;
#if CORE_DEBUG
    ee_u8 *start=p;
    ee_printf("State: %d,%d\n",size,seed);
#endif
    size--;
    e168:	1e45      	subs	r5, r0, #1
    next=0;
    while ((total+next+1)<size) {
    e16a:	2d01      	cmp	r5, #1
void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {
    e16c:	4614      	mov	r4, r2
    while ((total+next+1)<size) {
    e16e:	d976      	bls.n	e25e <core_init_state+0xfa>
    e170:	3101      	adds	r1, #1
            case 6: /* scientific */
                buf=scipat[(seed>>3) & 0x3];
                next=8;
            break;
            case 7: /* invalid */
                buf=errpat[(seed>>3) & 0x3];
    e172:	f8df 90f8 	ldr.w	r9, [pc, #248]	; e26c <core_init_state+0x108>
                buf=scipat[(seed>>3) & 0x3];
    e176:	f8df 80f8 	ldr.w	r8, [pc, #248]	; e270 <core_init_state+0x10c>
                buf=floatpat[(seed>>3) & 0x3];
    e17a:	4f3a      	ldr	r7, [pc, #232]	; (e264 <core_init_state+0x100>)
                buf=intpat[(seed>>3) & 0x3];
    e17c:	4e3a      	ldr	r6, [pc, #232]	; (e268 <core_init_state+0x104>)
    e17e:	fa1f fe81 	uxth.w	lr, r1
    ee_u32 total=0,next=0,i;
    e182:	f04f 0c00 	mov.w	ip, #0
            *(p+total+i)=',';
    e186:	222c      	movs	r2, #44	; 0x2c
    e188:	e03b      	b.n	e202 <core_init_state+0x9e>
        switch (seed & 0x7) {
    e18a:	2b04      	cmp	r3, #4
    e18c:	d85c      	bhi.n	e248 <core_init_state+0xe4>
    e18e:	3b03      	subs	r3, #3
    e190:	2b01      	cmp	r3, #1
                buf=floatpat[(seed>>3) & 0x3];
    e192:	f3c1 01c1 	ubfx	r1, r1, #3, #2
        switch (seed & 0x7) {
    e196:	d850      	bhi.n	e23a <core_init_state+0xd6>
                buf=floatpat[(seed>>3) & 0x3];
    e198:	f857 3021 	ldr.w	r3, [r7, r1, lsl #2]
            break;
    e19c:	f04f 0a09 	mov.w	sl, #9
                next=8;
    e1a0:	f04f 0b08 	mov.w	fp, #8
    while ((total+next+1)<size) {
    e1a4:	44e2      	add	sl, ip
    e1a6:	45aa      	cmp	sl, r5
    e1a8:	d23c      	bcs.n	e224 <core_init_state+0xc0>
                *(p+total+i)=buf[i];
    e1aa:	7819      	ldrb	r1, [r3, #0]
    e1ac:	f804 100c 	strb.w	r1, [r4, ip]
    e1b0:	eb04 010c 	add.w	r1, r4, ip
    e1b4:	f893 c001 	ldrb.w	ip, [r3, #1]
    e1b8:	f881 c001 	strb.w	ip, [r1, #1]
    e1bc:	f893 c002 	ldrb.w	ip, [r3, #2]
    e1c0:	f881 c002 	strb.w	ip, [r1, #2]
    e1c4:	f893 c003 	ldrb.w	ip, [r3, #3]
    e1c8:	f881 c003 	strb.w	ip, [r1, #3]
            for(i=0;i<next;i++)
    e1cc:	f1bb 0f04 	cmp.w	fp, #4
    e1d0:	d010      	beq.n	e1f4 <core_init_state+0x90>
                *(p+total+i)=buf[i];
    e1d2:	f893 c004 	ldrb.w	ip, [r3, #4]
    e1d6:	f881 c004 	strb.w	ip, [r1, #4]
    e1da:	f893 c005 	ldrb.w	ip, [r3, #5]
    e1de:	f881 c005 	strb.w	ip, [r1, #5]
    e1e2:	f893 c006 	ldrb.w	ip, [r3, #6]
    e1e6:	f881 c006 	strb.w	ip, [r1, #6]
            for(i=0;i<next;i++)
    e1ea:	f1bb 0f08 	cmp.w	fp, #8
                *(p+total+i)=buf[i];
    e1ee:	bf04      	itt	eq
    e1f0:	79db      	ldrbeq	r3, [r3, #7]
    e1f2:	71cb      	strbeq	r3, [r1, #7]
            *(p+total+i)=',';
    e1f4:	f10e 0e01 	add.w	lr, lr, #1
    e1f8:	f801 200b 	strb.w	r2, [r1, fp]
            total+=next+1;
    e1fc:	fa1f fe8e 	uxth.w	lr, lr
            *(p+total+i)=',';
    e200:	46d4      	mov	ip, sl
        seed++;
    e202:	f00e 0307 	and.w	r3, lr, #7
        switch (seed & 0x7) {
    e206:	2b07      	cmp	r3, #7
        seed++;
    e208:	fa0f f18e 	sxth.w	r1, lr
        switch (seed & 0x7) {
    e20c:	d1bd      	bne.n	e18a <core_init_state+0x26>
                next=8;
            break;
    e20e:	f04f 0a09 	mov.w	sl, #9
                buf=errpat[(seed>>3) & 0x3];
    e212:	f3c1 01c1 	ubfx	r1, r1, #3, #2
    while ((total+next+1)<size) {
    e216:	44e2      	add	sl, ip
    e218:	45aa      	cmp	sl, r5
                buf=errpat[(seed>>3) & 0x3];
    e21a:	f859 3021 	ldr.w	r3, [r9, r1, lsl #2]
                next=8;
    e21e:	f04f 0b08 	mov.w	fp, #8
    while ((total+next+1)<size) {
    e222:	d3c2      	bcc.n	e1aa <core_init_state+0x46>
            default: /* Never happen, just to make some compilers happy */
            break;
        }
    }
    size++;
    while (total<size) { /* fill the rest with 0 */
    e224:	4584      	cmp	ip, r0
    e226:	d218      	bcs.n	e25a <core_init_state+0xf6>
        *(p+total)=0;
    e228:	eba0 020c 	sub.w	r2, r0, ip
    e22c:	2100      	movs	r1, #0
    e22e:	eb04 000c 	add.w	r0, r4, ip
        total++;
    }
#if CORE_DEBUG
    ee_printf("State Input: %s\n",start);
#endif
}
    e232:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        *(p+total)=0;
    e236:	f001 bb2b 	b.w	f890 <memset>
                buf=intpat[(seed>>3) & 0x3];
    e23a:	f856 3021 	ldr.w	r3, [r6, r1, lsl #2]
            break;
    e23e:	f04f 0a05 	mov.w	sl, #5
                next=4;
    e242:	f04f 0b04 	mov.w	fp, #4
            break;
    e246:	e7ad      	b.n	e1a4 <core_init_state+0x40>
                buf=scipat[(seed>>3) & 0x3];
    e248:	f3c1 01c1 	ubfx	r1, r1, #3, #2
            break;
    e24c:	f04f 0a09 	mov.w	sl, #9
                buf=scipat[(seed>>3) & 0x3];
    e250:	f858 3021 	ldr.w	r3, [r8, r1, lsl #2]
                next=8;
    e254:	f04f 0b08 	mov.w	fp, #8
            break;
    e258:	e7a4      	b.n	e1a4 <core_init_state+0x40>
}
    e25a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ee_u32 total=0,next=0,i;
    e25e:	f04f 0c00 	mov.w	ip, #0
    e262:	e7e1      	b.n	e228 <core_init_state+0xc4>
    e264:	00011654 	.word	0x00011654
    e268:	00011664 	.word	0x00011664
    e26c:	00011644 	.word	0x00011644
    e270:	00011674 	.word	0x00011674

0000e274 <core_state_transition>:
    2 - a valid number has been detected.

    The input pointer is updated to point to the end of the token, and the end state is returned (either specific format determined or invalid).
*/

enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    e274:	b510      	push	{r4, lr}
    ee_u8 *str=*instr;
    e276:	6803      	ldr	r3, [r0, #0]
enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {
    e278:	4686      	mov	lr, r0
    ee_u8 NEXT_SYMBOL;
    enum CORE_STATE state=CORE_START;
    for( ; *str && state != CORE_INVALID; str++ ) {
    e27a:	7818      	ldrb	r0, [r3, #0]
    e27c:	2800      	cmp	r0, #0
    e27e:	d03e      	beq.n	e2fe <core_state_transition+0x8a>
        NEXT_SYMBOL = *str;
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e280:	282c      	cmp	r0, #44	; 0x2c
    e282:	f000 80bf 	beq.w	e404 <core_state_transition+0x190>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e286:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
    e28a:	2a09      	cmp	r2, #9
    e28c:	d83a      	bhi.n	e304 <core_state_transition+0x90>
            }
            else {
                state = CORE_INVALID;
                transition_count[CORE_INVALID]++;
            }
            transition_count[CORE_START]++;
    e28e:	680a      	ldr	r2, [r1, #0]
    e290:	3201      	adds	r2, #1
    e292:	600a      	str	r2, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e294:	785a      	ldrb	r2, [r3, #1]
    e296:	1c58      	adds	r0, r3, #1
    e298:	2a00      	cmp	r2, #0
    e29a:	d06d      	beq.n	e378 <core_state_transition+0x104>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e29c:	2a2c      	cmp	r2, #44	; 0x2c
    e29e:	f000 80d5 	beq.w	e44c <core_state_transition+0x1d8>
                state = CORE_INVALID;
                transition_count[CORE_S1]++;
            }
            break;
        case CORE_INT:
            if( NEXT_SYMBOL == '.' ) {
    e2a2:	2a2e      	cmp	r2, #46	; 0x2e
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e2a4:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
            if( NEXT_SYMBOL == '.' ) {
    e2a8:	d00e      	beq.n	e2c8 <core_state_transition+0x54>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e2aa:	2b09      	cmp	r3, #9
    e2ac:	d83c      	bhi.n	e328 <core_state_transition+0xb4>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e2ae:	7842      	ldrb	r2, [r0, #1]
    e2b0:	1c43      	adds	r3, r0, #1
    e2b2:	2a00      	cmp	r2, #0
    e2b4:	f000 80d6 	beq.w	e464 <core_state_transition+0x1f0>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e2b8:	2a2c      	cmp	r2, #44	; 0x2c
    e2ba:	f000 80d1 	beq.w	e460 <core_state_transition+0x1ec>
            if( NEXT_SYMBOL == '.' ) {
    e2be:	2a2e      	cmp	r2, #46	; 0x2e
    for( ; *str && state != CORE_INVALID; str++ ) {
    e2c0:	4618      	mov	r0, r3
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e2c2:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
            if( NEXT_SYMBOL == '.' ) {
    e2c6:	d1f0      	bne.n	e2aa <core_state_transition+0x36>
                state = CORE_FLOAT;
                transition_count[CORE_INT]++;
    e2c8:	690b      	ldr	r3, [r1, #16]
    e2ca:	3301      	adds	r3, #1
    e2cc:	610b      	str	r3, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e2ce:	7842      	ldrb	r2, [r0, #1]
    e2d0:	f100 0c01 	add.w	ip, r0, #1
    e2d4:	2a00      	cmp	r2, #0
    e2d6:	f000 80aa 	beq.w	e42e <core_state_transition+0x1ba>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e2da:	2a2c      	cmp	r2, #44	; 0x2c
    e2dc:	f000 80bb 	beq.w	e456 <core_state_transition+0x1e2>
                state = CORE_INVALID;
                transition_count[CORE_INT]++;
            }
            break;
        case CORE_FLOAT:
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    e2e0:	f002 03df 	and.w	r3, r2, #223	; 0xdf
    e2e4:	2b45      	cmp	r3, #69	; 0x45
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e2e6:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30
            if( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {
    e2ea:	d048      	beq.n	e37e <core_state_transition+0x10a>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e2ec:	2a09      	cmp	r2, #9
    e2ee:	f240 808c 	bls.w	e40a <core_state_transition+0x196>
                state = CORE_S2;
                transition_count[CORE_FLOAT]++;
            }
            else if(!ee_isdigit(NEXT_SYMBOL)) {
                state = CORE_INVALID;
                transition_count[CORE_FLOAT]++;
    e2f2:	694a      	ldr	r2, [r1, #20]
    e2f4:	3201      	adds	r2, #1
    for( ; *str && state != CORE_INVALID; str++ ) {
    e2f6:	f10c 0301 	add.w	r3, ip, #1
                transition_count[CORE_FLOAT]++;
    e2fa:	614a      	str	r2, [r1, #20]
                state = CORE_INVALID;
    e2fc:	2001      	movs	r0, #1
            break;
        default:
            break;
        }
    }
    *instr=str;
    e2fe:	f8ce 3000 	str.w	r3, [lr]
    return state;
}
    e302:	bd10      	pop	{r4, pc}
            else if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    e304:	282b      	cmp	r0, #43	; 0x2b
    e306:	d017      	beq.n	e338 <core_state_transition+0xc4>
    e308:	282d      	cmp	r0, #45	; 0x2d
    e30a:	d015      	beq.n	e338 <core_state_transition+0xc4>
            else if( NEXT_SYMBOL == '.' ) {
    e30c:	282e      	cmp	r0, #46	; 0x2e
    e30e:	f000 8085 	beq.w	e41c <core_state_transition+0x1a8>
            transition_count[CORE_START]++;
    e312:	e9d1 2000 	ldrd	r2, r0, [r1]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e316:	3301      	adds	r3, #1
                transition_count[CORE_INVALID]++;
    e318:	3001      	adds	r0, #1
            transition_count[CORE_START]++;
    e31a:	3201      	adds	r2, #1
    e31c:	e9c1 2000 	strd	r2, r0, [r1]
                state = CORE_INVALID;
    e320:	2001      	movs	r0, #1
    *instr=str;
    e322:	f8ce 3000 	str.w	r3, [lr]
}
    e326:	bd10      	pop	{r4, pc}
                transition_count[CORE_INT]++;
    e328:	690a      	ldr	r2, [r1, #16]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e32a:	1c43      	adds	r3, r0, #1
                transition_count[CORE_INT]++;
    e32c:	3201      	adds	r2, #1
    e32e:	610a      	str	r2, [r1, #16]
                state = CORE_INVALID;
    e330:	2001      	movs	r0, #1
    *instr=str;
    e332:	f8ce 3000 	str.w	r3, [lr]
}
    e336:	bd10      	pop	{r4, pc}
            transition_count[CORE_START]++;
    e338:	680a      	ldr	r2, [r1, #0]
    e33a:	3201      	adds	r2, #1
    e33c:	600a      	str	r2, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e33e:	1c5c      	adds	r4, r3, #1
    e340:	785b      	ldrb	r3, [r3, #1]
    e342:	2b00      	cmp	r3, #0
    e344:	f000 8090 	beq.w	e468 <core_state_transition+0x1f4>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e348:	2b2c      	cmp	r3, #44	; 0x2c
    e34a:	f000 8090 	beq.w	e46e <core_state_transition+0x1fa>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e34e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    e352:	2a09      	cmp	r2, #9
    e354:	d909      	bls.n	e36a <core_state_transition+0xf6>
            else if( NEXT_SYMBOL == '.' ) {
    e356:	2b2e      	cmp	r3, #46	; 0x2e
    e358:	d06c      	beq.n	e434 <core_state_transition+0x1c0>
                transition_count[CORE_S1]++;
    e35a:	688a      	ldr	r2, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e35c:	1c63      	adds	r3, r4, #1
                transition_count[CORE_S1]++;
    e35e:	3201      	adds	r2, #1
    e360:	608a      	str	r2, [r1, #8]
                state = CORE_INVALID;
    e362:	2001      	movs	r0, #1
    *instr=str;
    e364:	f8ce 3000 	str.w	r3, [lr]
}
    e368:	bd10      	pop	{r4, pc}
                transition_count[CORE_S1]++;
    e36a:	688b      	ldr	r3, [r1, #8]
    e36c:	3301      	adds	r3, #1
    e36e:	608b      	str	r3, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e370:	7862      	ldrb	r2, [r4, #1]
    e372:	1c60      	adds	r0, r4, #1
    e374:	2a00      	cmp	r2, #0
    e376:	d191      	bne.n	e29c <core_state_transition+0x28>
    e378:	4603      	mov	r3, r0
                state = CORE_INT;
    e37a:	2004      	movs	r0, #4
    e37c:	e7bf      	b.n	e2fe <core_state_transition+0x8a>
                transition_count[CORE_FLOAT]++;
    e37e:	694a      	ldr	r2, [r1, #20]
    e380:	3201      	adds	r2, #1
    e382:	614a      	str	r2, [r1, #20]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e384:	f89c 2001 	ldrb.w	r2, [ip, #1]
    e388:	f10c 0301 	add.w	r3, ip, #1
    e38c:	2a00      	cmp	r2, #0
    e38e:	d060      	beq.n	e452 <core_state_transition+0x1de>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e390:	2a2c      	cmp	r2, #44	; 0x2c
                state = CORE_S2;
    e392:	bf08      	it	eq
    e394:	2003      	moveq	r0, #3
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e396:	d036      	beq.n	e406 <core_state_transition+0x192>
            if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {
    e398:	2a2b      	cmp	r2, #43	; 0x2b
    e39a:	d00a      	beq.n	e3b2 <core_state_transition+0x13e>
    e39c:	2a2d      	cmp	r2, #45	; 0x2d
    e39e:	d008      	beq.n	e3b2 <core_state_transition+0x13e>
                transition_count[CORE_S2]++;
    e3a0:	68ca      	ldr	r2, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3a2:	f10c 0302 	add.w	r3, ip, #2
                transition_count[CORE_S2]++;
    e3a6:	3201      	adds	r2, #1
    e3a8:	60ca      	str	r2, [r1, #12]
                state = CORE_INVALID;
    e3aa:	2001      	movs	r0, #1
    *instr=str;
    e3ac:	f8ce 3000 	str.w	r3, [lr]
}
    e3b0:	bd10      	pop	{r4, pc}
                transition_count[CORE_S2]++;
    e3b2:	68ca      	ldr	r2, [r1, #12]
    e3b4:	3201      	adds	r2, #1
    e3b6:	60ca      	str	r2, [r1, #12]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3b8:	f89c 2002 	ldrb.w	r2, [ip, #2]
    e3bc:	f10c 0302 	add.w	r3, ip, #2
                state = CORE_EXPONENT;
    e3c0:	2006      	movs	r0, #6
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3c2:	2a00      	cmp	r2, #0
    e3c4:	d09b      	beq.n	e2fe <core_state_transition+0x8a>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e3c6:	2a2c      	cmp	r2, #44	; 0x2c
    e3c8:	d048      	beq.n	e45c <core_state_transition+0x1e8>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e3ca:	3a30      	subs	r2, #48	; 0x30
    e3cc:	2a09      	cmp	r2, #9
                transition_count[CORE_EXPONENT]++;
    e3ce:	698a      	ldr	r2, [r1, #24]
    e3d0:	f102 0201 	add.w	r2, r2, #1
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3d4:	f10c 0303 	add.w	r3, ip, #3
                transition_count[CORE_EXPONENT]++;
    e3d8:	618a      	str	r2, [r1, #24]
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e3da:	d80b      	bhi.n	e3f4 <core_state_transition+0x180>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3dc:	f89c 2003 	ldrb.w	r2, [ip, #3]
    e3e0:	b172      	cbz	r2, e400 <core_state_transition+0x18c>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e3e2:	2a2c      	cmp	r2, #44	; 0x2c
    e3e4:	d030      	beq.n	e448 <core_state_transition+0x1d4>
    retval = ((c>='0') & (c<='9')) ? 1 : 0;
    e3e6:	3a30      	subs	r2, #48	; 0x30
    e3e8:	2a09      	cmp	r2, #9
    e3ea:	d905      	bls.n	e3f8 <core_state_transition+0x184>
                transition_count[CORE_INVALID]++;
    e3ec:	684a      	ldr	r2, [r1, #4]
    e3ee:	3201      	adds	r2, #1
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3f0:	3301      	adds	r3, #1
                transition_count[CORE_INVALID]++;
    e3f2:	604a      	str	r2, [r1, #4]
                state = CORE_INVALID;
    e3f4:	2001      	movs	r0, #1
    e3f6:	e782      	b.n	e2fe <core_state_transition+0x8a>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e3f8:	785a      	ldrb	r2, [r3, #1]
    e3fa:	3301      	adds	r3, #1
    e3fc:	2a00      	cmp	r2, #0
    e3fe:	d1f0      	bne.n	e3e2 <core_state_transition+0x16e>
    e400:	2007      	movs	r0, #7
    e402:	e77c      	b.n	e2fe <core_state_transition+0x8a>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e404:	2000      	movs	r0, #0
            str++;
    e406:	3301      	adds	r3, #1
            break;
    e408:	e779      	b.n	e2fe <core_state_transition+0x8a>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e40a:	f89c 2001 	ldrb.w	r2, [ip, #1]
    e40e:	f10c 0301 	add.w	r3, ip, #1
    e412:	b37a      	cbz	r2, e474 <core_state_transition+0x200>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e414:	2a2c      	cmp	r2, #44	; 0x2c
    e416:	d02f      	beq.n	e478 <core_state_transition+0x204>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e418:	469c      	mov	ip, r3
    e41a:	e761      	b.n	e2e0 <core_state_transition+0x6c>
            transition_count[CORE_START]++;
    e41c:	680a      	ldr	r2, [r1, #0]
    e41e:	3201      	adds	r2, #1
    e420:	600a      	str	r2, [r1, #0]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e422:	785a      	ldrb	r2, [r3, #1]
    e424:	f103 0c01 	add.w	ip, r3, #1
    e428:	2a00      	cmp	r2, #0
    e42a:	f47f af56 	bne.w	e2da <core_state_transition+0x66>
    e42e:	4663      	mov	r3, ip
                state = CORE_FLOAT;
    e430:	2005      	movs	r0, #5
    e432:	e764      	b.n	e2fe <core_state_transition+0x8a>
                transition_count[CORE_S1]++;
    e434:	688b      	ldr	r3, [r1, #8]
    e436:	3301      	adds	r3, #1
    e438:	608b      	str	r3, [r1, #8]
    for( ; *str && state != CORE_INVALID; str++ ) {
    e43a:	7862      	ldrb	r2, [r4, #1]
    e43c:	f104 0c01 	add.w	ip, r4, #1
    e440:	2a00      	cmp	r2, #0
    e442:	f47f af4a 	bne.w	e2da <core_state_transition+0x66>
    e446:	e7f2      	b.n	e42e <core_state_transition+0x1ba>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e448:	2007      	movs	r0, #7
    e44a:	e7dc      	b.n	e406 <core_state_transition+0x192>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e44c:	4603      	mov	r3, r0
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e44e:	2004      	movs	r0, #4
    e450:	e7d9      	b.n	e406 <core_state_transition+0x192>
                state = CORE_S2;
    e452:	2003      	movs	r0, #3
    e454:	e753      	b.n	e2fe <core_state_transition+0x8a>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e456:	4663      	mov	r3, ip
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e458:	2005      	movs	r0, #5
    e45a:	e7d4      	b.n	e406 <core_state_transition+0x192>
                state = CORE_EXPONENT;
    e45c:	2006      	movs	r0, #6
    e45e:	e7d2      	b.n	e406 <core_state_transition+0x192>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e460:	2004      	movs	r0, #4
    e462:	e7d0      	b.n	e406 <core_state_transition+0x192>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e464:	2004      	movs	r0, #4
    e466:	e74a      	b.n	e2fe <core_state_transition+0x8a>
    e468:	4623      	mov	r3, r4
                state = CORE_S1;
    e46a:	2002      	movs	r0, #2
    e46c:	e747      	b.n	e2fe <core_state_transition+0x8a>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e46e:	4623      	mov	r3, r4
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e470:	2002      	movs	r0, #2
    e472:	e7c8      	b.n	e406 <core_state_transition+0x192>
    for( ; *str && state != CORE_INVALID; str++ ) {
    e474:	2005      	movs	r0, #5
    e476:	e742      	b.n	e2fe <core_state_transition+0x8a>
        if (NEXT_SYMBOL==',') /* end of this input */ {
    e478:	2005      	movs	r0, #5
    e47a:	e7c4      	b.n	e406 <core_state_transition+0x192>

0000e47c <core_bench_state>:
{
    e47c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e480:	b093      	sub	sp, #76	; 0x4c
    e482:	460c      	mov	r4, r1
    ee_u8 *p=memblock;
    e484:	9101      	str	r1, [sp, #4]
{
    e486:	4683      	mov	fp, r0
        final_counts[i]=track_counts[i]=0;
    e488:	2100      	movs	r1, #0
{
    e48a:	4692      	mov	sl, r2
        final_counts[i]=track_counts[i]=0;
    e48c:	a80a      	add	r0, sp, #40	; 0x28
    e48e:	2220      	movs	r2, #32
{
    e490:	4699      	mov	r9, r3
    e492:	f9bd 8070 	ldrsh.w	r8, [sp, #112]	; 0x70
    e496:	f8bd 7074 	ldrh.w	r7, [sp, #116]	; 0x74
        final_counts[i]=track_counts[i]=0;
    e49a:	f001 f9f9 	bl	f890 <memset>
    e49e:	2220      	movs	r2, #32
    e4a0:	2100      	movs	r1, #0
    e4a2:	a802      	add	r0, sp, #8
    e4a4:	f001 f9f4 	bl	f890 <memset>
    while (*p!=0) {
    e4a8:	7823      	ldrb	r3, [r4, #0]
    e4aa:	2b00      	cmp	r3, #0
    e4ac:	d05c      	beq.n	e568 <core_bench_state+0xec>
    e4ae:	ae01      	add	r6, sp, #4
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    e4b0:	a90a      	add	r1, sp, #40	; 0x28
    e4b2:	4630      	mov	r0, r6
    e4b4:	f7ff fede 	bl	e274 <core_state_transition>
        final_counts[fstate]++;
    e4b8:	ab12      	add	r3, sp, #72	; 0x48
    e4ba:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    while (*p!=0) {
    e4be:	9a01      	ldr	r2, [sp, #4]
        final_counts[fstate]++;
    e4c0:	f850 3c40 	ldr.w	r3, [r0, #-64]
    while (*p!=0) {
    e4c4:	7812      	ldrb	r2, [r2, #0]
        final_counts[fstate]++;
    e4c6:	3301      	adds	r3, #1
    e4c8:	f840 3c40 	str.w	r3, [r0, #-64]
    while (*p!=0) {
    e4cc:	2a00      	cmp	r2, #0
    e4ce:	d1ef      	bne.n	e4b0 <core_bench_state+0x34>
    while (p < (memblock+blksize)) { /* insert some corruption */
    e4d0:	44a3      	add	fp, r4
    e4d2:	45a3      	cmp	fp, r4
    while (*p!=0) {
    e4d4:	7823      	ldrb	r3, [r4, #0]
    p=memblock;
    e4d6:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    e4d8:	d943      	bls.n	e562 <core_bench_state+0xe6>
        p+=step;
    e4da:	4625      	mov	r5, r4
    e4dc:	e006      	b.n	e4ec <core_bench_state+0x70>
            *p^=(ee_u8)seed1;
    e4de:	702a      	strb	r2, [r5, #0]
        p+=step;
    e4e0:	9d01      	ldr	r5, [sp, #4]
    e4e2:	4445      	add	r5, r8
    while (p < (memblock+blksize)) { /* insert some corruption */
    e4e4:	455d      	cmp	r5, fp
        p+=step;
    e4e6:	9501      	str	r5, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    e4e8:	d208      	bcs.n	e4fc <core_bench_state+0x80>
        if (*p!=',')
    e4ea:	782b      	ldrb	r3, [r5, #0]
    e4ec:	2b2c      	cmp	r3, #44	; 0x2c
            *p^=(ee_u8)seed1;
    e4ee:	ea83 020a 	eor.w	r2, r3, sl
        if (*p!=',')
    e4f2:	d1f4      	bne.n	e4de <core_bench_state+0x62>
        p+=step;
    e4f4:	4445      	add	r5, r8
    while (p < (memblock+blksize)) { /* insert some corruption */
    e4f6:	455d      	cmp	r5, fp
        p+=step;
    e4f8:	9501      	str	r5, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    e4fa:	d3f6      	bcc.n	e4ea <core_bench_state+0x6e>
    while (*p!=0) {
    e4fc:	7823      	ldrb	r3, [r4, #0]
    p=memblock;
    e4fe:	9401      	str	r4, [sp, #4]
    while (*p!=0) {
    e500:	b193      	cbz	r3, e528 <core_bench_state+0xac>
        enum CORE_STATE fstate=core_state_transition(&p,track_counts);
    e502:	a90a      	add	r1, sp, #40	; 0x28
    e504:	4630      	mov	r0, r6
    e506:	f7ff feb5 	bl	e274 <core_state_transition>
        final_counts[fstate]++;
    e50a:	ab12      	add	r3, sp, #72	; 0x48
    e50c:	eb03 0280 	add.w	r2, r3, r0, lsl #2
    while (*p!=0) {
    e510:	9901      	ldr	r1, [sp, #4]
        final_counts[fstate]++;
    e512:	f852 3c40 	ldr.w	r3, [r2, #-64]
    while (*p!=0) {
    e516:	7809      	ldrb	r1, [r1, #0]
        final_counts[fstate]++;
    e518:	3301      	adds	r3, #1
    e51a:	f842 3c40 	str.w	r3, [r2, #-64]
    while (*p!=0) {
    e51e:	2900      	cmp	r1, #0
    e520:	d1ef      	bne.n	e502 <core_bench_state+0x86>
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    e522:	455c      	cmp	r4, fp
        p+=step;
    e524:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    e526:	d20a      	bcs.n	e53e <core_bench_state+0xc2>
        if (*p!=',')
    e528:	7823      	ldrb	r3, [r4, #0]
    e52a:	2b2c      	cmp	r3, #44	; 0x2c
            *p^=(ee_u8)seed2;
    e52c:	ea83 0209 	eor.w	r2, r3, r9
    e530:	bf1c      	itt	ne
    e532:	7022      	strbne	r2, [r4, #0]
        p+=step;
    e534:	9c01      	ldrne	r4, [sp, #4]
    e536:	4444      	add	r4, r8
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    e538:	455c      	cmp	r4, fp
        p+=step;
    e53a:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* undo corruption is seed1 and seed2 are equal */
    e53c:	d3f4      	bcc.n	e528 <core_bench_state+0xac>
    e53e:	ac09      	add	r4, sp, #36	; 0x24
    e540:	4625      	mov	r5, r4
        crc=crcu32(final_counts[i],crc);
    e542:	4639      	mov	r1, r7
    e544:	f856 0f04 	ldr.w	r0, [r6, #4]!
    e548:	f000 f8da 	bl	e700 <crcu32>
    e54c:	4601      	mov	r1, r0
        crc=crcu32(track_counts[i],crc);
    e54e:	f854 0f04 	ldr.w	r0, [r4, #4]!
    e552:	f000 f8d5 	bl	e700 <crcu32>
    for (i=0; i<NUM_CORE_STATES; i++) {
    e556:	42ae      	cmp	r6, r5
        crc=crcu32(track_counts[i],crc);
    e558:	4607      	mov	r7, r0
    for (i=0; i<NUM_CORE_STATES; i++) {
    e55a:	d1f2      	bne.n	e542 <core_bench_state+0xc6>
}
    e55c:	b013      	add	sp, #76	; 0x4c
    e55e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while (*p!=0) {
    e562:	2b00      	cmp	r3, #0
    e564:	d1cd      	bne.n	e502 <core_bench_state+0x86>
    e566:	e7ea      	b.n	e53e <core_bench_state+0xc2>
    while (p < (memblock+blksize)) { /* insert some corruption */
    e568:	44a3      	add	fp, r4
    e56a:	45a3      	cmp	fp, r4
    p=memblock;
    e56c:	9401      	str	r4, [sp, #4]
    while (p < (memblock+blksize)) { /* insert some corruption */
    e56e:	ae01      	add	r6, sp, #4
    e570:	d8b3      	bhi.n	e4da <core_bench_state+0x5e>
    e572:	e7e4      	b.n	e53e <core_bench_state+0xc2>

0000e574 <get_seed_32>:
    extern volatile ee_s32 seed3_volatile;
    extern volatile ee_s32 seed4_volatile;
    extern volatile ee_s32 seed5_volatile;
    ee_s32 get_seed_32(int i) {
        ee_s32 retval;
        switch (i) {
    e574:	3801      	subs	r0, #1
    e576:	2804      	cmp	r0, #4
    e578:	d813      	bhi.n	e5a2 <get_seed_32+0x2e>
    e57a:	e8df f000 	tbb	[pc, r0]
    e57e:	0906      	.short	0x0906
    e580:	0f0c      	.short	0x0f0c
    e582:	03          	.byte	0x03
    e583:	00          	.byte	0x00
                break;
            case 4:
                retval=seed4_volatile;
                break;
            case 5:
                retval=seed5_volatile;
    e584:	4b08      	ldr	r3, [pc, #32]	; (e5a8 <get_seed_32+0x34>)
    e586:	6818      	ldr	r0, [r3, #0]
                break;
    e588:	4770      	bx	lr
                retval=seed1_volatile;
    e58a:	4b08      	ldr	r3, [pc, #32]	; (e5ac <get_seed_32+0x38>)
    e58c:	6818      	ldr	r0, [r3, #0]
                break;
    e58e:	4770      	bx	lr
                retval=seed2_volatile;
    e590:	4b07      	ldr	r3, [pc, #28]	; (e5b0 <get_seed_32+0x3c>)
    e592:	6818      	ldr	r0, [r3, #0]
                break;
    e594:	4770      	bx	lr
                retval=seed3_volatile;
    e596:	4b07      	ldr	r3, [pc, #28]	; (e5b4 <get_seed_32+0x40>)
    e598:	6818      	ldr	r0, [r3, #0]
                break;
    e59a:	4770      	bx	lr
                retval=seed4_volatile;
    e59c:	4b06      	ldr	r3, [pc, #24]	; (e5b8 <get_seed_32+0x44>)
    e59e:	6818      	ldr	r0, [r3, #0]
                break;
    e5a0:	4770      	bx	lr
        switch (i) {
    e5a2:	2000      	movs	r0, #0
            default:
                retval=0;
                break;
        }
        return retval;
    }
    e5a4:	4770      	bx	lr
    e5a6:	bf00      	nop
    e5a8:	10001454 	.word	0x10001454
    e5ac:	1000144c 	.word	0x1000144c
    e5b0:	10001450 	.word	0x10001450
    e5b4:	10001004 	.word	0x10001004
    e5b8:	10001008 	.word	0x10001008

0000e5bc <crcu16>:
{
    ee_u8 i=0,x16=0,carry=0;

    for (i = 0; i < 8; i++)
    {
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e5bc:	ea81 0300 	eor.w	r3, r1, r0
        data >>= 1;

        if (x16 == 1)
    e5c0:	07db      	lsls	r3, r3, #31
        }
        else
            carry = 0;
        crc >>= 1;
        if (carry)
           crc |= 0x8000;
    e5c2:	bf46      	itte	mi
    e5c4:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e5c8:	ea83 0351 	eormi.w	r3, r3, r1, lsr #1
        crc >>= 1;
    e5cc:	084b      	lsrpl	r3, r1, #1
        data >>= 1;
    e5ce:	f3c0 0c46 	ubfx	ip, r0, #1, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e5d2:	ea83 0c0c 	eor.w	ip, r3, ip
        if (x16 == 1)
    e5d6:	f01c 0f01 	tst.w	ip, #1
           crc &= 0x7fff;
    }
    return crc;
}
ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {
    crc=crcu8( (ee_u8) (newval)             ,crc);
    e5da:	b2c2      	uxtb	r2, r0
           crc |= 0x8000;
    e5dc:	bf1a      	itte	ne
    e5de:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e5e2:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        crc >>= 1;
    e5e6:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e5e8:	0891      	lsrs	r1, r2, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e5ea:	4059      	eors	r1, r3
        if (x16 == 1)
    e5ec:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e5ee:	bf46      	itte	mi
    e5f0:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e5f4:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e5f8:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e5fa:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e5fe:	ea83 0c0c 	eor.w	ip, r3, ip
        if (x16 == 1)
    e602:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e606:	bf1a      	itte	ne
    e608:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e60c:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        crc >>= 1;
    e610:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e612:	0911      	lsrs	r1, r2, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e614:	4059      	eors	r1, r3
        if (x16 == 1)
    e616:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e618:	bf46      	itte	mi
    e61a:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e61e:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e622:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e624:	ea4f 1c52 	mov.w	ip, r2, lsr #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e628:	ea83 0c0c 	eor.w	ip, r3, ip
        if (x16 == 1)
    e62c:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e630:	bf1a      	itte	ne
    e632:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e636:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        crc >>= 1;
    e63a:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e63c:	0991      	lsrs	r1, r2, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e63e:	4059      	eors	r1, r3
        if (x16 == 1)
    e640:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e642:	bf46      	itte	mi
    e644:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e648:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e64c:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e64e:	09d2      	lsrs	r2, r2, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e650:	405a      	eors	r2, r3
        if (x16 == 1)
    e652:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e654:	bf46      	itte	mi
    e656:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    e65a:	ea82 0353 	eormi.w	r3, r2, r3, lsr #1
        crc >>= 1;
    e65e:	085b      	lsrpl	r3, r3, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e660:	ea83 2c10 	eor.w	ip, r3, r0, lsr #8
        if (x16 == 1)
    e664:	f01c 0f01 	tst.w	ip, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    e668:	ea4f 2210 	mov.w	r2, r0, lsr #8
        data >>= 1;
    e66c:	ea4f 2150 	mov.w	r1, r0, lsr #9
           crc |= 0x8000;
    e670:	bf16      	itet	ne
    e672:	f24a 0001 	movwne	r0, #40961	; 0xa001
        crc >>= 1;
    e676:	0858      	lsreq	r0, r3, #1
           crc |= 0x8000;
    e678:	ea80 0053 	eorne.w	r0, r0, r3, lsr #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e67c:	ea80 0301 	eor.w	r3, r0, r1
        if (x16 == 1)
    e680:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e682:	bf4a      	itet	mi
    e684:	f24a 0301 	movwmi	r3, #40961	; 0xa001
        crc >>= 1;
    e688:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    e68a:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        data >>= 1;
    e68e:	0891      	lsrs	r1, r2, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e690:	ea80 0301 	eor.w	r3, r0, r1
        if (x16 == 1)
    e694:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e696:	bf46      	itte	mi
    e698:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e69c:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e6a0:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e6a2:	08d1      	lsrs	r1, r2, #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e6a4:	4041      	eors	r1, r0
        if (x16 == 1)
    e6a6:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e6a8:	bf46      	itte	mi
    e6aa:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e6ae:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    e6b2:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e6b4:	0913      	lsrs	r3, r2, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e6b6:	4043      	eors	r3, r0
        if (x16 == 1)
    e6b8:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e6ba:	bf46      	itte	mi
    e6bc:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e6c0:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e6c4:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e6c6:	0951      	lsrs	r1, r2, #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e6c8:	4041      	eors	r1, r0
        if (x16 == 1)
    e6ca:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e6cc:	bf4a      	itet	mi
    e6ce:	f24a 0101 	movwmi	r1, #40961	; 0xa001
        crc >>= 1;
    e6d2:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    e6d4:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        data >>= 1;
    e6d8:	0993      	lsrs	r3, r2, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e6da:	4043      	eors	r3, r0
        if (x16 == 1)
    e6dc:	07d9      	lsls	r1, r3, #31
           crc |= 0x8000;
    e6de:	bf46      	itte	mi
    e6e0:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e6e4:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e6e8:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e6ea:	09d2      	lsrs	r2, r2, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e6ec:	4042      	eors	r2, r0
        if (x16 == 1)
    e6ee:	07d3      	lsls	r3, r2, #31
           crc |= 0x8000;
    e6f0:	bf46      	itte	mi
    e6f2:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e6f6:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e6fa:	0840      	lsrpl	r0, r0, #1
    return crc;
}
    e6fc:	4770      	bx	lr
    e6fe:	bf00      	nop

0000e700 <crcu32>:
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e700:	ea81 0300 	eor.w	r3, r1, r0
        if (x16 == 1)
    e704:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e706:	bf46      	itte	mi
    e708:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e70c:	ea83 0351 	eormi.w	r3, r3, r1, lsr #1
        crc >>= 1;
    e710:	084b      	lsrpl	r3, r1, #1
ee_u16 crcu32(ee_u32 newval, ee_u16 crc) {
    e712:	b500      	push	{lr}
        data >>= 1;
    e714:	f3c0 0e46 	ubfx	lr, r0, #1, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e718:	ea83 0e0e 	eor.w	lr, r3, lr
        if (x16 == 1)
    e71c:	f01e 0f01 	tst.w	lr, #1
    crc=crcu8( (ee_u8) (newval)             ,crc);
    e720:	b2c2      	uxtb	r2, r0
           crc |= 0x8000;
    e722:	bf1a      	itte	ne
    e724:	f24a 0e01 	movwne	lr, #40961	; 0xa001
    e728:	ea8e 0353 	eorne.w	r3, lr, r3, lsr #1
        crc >>= 1;
    e72c:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e72e:	0891      	lsrs	r1, r2, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e730:	4059      	eors	r1, r3
        if (x16 == 1)
    e732:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e734:	bf46      	itte	mi
    e736:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e73a:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e73e:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e740:	ea4f 0ed2 	mov.w	lr, r2, lsr #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e744:	ea83 0e0e 	eor.w	lr, r3, lr
        if (x16 == 1)
    e748:	f01e 0f01 	tst.w	lr, #1
           crc |= 0x8000;
    e74c:	bf1a      	itte	ne
    e74e:	f24a 0e01 	movwne	lr, #40961	; 0xa001
    e752:	ea8e 0353 	eorne.w	r3, lr, r3, lsr #1
        crc >>= 1;
    e756:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e758:	0911      	lsrs	r1, r2, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e75a:	4059      	eors	r1, r3
        if (x16 == 1)
    e75c:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e75e:	bf46      	itte	mi
    e760:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e764:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e768:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e76a:	ea4f 1e52 	mov.w	lr, r2, lsr #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e76e:	ea83 0e0e 	eor.w	lr, r3, lr
        if (x16 == 1)
    e772:	f01e 0f01 	tst.w	lr, #1
           crc |= 0x8000;
    e776:	bf1a      	itte	ne
    e778:	f24a 0e01 	movwne	lr, #40961	; 0xa001
    e77c:	ea8e 0353 	eorne.w	r3, lr, r3, lsr #1
        crc >>= 1;
    e780:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e782:	0991      	lsrs	r1, r2, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e784:	4059      	eors	r1, r3
        if (x16 == 1)
    e786:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e788:	bf46      	itte	mi
    e78a:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e78e:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e792:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e794:	09d2      	lsrs	r2, r2, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e796:	405a      	eors	r2, r3
        if (x16 == 1)
    e798:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e79a:	bf46      	itte	mi
    e79c:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    e7a0:	ea82 0353 	eormi.w	r3, r2, r3, lsr #1
        crc >>= 1;
    e7a4:	085b      	lsrpl	r3, r3, #1
    crc=crc16((ee_s16) newval       ,crc);
    crc=crc16((ee_s16) (newval>>16) ,crc);
    return crc;
}
ee_u16 crc16(ee_s16 newval, ee_u16 crc) {
    return crcu16((ee_u16)newval, crc);
    e7a6:	fa1f fc80 	uxth.w	ip, r0
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    e7aa:	ea4f 221c 	mov.w	r2, ip, lsr #8
        data >>= 1;
    e7ae:	ea4f 215c 	mov.w	r1, ip, lsr #9
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e7b2:	ea83 2c1c 	eor.w	ip, r3, ip, lsr #8
        if (x16 == 1)
    e7b6:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e7ba:	bf16      	itet	ne
    e7bc:	f24a 0c01 	movwne	ip, #40961	; 0xa001
        crc >>= 1;
    e7c0:	085b      	lsreq	r3, r3, #1
           crc |= 0x8000;
    e7c2:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e7c6:	ea83 0c01 	eor.w	ip, r3, r1
        if (x16 == 1)
    e7ca:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e7ce:	bf1a      	itte	ne
    e7d0:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e7d4:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        crc >>= 1;
    e7d8:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e7da:	0891      	lsrs	r1, r2, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e7dc:	4059      	eors	r1, r3
        if (x16 == 1)
    e7de:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e7e0:	bf46      	itte	mi
    e7e2:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e7e6:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e7ea:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e7ec:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e7f0:	ea83 0c0c 	eor.w	ip, r3, ip
        if (x16 == 1)
    e7f4:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e7f8:	bf1a      	itte	ne
    e7fa:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e7fe:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        crc >>= 1;
    e802:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e804:	0911      	lsrs	r1, r2, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e806:	4059      	eors	r1, r3
        if (x16 == 1)
    e808:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e80a:	bf46      	itte	mi
    e80c:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e810:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e814:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e816:	ea4f 1c52 	mov.w	ip, r2, lsr #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e81a:	ea83 0c0c 	eor.w	ip, r3, ip
        if (x16 == 1)
    e81e:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e822:	bf1a      	itte	ne
    e824:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e828:	ea8c 0353 	eorne.w	r3, ip, r3, lsr #1
        crc >>= 1;
    e82c:	085b      	lsreq	r3, r3, #1
        data >>= 1;
    e82e:	0991      	lsrs	r1, r2, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e830:	4059      	eors	r1, r3
        if (x16 == 1)
    e832:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e834:	bf46      	itte	mi
    e836:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e83a:	ea81 0353 	eormi.w	r3, r1, r3, lsr #1
        crc >>= 1;
    e83e:	085b      	lsrpl	r3, r3, #1
        data >>= 1;
    e840:	09d2      	lsrs	r2, r2, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e842:	405a      	eors	r2, r3
        if (x16 == 1)
    e844:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e846:	bf46      	itte	mi
    e848:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    e84c:	ea82 0353 	eormi.w	r3, r2, r3, lsr #1
        crc >>= 1;
    e850:	085b      	lsrpl	r3, r3, #1
    crc=crcu8( (ee_u8) (newval)             ,crc);
    e852:	f3c0 4207 	ubfx	r2, r0, #16, #8
    return crcu16((ee_u16)newval, crc);
    e856:	0c01      	lsrs	r1, r0, #16
        data >>= 1;
    e858:	f3c0 4c46 	ubfx	ip, r0, #17, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e85c:	ea83 4010 	eor.w	r0, r3, r0, lsr #16
        if (x16 == 1)
    e860:	07c0      	lsls	r0, r0, #31
           crc |= 0x8000;
    e862:	bf4a      	itet	mi
    e864:	f24a 0001 	movwmi	r0, #40961	; 0xa001
        crc >>= 1;
    e868:	0858      	lsrpl	r0, r3, #1
           crc |= 0x8000;
    e86a:	ea80 0053 	eormi.w	r0, r0, r3, lsr #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e86e:	ea80 0c0c 	eor.w	ip, r0, ip
        if (x16 == 1)
    e872:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e876:	bf1a      	itte	ne
    e878:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e87c:	ea8c 0050 	eorne.w	r0, ip, r0, lsr #1
        crc >>= 1;
    e880:	0840      	lsreq	r0, r0, #1
        data >>= 1;
    e882:	0893      	lsrs	r3, r2, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e884:	4043      	eors	r3, r0
        if (x16 == 1)
    e886:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e888:	bf46      	itte	mi
    e88a:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e88e:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e892:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e894:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e898:	ea80 0c0c 	eor.w	ip, r0, ip
        if (x16 == 1)
    e89c:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e8a0:	bf1a      	itte	ne
    e8a2:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e8a6:	ea8c 0050 	eorne.w	r0, ip, r0, lsr #1
        crc >>= 1;
    e8aa:	0840      	lsreq	r0, r0, #1
        data >>= 1;
    e8ac:	0913      	lsrs	r3, r2, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e8ae:	4043      	eors	r3, r0
        if (x16 == 1)
    e8b0:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e8b2:	bf46      	itte	mi
    e8b4:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e8b8:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e8bc:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e8be:	ea4f 1c52 	mov.w	ip, r2, lsr #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e8c2:	ea80 0c0c 	eor.w	ip, r0, ip
        if (x16 == 1)
    e8c6:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e8ca:	bf16      	itet	ne
    e8cc:	f24a 0c01 	movwne	ip, #40961	; 0xa001
        crc >>= 1;
    e8d0:	0840      	lsreq	r0, r0, #1
           crc |= 0x8000;
    e8d2:	ea8c 0050 	eorne.w	r0, ip, r0, lsr #1
        data >>= 1;
    e8d6:	0993      	lsrs	r3, r2, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e8d8:	4043      	eors	r3, r0
        if (x16 == 1)
    e8da:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e8dc:	bf46      	itte	mi
    e8de:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e8e2:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e8e6:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e8e8:	09d2      	lsrs	r2, r2, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e8ea:	4042      	eors	r2, r0
        if (x16 == 1)
    e8ec:	07d3      	lsls	r3, r2, #31
           crc |= 0x8000;
    e8ee:	bf46      	itte	mi
    e8f0:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e8f4:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e8f8:	0840      	lsrpl	r0, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e8fa:	ea80 2211 	eor.w	r2, r0, r1, lsr #8
        if (x16 == 1)
    e8fe:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e900:	bf46      	itte	mi
    e902:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    e906:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        crc >>= 1;
    e90a:	0840      	lsrpl	r0, r0, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    e90c:	0a0b      	lsrs	r3, r1, #8
        data >>= 1;
    e90e:	0a49      	lsrs	r1, r1, #9
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e910:	4041      	eors	r1, r0
        if (x16 == 1)
    e912:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e914:	bf46      	itte	mi
    e916:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e91a:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    e91e:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e920:	089a      	lsrs	r2, r3, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e922:	4042      	eors	r2, r0
        if (x16 == 1)
    e924:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e926:	bf46      	itte	mi
    e928:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    e92c:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        crc >>= 1;
    e930:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e932:	08d9      	lsrs	r1, r3, #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e934:	4041      	eors	r1, r0
        if (x16 == 1)
    e936:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e938:	bf46      	itte	mi
    e93a:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e93e:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    e942:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e944:	091a      	lsrs	r2, r3, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e946:	4042      	eors	r2, r0
        if (x16 == 1)
    e948:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e94a:	bf46      	itte	mi
    e94c:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    e950:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        crc >>= 1;
    e954:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e956:	0959      	lsrs	r1, r3, #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e958:	4041      	eors	r1, r0
        if (x16 == 1)
    e95a:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e95c:	bf4a      	itet	mi
    e95e:	f24a 0101 	movwmi	r1, #40961	; 0xa001
        crc >>= 1;
    e962:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    e964:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        data >>= 1;
    e968:	099a      	lsrs	r2, r3, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e96a:	4042      	eors	r2, r0
        if (x16 == 1)
    e96c:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    e96e:	bf4a      	itet	mi
    e970:	f24a 0201 	movwmi	r2, #40961	; 0xa001
        crc >>= 1;
    e974:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    e976:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        data >>= 1;
    e97a:	09db      	lsrs	r3, r3, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e97c:	4043      	eors	r3, r0
        if (x16 == 1)
    e97e:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    e980:	bf46      	itte	mi
    e982:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    e986:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    e98a:	0840      	lsrpl	r0, r0, #1
}
    e98c:	f85d fb04 	ldr.w	pc, [sp], #4

0000e990 <crc16>:
    crc=crcu8( (ee_u8) (newval)             ,crc);
    e990:	b2c3      	uxtb	r3, r0
    return crcu16((ee_u16)newval, crc);
    e992:	b282      	uxth	r2, r0
        data >>= 1;
    e994:	f3c0 0c46 	ubfx	ip, r0, #1, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e998:	4048      	eors	r0, r1
        if (x16 == 1)
    e99a:	07c0      	lsls	r0, r0, #31
           crc |= 0x8000;
    e99c:	bf46      	itte	mi
    e99e:	f24a 0001 	movwmi	r0, #40961	; 0xa001
    e9a2:	ea80 0051 	eormi.w	r0, r0, r1, lsr #1
        crc >>= 1;
    e9a6:	0848      	lsrpl	r0, r1, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e9a8:	ea80 0c0c 	eor.w	ip, r0, ip
        if (x16 == 1)
    e9ac:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e9b0:	bf1a      	itte	ne
    e9b2:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e9b6:	ea8c 0050 	eorne.w	r0, ip, r0, lsr #1
        crc >>= 1;
    e9ba:	0840      	lsreq	r0, r0, #1
        data >>= 1;
    e9bc:	0899      	lsrs	r1, r3, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e9be:	4041      	eors	r1, r0
        if (x16 == 1)
    e9c0:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e9c2:	bf46      	itte	mi
    e9c4:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e9c8:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    e9cc:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e9ce:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e9d2:	ea80 0c0c 	eor.w	ip, r0, ip
        if (x16 == 1)
    e9d6:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    e9da:	bf1a      	itte	ne
    e9dc:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    e9e0:	ea8c 0050 	eorne.w	r0, ip, r0, lsr #1
        crc >>= 1;
    e9e4:	0840      	lsreq	r0, r0, #1
        data >>= 1;
    e9e6:	0919      	lsrs	r1, r3, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e9e8:	4041      	eors	r1, r0
        if (x16 == 1)
    e9ea:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    e9ec:	bf46      	itte	mi
    e9ee:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    e9f2:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    e9f6:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    e9f8:	ea4f 1c53 	mov.w	ip, r3, lsr #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    e9fc:	ea80 0c0c 	eor.w	ip, r0, ip
        if (x16 == 1)
    ea00:	f01c 0f01 	tst.w	ip, #1
           crc |= 0x8000;
    ea04:	bf1a      	itte	ne
    ea06:	f24a 0c01 	movwne	ip, #40961	; 0xa001
    ea0a:	ea8c 0050 	eorne.w	r0, ip, r0, lsr #1
        crc >>= 1;
    ea0e:	0840      	lsreq	r0, r0, #1
        data >>= 1;
    ea10:	0999      	lsrs	r1, r3, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea12:	4041      	eors	r1, r0
        if (x16 == 1)
    ea14:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    ea16:	bf46      	itte	mi
    ea18:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    ea1c:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    ea20:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    ea22:	09db      	lsrs	r3, r3, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea24:	4043      	eors	r3, r0
        if (x16 == 1)
    ea26:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    ea28:	bf46      	itte	mi
    ea2a:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    ea2e:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    ea32:	0840      	lsrpl	r0, r0, #1
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea34:	ea80 2112 	eor.w	r1, r0, r2, lsr #8
        if (x16 == 1)
    ea38:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    ea3a:	bf46      	itte	mi
    ea3c:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    ea40:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    ea44:	0840      	lsrpl	r0, r0, #1
    crc=crcu8( (ee_u8) ((newval)>>8)    ,crc);
    ea46:	0a13      	lsrs	r3, r2, #8
        data >>= 1;
    ea48:	0a52      	lsrs	r2, r2, #9
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea4a:	4042      	eors	r2, r0
        if (x16 == 1)
    ea4c:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    ea4e:	bf4a      	itet	mi
    ea50:	f24a 0201 	movwmi	r2, #40961	; 0xa001
        crc >>= 1;
    ea54:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    ea56:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        data >>= 1;
    ea5a:	0899      	lsrs	r1, r3, #2
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea5c:	ea81 0200 	eor.w	r2, r1, r0
        if (x16 == 1)
    ea60:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    ea62:	bf46      	itte	mi
    ea64:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    ea68:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        crc >>= 1;
    ea6c:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    ea6e:	08d9      	lsrs	r1, r3, #3
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea70:	4041      	eors	r1, r0
        if (x16 == 1)
    ea72:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    ea74:	bf46      	itte	mi
    ea76:	f24a 0101 	movwmi	r1, #40961	; 0xa001
    ea7a:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        crc >>= 1;
    ea7e:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    ea80:	091a      	lsrs	r2, r3, #4
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea82:	4042      	eors	r2, r0
        if (x16 == 1)
    ea84:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    ea86:	bf46      	itte	mi
    ea88:	f24a 0201 	movwmi	r2, #40961	; 0xa001
    ea8c:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        crc >>= 1;
    ea90:	0840      	lsrpl	r0, r0, #1
        data >>= 1;
    ea92:	0959      	lsrs	r1, r3, #5
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    ea94:	4041      	eors	r1, r0
        if (x16 == 1)
    ea96:	07c9      	lsls	r1, r1, #31
           crc |= 0x8000;
    ea98:	bf4a      	itet	mi
    ea9a:	f24a 0101 	movwmi	r1, #40961	; 0xa001
        crc >>= 1;
    ea9e:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    eaa0:	ea81 0050 	eormi.w	r0, r1, r0, lsr #1
        data >>= 1;
    eaa4:	099a      	lsrs	r2, r3, #6
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    eaa6:	4042      	eors	r2, r0
        if (x16 == 1)
    eaa8:	07d2      	lsls	r2, r2, #31
           crc |= 0x8000;
    eaaa:	bf4a      	itet	mi
    eaac:	f24a 0201 	movwmi	r2, #40961	; 0xa001
        crc >>= 1;
    eab0:	0840      	lsrpl	r0, r0, #1
           crc |= 0x8000;
    eab2:	ea82 0050 	eormi.w	r0, r2, r0, lsr #1
        data >>= 1;
    eab6:	09db      	lsrs	r3, r3, #7
        x16 = (ee_u8)((data & 1) ^ ((ee_u8)crc & 1));
    eab8:	4043      	eors	r3, r0
        if (x16 == 1)
    eaba:	07db      	lsls	r3, r3, #31
           crc |= 0x8000;
    eabc:	bf46      	itte	mi
    eabe:	f24a 0301 	movwmi	r3, #40961	; 0xa001
    eac2:	ea83 0050 	eormi.w	r0, r3, r0, lsr #1
        crc >>= 1;
    eac6:	0840      	lsrpl	r0, r0, #1
}
    eac8:	4770      	bx	lr
    eaca:	bf00      	nop

0000eacc <check_data_types>:
    }
    if (retval>0) {
        ee_printf("ERROR: Please modify the datatypes in core_portme.h!\n");
    }
    return retval;
}
    eacc:	2000      	movs	r0, #0
    eace:	4770      	bx	lr

0000ead0 <am_devices_led_array_init>:
void
am_devices_led_array_init(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs)
{
    uint32_t i;

    if ( (psLEDs == NULL)                       ||
    ead0:	b358      	cbz	r0, eb2a <am_devices_led_array_init+0x5a>
    }

    //
    // Loop through the list of LEDs, configuring each one individually.
    //
    for ( i = 0; i < ui32NumLEDs; i++ )
    ead2:	1e4b      	subs	r3, r1, #1
    ead4:	2b1e      	cmp	r3, #30
    ead6:	d828      	bhi.n	eb2a <am_devices_led_array_init+0x5a>
{
    ead8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eadc:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    eae0:	f8df 804c 	ldr.w	r8, [pc, #76]	; eb30 <am_devices_led_array_init+0x60>
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    eae4:	4f11      	ldr	r7, [pc, #68]	; (eb2c <am_devices_led_array_init+0x5c>)
    eae6:	4605      	mov	r5, r0
    eae8:	1d04      	adds	r4, r0, #4
    eaea:	1d0e      	adds	r6, r1, #4
         (psLED->ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    eaec:	f854 0c04 	ldr.w	r0, [r4, #-4]
    if ( (psLED == NULL)    ||
    eaf0:	2831      	cmp	r0, #49	; 0x31
    eaf2:	d813      	bhi.n	eb1c <am_devices_led_array_init+0x4c>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLED->ui32Polarity )
    eaf4:	686b      	ldr	r3, [r5, #4]
    eaf6:	079b      	lsls	r3, r3, #30
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_OUTPUT);
    eaf8:	bf4c      	ite	mi
    eafa:	6839      	ldrmi	r1, [r7, #0]
        am_hal_gpio_pinconfig(psLED->ui32GPIONumber, g_AM_HAL_GPIO_TRISTATE);
    eafc:	f8d8 1000 	ldrpl.w	r1, [r8]
    eb00:	f001 fa60 	bl	ffc4 <am_hal_gpio_pinconfig>
        am_hal_gpio_state_write(psLED->ui32GPIONumber, AM_HAL_GPIO_OUTPUT_TRISTATE_DISABLE);
    eb04:	2103      	movs	r1, #3
    eb06:	f854 0c04 	ldr.w	r0, [r4, #-4]
    eb0a:	f001 fb91 	bl	10230 <am_hal_gpio_state_write>
                                AM_HAL_GPIO_OUTPUT_SET : AM_HAL_GPIO_OUTPUT_CLEAR);
    eb0e:	6869      	ldr	r1, [r5, #4]
        am_hal_gpio_state_write(psLED->ui32GPIONumber,
    eb10:	f854 0c04 	ldr.w	r0, [r4, #-4]
    eb14:	f001 0101 	and.w	r1, r1, #1
    eb18:	f001 fb8a 	bl	10230 <am_hal_gpio_state_write>
    for ( i = 0; i < ui32NumLEDs; i++ )
    eb1c:	3408      	adds	r4, #8
    eb1e:	42b4      	cmp	r4, r6
    eb20:	f105 0508 	add.w	r5, r5, #8
    eb24:	d1e2      	bne.n	eaec <am_devices_led_array_init+0x1c>
    {
        am_devices_led_init(psLEDs + i);
    }
}
    eb26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    eb2a:	4770      	bx	lr
    eb2c:	000116d0 	.word	0x000116d0
    eb30:	000116d4 	.word	0x000116d4

0000eb34 <am_devices_led_array_out>:
am_devices_led_array_out(am_devices_led_t *psLEDs, uint32_t ui32NumLEDs,
                         uint32_t ui32Value)
{
    uint32_t i;

    for ( i = 0; i < ui32NumLEDs; i++ )
    eb34:	2900      	cmp	r1, #0
    eb36:	d059      	beq.n	ebec <am_devices_led_array_out+0xb8>
{
    eb38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    eb3c:	4606      	mov	r6, r0
    eb3e:	2800      	cmp	r0, #0
    eb40:	d052      	beq.n	ebe8 <am_devices_led_array_out+0xb4>
    eb42:	f101 39ff 	add.w	r9, r1, #4294967295
    eb46:	f1b9 0f1e 	cmp.w	r9, #30
    eb4a:	4617      	mov	r7, r2
    eb4c:	4688      	mov	r8, r1
    eb4e:	bf28      	it	cs
    eb50:	f04f 091e 	movcs.w	r9, #30
    eb54:	1d05      	adds	r5, r0, #4
    for ( i = 0; i < ui32NumLEDs; i++ )
    eb56:	2400      	movs	r4, #0
    {
        if ( ui32Value & (1 << i) )
    eb58:	f04f 0a01 	mov.w	sl, #1
    eb5c:	e010      	b.n	eb80 <am_devices_led_array_out+0x4c>
         (ui32LEDNum >= MAX_LEDS)               ||
    eb5e:	2831      	cmp	r0, #49	; 0x31
    eb60:	d809      	bhi.n	eb76 <am_devices_led_array_out+0x42>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    eb62:	682b      	ldr	r3, [r5, #0]
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    eb64:	43da      	mvns	r2, r3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    eb66:	079b      	lsls	r3, r3, #30
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    eb68:	f04f 0103 	mov.w	r1, #3
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    eb6c:	d517      	bpl.n	eb9e <am_devices_led_array_out+0x6a>
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    eb6e:	f002 0101 	and.w	r1, r2, #1
    eb72:	f001 fb5d 	bl	10230 <am_hal_gpio_state_write>
    for ( i = 0; i < ui32NumLEDs; i++ )
    eb76:	3401      	adds	r4, #1
    eb78:	454c      	cmp	r4, r9
    eb7a:	f105 0508 	add.w	r5, r5, #8
    eb7e:	d815      	bhi.n	ebac <am_devices_led_array_out+0x78>
        if ( ui32Value & (1 << i) )
    eb80:	fa0a f304 	lsl.w	r3, sl, r4
    eb84:	423b      	tst	r3, r7
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    eb86:	f855 0c04 	ldr.w	r0, [r5, #-4]
        if ( ui32Value & (1 << i) )
    eb8a:	d0e8      	beq.n	eb5e <am_devices_led_array_out+0x2a>
         (ui32LEDNum >= MAX_LEDS)               ||
    eb8c:	2831      	cmp	r0, #49	; 0x31
    eb8e:	d8f2      	bhi.n	eb76 <am_devices_led_array_out+0x42>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    eb90:	682b      	ldr	r3, [r5, #0]
    eb92:	079a      	lsls	r2, r3, #30
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    eb94:	f04f 0104 	mov.w	r1, #4
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    eb98:	bf48      	it	mi
    eb9a:	f003 0101 	andmi.w	r1, r3, #1
    for ( i = 0; i < ui32NumLEDs; i++ )
    eb9e:	3401      	adds	r4, #1
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    eba0:	f001 fb46 	bl	10230 <am_hal_gpio_state_write>
    for ( i = 0; i < ui32NumLEDs; i++ )
    eba4:	454c      	cmp	r4, r9
    eba6:	f105 0508 	add.w	r5, r5, #8
    ebaa:	d9e9      	bls.n	eb80 <am_devices_led_array_out+0x4c>
    ebac:	45a0      	cmp	r8, r4
    ebae:	d91b      	bls.n	ebe8 <am_devices_led_array_out+0xb4>
    ebb0:	eb06 05c4 	add.w	r5, r6, r4, lsl #3
    ebb4:	3504      	adds	r5, #4
        if ( ui32Value & (1 << i) )
    ebb6:	2601      	movs	r6, #1
    ebb8:	fa06 f304 	lsl.w	r3, r6, r4
    ebbc:	423b      	tst	r3, r7
    ebbe:	d00e      	beq.n	ebde <am_devices_led_array_out+0xaa>
    if ( (psLEDs == NULL)                       ||
    ebc0:	2c1e      	cmp	r4, #30
    ebc2:	d80c      	bhi.n	ebde <am_devices_led_array_out+0xaa>
         (psLEDs[ui32LEDNum].ui32GPIONumber >= AM_HAL_GPIO_MAX_PADS) )
    ebc4:	f855 0c04 	ldr.w	r0, [r5, #-4]
         (ui32LEDNum >= MAX_LEDS)               ||
    ebc8:	2831      	cmp	r0, #49	; 0x31
    ebca:	d808      	bhi.n	ebde <am_devices_led_array_out+0xaa>
    if ( AM_DEVICES_LED_POL_DIRECT_DRIVE_M & psLEDs[ui32LEDNum].ui32Polarity )
    ebcc:	682b      	ldr	r3, [r5, #0]
    ebce:	079a      	lsls	r2, r3, #30
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    ebd0:	f04f 0104 	mov.w	r1, #4
        am_hal_gpio_state_write(psLEDs[ui32LEDNum].ui32GPIONumber,
    ebd4:	bf48      	it	mi
    ebd6:	f003 0101 	andmi.w	r1, r3, #1
    ebda:	f001 fb29 	bl	10230 <am_hal_gpio_state_write>
    for ( i = 0; i < ui32NumLEDs; i++ )
    ebde:	3401      	adds	r4, #1
    ebe0:	45a0      	cmp	r8, r4
    ebe2:	f105 0508 	add.w	r5, r5, #8
    ebe6:	d1e7      	bne.n	ebb8 <am_devices_led_array_out+0x84>
        else
        {
            am_devices_led_off(psLEDs, i);
        }
    }
}
    ebe8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ebec:	4770      	bx	lr
    ebee:	bf00      	nop

0000ebf0 <am_util_delay_ms>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
    ebf0:	b510      	push	{r4, lr}
    ebf2:	b084      	sub	sp, #16
    ebf4:	4604      	mov	r4, r0
    am_hal_delay_us( ui32MilliSeconds * 1000);
#else // AM_PART_APOLLO4
    uint32_t ui32Loops, ui32HFRC;
#if AM_APOLLO3_CLKGEN
    am_hal_clkgen_status_t sClkgenStatus;
    am_hal_clkgen_status_get(&sClkgenStatus);
    ebf6:	a801      	add	r0, sp, #4
    ebf8:	f001 f976 	bl	fee8 <am_hal_clkgen_status_get>
    ui32HFRC = sClkgenStatus.ui32SysclkFreq;
#else // AM_APOLLO3_CLKGEN
    ui32HFRC = am_hal_clkgen_sysclk_get();
#endif // AM_APOLLO3_CLKGEN
    ui32Loops = ui32MilliSeconds * (ui32HFRC / 3000);
    ebfc:	9b01      	ldr	r3, [sp, #4]
    ebfe:	4805      	ldr	r0, [pc, #20]	; (ec14 <am_util_delay_ms+0x24>)
    ec00:	fba0 2303 	umull	r2, r3, r0, r3
    ec04:	099b      	lsrs	r3, r3, #6

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
    ec06:	fb04 f003 	mul.w	r0, r4, r3
    ec0a:	f001 f98b 	bl	ff24 <am_hal_flash_delay>
#endif // AM_PART_APOLLO4
}
    ec0e:	b004      	add	sp, #16
    ec10:	bd10      	pop	{r4, pc}
    ec12:	bf00      	nop
    ec14:	057619f1 	.word	0x057619f1

0000ec18 <HardFault_Handler>:
HardFault_Handler(void)
#else // AM_CMSIS_REGS
am_fault_isr(void)
#endif // AM_CMSIS_REGS
{
    __asm("    push    {r0,lr}");       // Always pushes to MSP stack
    ec18:	b501      	push	{r0, lr}
    __asm("    tst     lr, #4");        // Check if we should use MSP or PSP
    ec1a:	f01e 0f04 	tst.w	lr, #4
    __asm("    itet    eq");            // Instrs executed when: eq,ne,eq
    ec1e:	bf0a      	itet	eq
    __asm("    mrseq   r0, msp");       //    bit2=0 indicating MSP stack
    ec20:	f3ef 8008 	mrseq	r0, MSP
    __asm("    mrsne   r0, psp");       // e: bit2=1 indicating PSP stack
    ec24:	f3ef 8009 	mrsne	r0, PSP
    __asm("    addseq  r0, r0, #8");    // t: bit2=0, adjust for pushes to MSP stack
    ec28:	f110 0008 	addseq.w	r0, r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
    ec2c:	f000 f806 	bl	ec3c <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");       // Restore from MSP stack
    ec30:	bd01      	pop	{r0, pc}
    ec32:	bf00      	nop

0000ec34 <getStackedReg>:
}

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
    ec34:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
    ec36:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
    ec38:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
    ec3a:	4770      	bx	lr

0000ec3c <am_util_faultisr_collect_data>:
// HardFault_Handler() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
    ec3c:	b510      	push	{r4, lr}
    volatile am_fault_t sFaultData;
#if (defined(AM_PART_APOLLO4) || defined(AM_PART_APOLLO4B))
    am_hal_fault_status_t  sHalFaultData = {0};
#else
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    ec3e:	2300      	movs	r3, #0
{
    ec40:	b092      	sub	sp, #72	; 0x48
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
    ec42:	e9cd 3300 	strd	r3, r3, [sp]
    ec46:	e9cd 3302 	strd	r3, r3, [sp, #8]
    ec4a:	e9cd 3304 	strd	r3, r3, [sp, #16]
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    ec4e:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
    ec52:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
    ec54:	f8d2 3d28 	ldr.w	r3, [r2, #3368]	; 0xd28
    ec58:	9310      	str	r3, [sp, #64]	; 0x40
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
    ec5a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ec5c:	b2db      	uxtb	r3, r3
    ec5e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
    ec62:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ec64:	f3c3 2307 	ubfx	r3, r3, #8, #8
    ec68:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
    ec6c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ec6e:	0c1b      	lsrs	r3, r3, #16
    ec70:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
    ec74:	f8d2 3d38 	ldr.w	r3, [r2, #3384]	; 0xd38
    ec78:	930f      	str	r3, [sp, #60]	; 0x3c

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ec7a:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    ec7e:	079b      	lsls	r3, r3, #30
{
    ec80:	4604      	mov	r4, r0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ec82:	d437      	bmi.n	ecf4 <am_util_faultisr_collect_data+0xb8>
    ec84:	f04f 33ff 	mov.w	r3, #4294967295

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ec88:	4621      	mov	r1, r4
    ec8a:	2000      	movs	r0, #0
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ec8c:	930e      	str	r3, [sp, #56]	; 0x38
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ec8e:	f7ff ffd1 	bl	ec34 <getStackedReg>
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    ec92:	4621      	mov	r1, r4
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ec94:	4603      	mov	r3, r0
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    ec96:	2001      	movs	r0, #1
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
    ec98:	9306      	str	r3, [sp, #24]
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    ec9a:	f7ff ffcb 	bl	ec34 <getStackedReg>
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    ec9e:	4621      	mov	r1, r4
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    eca0:	4603      	mov	r3, r0
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    eca2:	2002      	movs	r0, #2
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
    eca4:	9307      	str	r3, [sp, #28]
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    eca6:	f7ff ffc5 	bl	ec34 <getStackedReg>
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ecaa:	4621      	mov	r1, r4
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    ecac:	4603      	mov	r3, r0
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ecae:	2003      	movs	r0, #3
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
    ecb0:	9308      	str	r3, [sp, #32]
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ecb2:	f7ff ffbf 	bl	ec34 <getStackedReg>
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ecb6:	4621      	mov	r1, r4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ecb8:	4603      	mov	r3, r0
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ecba:	2004      	movs	r0, #4
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
    ecbc:	9309      	str	r3, [sp, #36]	; 0x24
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ecbe:	f7ff ffb9 	bl	ec34 <getStackedReg>
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ecc2:	4621      	mov	r1, r4
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ecc4:	4603      	mov	r3, r0
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ecc6:	2005      	movs	r0, #5
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
    ecc8:	930a      	str	r3, [sp, #40]	; 0x28
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ecca:	f7ff ffb3 	bl	ec34 <getStackedReg>
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ecce:	4621      	mov	r1, r4
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ecd0:	4603      	mov	r3, r0
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ecd2:	2006      	movs	r0, #6
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
    ecd4:	930b      	str	r3, [sp, #44]	; 0x2c
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ecd6:	f7ff ffad 	bl	ec34 <getStackedReg>
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ecda:	4621      	mov	r1, r4
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ecdc:	4603      	mov	r3, r0
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ecde:	2007      	movs	r0, #7
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
    ece0:	930c      	str	r3, [sp, #48]	; 0x30
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ece2:	f7ff ffa7 	bl	ec34 <getStackedReg>
    //
#if (defined(AM_PART_APOLLO4) || defined(AM_PART_APOLLO4B))
    am_hal_fault_status_get(&sHalFaultData);
#else
#if AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ece6:	4669      	mov	r1, sp
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ece8:	4603      	mov	r3, r0
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ecea:	2002      	movs	r0, #2
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
    ecec:	930d      	str	r3, [sp, #52]	; 0x34
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
    ecee:	f001 faeb 	bl	102c8 <am_hal_mcuctrl_info_get>
    //
    // Spin in an infinite loop.
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
    ecf2:	e7fe      	b.n	ecf2 <am_util_faultisr_collect_data+0xb6>
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
    ecf4:	4601      	mov	r1, r0
    ecf6:	2006      	movs	r0, #6
    ecf8:	f7ff ff9c 	bl	ec34 <getStackedReg>
    ecfc:	4603      	mov	r3, r0
    ecfe:	e7c3      	b.n	ec88 <am_util_faultisr_collect_data+0x4c>

0000ed00 <divu64_10>:
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
    ed00:	2900      	cmp	r1, #0
    ed02:	d047      	beq.n	ed94 <divu64_10+0x94>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ed04:	0843      	lsrs	r3, r0, #1
    ed06:	0882      	lsrs	r2, r0, #2
    ed08:	ea42 7281 	orr.w	r2, r2, r1, lsl #30
    ed0c:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
    ed10:	189b      	adds	r3, r3, r2
    ed12:	ea4f 0291 	mov.w	r2, r1, lsr #2
    ed16:	eb42 0251 	adc.w	r2, r2, r1, lsr #1
        q64 += (q64 >> 4);
    ed1a:	ea4f 1c13 	mov.w	ip, r3, lsr #4
    ed1e:	ea4c 7c02 	orr.w	ip, ip, r2, lsl #28
    ed22:	eb13 030c 	adds.w	r3, r3, ip
    ed26:	eb42 1212 	adc.w	r2, r2, r2, lsr #4
        q64 += (q64 >> 8);
    ed2a:	ea4f 2c13 	mov.w	ip, r3, lsr #8
    ed2e:	ea4c 6c02 	orr.w	ip, ip, r2, lsl #24
    ed32:	eb13 030c 	adds.w	r3, r3, ip
    ed36:	eb42 2212 	adc.w	r2, r2, r2, lsr #8
        q64 += (q64 >> 16);
    ed3a:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    ed3e:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
    ed42:	eb13 030c 	adds.w	r3, r3, ip
    ed46:	eb42 4212 	adc.w	r2, r2, r2, lsr #16
        q64 += (q64 >> 32);
    ed4a:	189b      	adds	r3, r3, r2
    ed4c:	f142 0200 	adc.w	r2, r2, #0
        q64 >>= 3;
    ed50:	08db      	lsrs	r3, r3, #3
    ed52:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
    ed56:	08d2      	lsrs	r2, r2, #3
        r64 = ui64Val - q64*10;
        return q64 + ((r64 + 6) >> 4);
    ed58:	3006      	adds	r0, #6
{
    ed5a:	b500      	push	{lr}
        r64 = ui64Val - q64*10;
    ed5c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    ed60:	ea4f 0e82 	mov.w	lr, r2, lsl #2
        return q64 + ((r64 + 6) >> 4);
    ed64:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    ed68:	ea4e 7e93 	orr.w	lr, lr, r3, lsr #30
    ed6c:	eb1c 0c03 	adds.w	ip, ip, r3
    ed70:	eb42 0e0e 	adc.w	lr, r2, lr
    ed74:	eb1c 0c0c 	adds.w	ip, ip, ip
    ed78:	eb4e 0e0e 	adc.w	lr, lr, lr
        return q64 + ((r64 + 6) >> 4);
    ed7c:	ebb0 000c 	subs.w	r0, r0, ip
    ed80:	eb61 010e 	sbc.w	r1, r1, lr
    ed84:	0900      	lsrs	r0, r0, #4
    ed86:	ea40 7001 	orr.w	r0, r0, r1, lsl #28
    ed8a:	18c0      	adds	r0, r0, r3
    ed8c:	eb42 1111 	adc.w	r1, r2, r1, lsr #4
        q32 += (q32 >> 16);
        q32 >>= 3;
        r32 = ui32Val - q32*10;
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    }
}
    ed90:	f85d fb04 	ldr.w	pc, [sp], #4
        q32 = (ui32Val>>1) + (ui32Val>>2);
    ed94:	0883      	lsrs	r3, r0, #2
    ed96:	eb03 0350 	add.w	r3, r3, r0, lsr #1
        q32 += (q32 >> 4);
    ed9a:	eb03 1313 	add.w	r3, r3, r3, lsr #4
        q32 += (q32 >> 8);
    ed9e:	eb03 2313 	add.w	r3, r3, r3, lsr #8
        q32 += (q32 >> 16);
    eda2:	eb03 4313 	add.w	r3, r3, r3, lsr #16
        q32 >>= 3;
    eda6:	08db      	lsrs	r3, r3, #3
        r32 = ui32Val - q32*10;
    eda8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    edac:	3006      	adds	r0, #6
    edae:	eba0 0042 	sub.w	r0, r0, r2, lsl #1
    edb2:	eb03 1010 	add.w	r0, r3, r0, lsr #4
}
    edb6:	4770      	bx	lr

0000edb8 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
    edb8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    edbc:	b089      	sub	sp, #36	; 0x24
    edbe:	ad01      	add	r5, sp, #4
        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);

        tbuf[ix++] = uMod + '0';
    edc0:	46ae      	mov	lr, r5
    edc2:	2401      	movs	r4, #1
    edc4:	e042      	b.n	ee4c <uint64_to_str+0x94>
        q64 = (ui64Val>>1) + (ui64Val>>2);
    edc6:	19db      	adds	r3, r3, r7
    edc8:	eb46 0651 	adc.w	r6, r6, r1, lsr #1
        q64 += (q64 >> 4);
    edcc:	091f      	lsrs	r7, r3, #4
    edce:	ea47 7706 	orr.w	r7, r7, r6, lsl #28
    edd2:	19db      	adds	r3, r3, r7
    edd4:	eb46 1616 	adc.w	r6, r6, r6, lsr #4
        q64 += (q64 >> 8);
    edd8:	0a1f      	lsrs	r7, r3, #8
    edda:	ea47 6706 	orr.w	r7, r7, r6, lsl #24
    edde:	19db      	adds	r3, r3, r7
    ede0:	eb46 2616 	adc.w	r6, r6, r6, lsr #8
        q64 += (q64 >> 16);
    ede4:	0c1f      	lsrs	r7, r3, #16
    ede6:	ea47 4706 	orr.w	r7, r7, r6, lsl #16
    edea:	19db      	adds	r3, r3, r7
    edec:	eb46 4616 	adc.w	r6, r6, r6, lsr #16
        q64 += (q64 >> 32);
    edf0:	199b      	adds	r3, r3, r6
    edf2:	f146 0600 	adc.w	r6, r6, #0
        q64 >>= 3;
    edf6:	08db      	lsrs	r3, r3, #3
    edf8:	ea43 7346 	orr.w	r3, r3, r6, lsl #29
    edfc:	08f6      	lsrs	r6, r6, #3
        return q64 + ((r64 + 6) >> 4);
    edfe:	1d87      	adds	r7, r0, #6
        r64 = ui64Val - q64*10;
    ee00:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    ee04:	ea4f 0886 	mov.w	r8, r6, lsl #2
        return q64 + ((r64 + 6) >> 4);
    ee08:	f141 0100 	adc.w	r1, r1, #0
        r64 = ui64Val - q64*10;
    ee0c:	ea48 7893 	orr.w	r8, r8, r3, lsr #30
    ee10:	eb1c 0c03 	adds.w	ip, ip, r3
    ee14:	eb46 0808 	adc.w	r8, r6, r8
    ee18:	eb1c 0c0c 	adds.w	ip, ip, ip
    ee1c:	eb48 0808 	adc.w	r8, r8, r8
        return q64 + ((r64 + 6) >> 4);
    ee20:	ebb7 070c 	subs.w	r7, r7, ip
    ee24:	eb61 0108 	sbc.w	r1, r1, r8
    ee28:	093f      	lsrs	r7, r7, #4
    ee2a:	ea47 7701 	orr.w	r7, r7, r1, lsl #28
    ee2e:	18fb      	adds	r3, r7, r3
        uMod = ui64Val - (u64Tmp * 10);
    ee30:	eb03 0783 	add.w	r7, r3, r3, lsl #2
    ee34:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
        tbuf[ix++] = uMod + '0';
    ee38:	f100 0030 	add.w	r0, r0, #48	; 0x30
    ee3c:	f88e 0000 	strb.w	r0, [lr]
    ee40:	eb46 1111 	adc.w	r1, r6, r1, lsr #4
    ee44:	4618      	mov	r0, r3
    ee46:	3401      	adds	r4, #1
    ee48:	f10e 0e01 	add.w	lr, lr, #1
        q32 = (ui32Val>>1) + (ui32Val>>2);
    ee4c:	ea4f 0c90 	mov.w	ip, r0, lsr #2
    ee50:	eb0c 0c50 	add.w	ip, ip, r0, lsr #1
        q32 += (q32 >> 4);
    ee54:	eb0c 1c1c 	add.w	ip, ip, ip, lsr #4
        q32 += (q32 >> 8);
    ee58:	eb0c 2c1c 	add.w	ip, ip, ip, lsr #8
        q32 += (q32 >> 16);
    ee5c:	eb0c 4c1c 	add.w	ip, ip, ip, lsr #16
        q32 >>= 3;
    ee60:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
        r32 = ui32Val - q32*10;
    ee64:	eb0c 098c 	add.w	r9, ip, ip, lsl #2
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ee68:	0843      	lsrs	r3, r0, #1
    ee6a:	0887      	lsrs	r7, r0, #2
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ee6c:	f100 0806 	add.w	r8, r0, #6
    ee70:	eba8 0849 	sub.w	r8, r8, r9, lsl #1
        q64 = (ui64Val>>1) + (ui64Val>>2);
    ee74:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
    ee78:	ea47 7781 	orr.w	r7, r7, r1, lsl #30
    ee7c:	088e      	lsrs	r6, r1, #2
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    ee7e:	4681      	mov	r9, r0
    if ( ui64Val >> 32 )
    ee80:	2900      	cmp	r1, #0
    ee82:	d1a0      	bne.n	edc6 <uint64_to_str+0xe>
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
    ee84:	eb0c 1018 	add.w	r0, ip, r8, lsr #4
        uMod = ui64Val - (u64Tmp * 10);
    ee88:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    ee8c:	eba9 0943 	sub.w	r9, r9, r3, lsl #1
        tbuf[ix++] = uMod + '0';
    ee90:	f109 0930 	add.w	r9, r9, #48	; 0x30
    ee94:	f88e 9000 	strb.w	r9, [lr]
        ui64Val = u64Tmp;
    } while ( ui64Val );
    ee98:	2800      	cmp	r0, #0
    ee9a:	d1d4      	bne.n	ee46 <uint64_to_str+0x8e>
    iNumDig = ix;

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
    ee9c:	b14a      	cbz	r2, eeb2 <uint64_to_str+0xfa>
    {
        while ( ix-- )
    ee9e:	192b      	adds	r3, r5, r4
    eea0:	1e51      	subs	r1, r2, #1
        {
            *pcBuf++ = tbuf[ix];
    eea2:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    eea6:	f801 0f01 	strb.w	r0, [r1, #1]!
        while ( ix-- )
    eeaa:	429d      	cmp	r5, r3
    eeac:	d1f9      	bne.n	eea2 <uint64_to_str+0xea>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
    eeae:	2300      	movs	r3, #0
    eeb0:	5513      	strb	r3, [r2, r4]
    }

    return iNumDig;
}
    eeb2:	4620      	mov	r0, r4
    eeb4:	b009      	add	sp, #36	; 0x24
    eeb6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    eeba:	bf00      	nop

0000eebc <am_util_stdio_printf_init>:
    g_pfnCharPrint = pfnCharPrint;
    eebc:	4b01      	ldr	r3, [pc, #4]	; (eec4 <am_util_stdio_printf_init+0x8>)
    eebe:	6018      	str	r0, [r3, #0]
}
    eec0:	4770      	bx	lr
    eec2:	bf00      	nop
    eec4:	1000146c 	.word	0x1000146c

0000eec8 <am_util_stdio_vsprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
    eec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;

    while ( *pcFmt != 0x0 )
    eecc:	780b      	ldrb	r3, [r1, #0]
{
    eece:	b089      	sub	sp, #36	; 0x24
    eed0:	4605      	mov	r5, r0
    while ( *pcFmt != 0x0 )
    eed2:	2b00      	cmp	r3, #0
    eed4:	f000 8097 	beq.w	f006 <am_util_stdio_vsprintf+0x13e>
    eed8:	4617      	mov	r7, r2
    uint32_t ui32NumChars, ui32CharCnt = 0;
    eeda:	2600      	movs	r6, #0
    eedc:	e00b      	b.n	eef6 <am_util_stdio_vsprintf+0x2e>
        if ( *pcFmt != '%' )
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
    eede:	b125      	cbz	r5, eeea <am_util_stdio_vsprintf+0x22>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    eee0:	2b0a      	cmp	r3, #10
    eee2:	f000 8085 	beq.w	eff0 <am_util_stdio_vsprintf+0x128>
                {
                    *pcBuf++ = '\r';
                    ++ui32CharCnt;
                }
                *pcBuf++ = *pcFmt;
    eee6:	f805 3b01 	strb.w	r3, [r5], #1
            }

            ++pcFmt;
    eeea:	3101      	adds	r1, #1
            ++ui32CharCnt;
    eeec:	3601      	adds	r6, #1
    while ( *pcFmt != 0x0 )
    eeee:	780b      	ldrb	r3, [r1, #0]
    eef0:	2b00      	cmp	r3, #0
    eef2:	f000 8089 	beq.w	f008 <am_util_stdio_vsprintf+0x140>
        if ( *pcFmt != '%' )
    eef6:	2b25      	cmp	r3, #37	; 0x25
    eef8:	d1f1      	bne.n	eede <am_util_stdio_vsprintf+0x16>
        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';

        if ( *pcFmt == '0' )
    eefa:	784b      	ldrb	r3, [r1, #1]
    eefc:	2b30      	cmp	r3, #48	; 0x30
    eefe:	f000 8098 	beq.w	f032 <am_util_stdio_vsprintf+0x16a>
        ++pcFmt;
    ef02:	f101 0e01 	add.w	lr, r1, #1
        ui8PadChar = ' ';
    ef06:	2220      	movs	r2, #32
    if ( *pcStr == '-')
    ef08:	2b2d      	cmp	r3, #45	; 0x2d
    ef0a:	f000 8084 	beq.w	f016 <am_util_stdio_vsprintf+0x14e>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ef0e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    uint32_t ui32Val = 0, uCnt = 0;
    ef12:	f04f 0c00 	mov.w	ip, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ef16:	2909      	cmp	r1, #9
    ef18:	4674      	mov	r4, lr
    bool bNeg = false;
    ef1a:	46e0      	mov	r8, ip
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ef1c:	f200 8087 	bhi.w	f02e <am_util_stdio_vsprintf+0x166>
    ef20:	f10c 0c01 	add.w	ip, ip, #1
    ef24:	ebac 0c04 	sub.w	ip, ip, r4
    ef28:	2100      	movs	r1, #0
        ui32Val *= 10;
    ef2a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
        ui32Val += (*pcStr - '0');
    ef2e:	eb03 0141 	add.w	r1, r3, r1, lsl #1
    ef32:	eb04 090c 	add.w	r9, r4, ip
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ef36:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    ef3a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    ef3e:	2809      	cmp	r0, #9
        ui32Val += (*pcStr - '0');
    ef40:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    ef44:	d9f1      	bls.n	ef2a <am_util_stdio_vsprintf+0x62>
        pcFmt += ui32NumChars;

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ef46:	f81e 3009 	ldrb.w	r3, [lr, r9]
        pcFmt += ui32NumChars;
    ef4a:	eb0e 0409 	add.w	r4, lr, r9
    return bNeg ? -ui32Val : ui32Val;
    ef4e:	f1b8 0f00 	cmp.w	r8, #0
    ef52:	d000      	beq.n	ef56 <am_util_stdio_vsprintf+0x8e>
    ef54:	4249      	negs	r1, r1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ef56:	2b73      	cmp	r3, #115	; 0x73
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    ef58:	4608      	mov	r0, r1
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    ef5a:	f000 8125 	beq.w	f1a8 <am_util_stdio_vsprintf+0x2e0>
    ef5e:	ea81 78e1 	eor.w	r8, r1, r1, asr #31
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
    ef62:	2b2e      	cmp	r3, #46	; 0x2e
    ef64:	eba8 78e1 	sub.w	r8, r8, r1, asr #31
    ef68:	f000 80f2 	beq.w	f150 <am_util_stdio_vsprintf+0x288>
        iPrecision = 6;             // printf() default precision for %f is 6
    ef6c:	f04f 0906 	mov.w	r9, #6
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
    ef70:	2b6c      	cmp	r3, #108	; 0x6c
    ef72:	d104      	bne.n	ef7e <am_util_stdio_vsprintf+0xb6>
        {
            pcFmt++;
            if ( *pcFmt == 'l' )    // "ll" (long long)
    ef74:	7863      	ldrb	r3, [r4, #1]
    ef76:	2b6c      	cmp	r3, #108	; 0x6c
    ef78:	f000 8163 	beq.w	f242 <am_util_stdio_vsprintf+0x37a>
            pcFmt++;
    ef7c:	3401      	adds	r4, #1
                pcFmt++;
                bLongLong = true;
            }
        }

        switch ( *pcFmt )
    ef7e:	f1a3 0046 	sub.w	r0, r3, #70	; 0x46
    ef82:	2832      	cmp	r0, #50	; 0x32
    ef84:	d85a      	bhi.n	f03c <am_util_stdio_vsprintf+0x174>
    ef86:	e8df f010 	tbh	[pc, r0, lsl #1]
    ef8a:	005f      	.short	0x005f
    ef8c:	00590059 	.word	0x00590059
    ef90:	00590059 	.word	0x00590059
    ef94:	00590059 	.word	0x00590059
    ef98:	00590059 	.word	0x00590059
    ef9c:	00590059 	.word	0x00590059
    efa0:	00590059 	.word	0x00590059
    efa4:	00590059 	.word	0x00590059
    efa8:	00590059 	.word	0x00590059
    efac:	01dc0059 	.word	0x01dc0059
    efb0:	00590059 	.word	0x00590059
    efb4:	00590059 	.word	0x00590059
    efb8:	00590059 	.word	0x00590059
    efbc:	00590059 	.word	0x00590059
    efc0:	00590059 	.word	0x00590059
    efc4:	00b400c9 	.word	0x00b400c9
    efc8:	005f0059 	.word	0x005f0059
    efcc:	00590059 	.word	0x00590059
    efd0:	005900b4 	.word	0x005900b4
    efd4:	00590059 	.word	0x00590059
    efd8:	00590059 	.word	0x00590059
    efdc:	00590059 	.word	0x00590059
    efe0:	00590059 	.word	0x00590059
    efe4:	0059010e 	.word	0x0059010e
    efe8:	005900d2 	.word	0x005900d2
    efec:	02fb0059 	.word	0x02fb0059
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    eff0:	4acc      	ldr	r2, [pc, #816]	; (f324 <am_util_stdio_vsprintf+0x45c>)
    eff2:	7812      	ldrb	r2, [r2, #0]
    eff4:	2a00      	cmp	r2, #0
    eff6:	f43f af76 	beq.w	eee6 <am_util_stdio_vsprintf+0x1e>
                    *pcBuf++ = '\r';
    effa:	230d      	movs	r3, #13
    effc:	f805 3b01 	strb.w	r3, [r5], #1
                    ++ui32CharCnt;
    f000:	3601      	adds	r6, #1
                *pcBuf++ = *pcFmt;
    f002:	780b      	ldrb	r3, [r1, #0]
    f004:	e76f      	b.n	eee6 <am_util_stdio_vsprintf+0x1e>
    uint32_t ui32NumChars, ui32CharCnt = 0;
    f006:	461e      	mov	r6, r3
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
    f008:	b10d      	cbz	r5, f00e <am_util_stdio_vsprintf+0x146>
    {
        *pcBuf = 0x0;
    f00a:	2300      	movs	r3, #0
    f00c:	702b      	strb	r3, [r5, #0]
    }

    return (ui32CharCnt);
}
    f00e:	4630      	mov	r0, r6
    f010:	b009      	add	sp, #36	; 0x24
    f012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f016:	f89e 3001 	ldrb.w	r3, [lr, #1]
    f01a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
        uCnt++;
    f01e:	f04f 0c01 	mov.w	ip, #1
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f022:	2909      	cmp	r1, #9
        pcStr++;
    f024:	eb0e 040c 	add.w	r4, lr, ip
        bNeg = true;
    f028:	46e0      	mov	r8, ip
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f02a:	f67f af79 	bls.w	ef20 <am_util_stdio_vsprintf+0x58>
    f02e:	2100      	movs	r1, #0
    f030:	e78d      	b.n	ef4e <am_util_stdio_vsprintf+0x86>
            ui8PadChar = '0';
    f032:	461a      	mov	r2, r3
            ++pcFmt;
    f034:	f101 0e02 	add.w	lr, r1, #2
    if ( *pcStr == '-')
    f038:	788b      	ldrb	r3, [r1, #2]
    f03a:	e765      	b.n	ef08 <am_util_stdio_vsprintf+0x40>
                if ( pcBuf )
    f03c:	b10d      	cbz	r5, f042 <am_util_stdio_vsprintf+0x17a>
                    *pcBuf++ = *pcFmt;
    f03e:	f805 3b01 	strb.w	r3, [r5], #1
                ++ui32CharCnt;
    f042:	3601      	adds	r6, #1
        ++pcFmt;
    f044:	1c61      	adds	r1, r4, #1
    f046:	e752      	b.n	eeee <am_util_stdio_vsprintf+0x26>
                if ( pcBuf )
    f048:	2d00      	cmp	r5, #0
    f04a:	d0fb      	beq.n	f044 <am_util_stdio_vsprintf+0x17c>
                    float fValue = va_arg(pArgs, double);
    f04c:	3707      	adds	r7, #7
    f04e:	f027 0707 	bic.w	r7, r7, #7
    f052:	e8f7 0102 	ldrd	r0, r1, [r7], #8
    f056:	f7fd fcc9 	bl	c9ec <__aeabi_d2f>
    f05a:	ee07 0a90 	vmov	s15, r0
    if (fValue == 0.0f)
    f05e:	eef5 7a40 	vcmp.f32	s15, #0.0
                    *(uint32_t*)pcBuf = 20;
    f062:	2314      	movs	r3, #20
    if (fValue == 0.0f)
    f064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    *(uint32_t*)pcBuf = 20;
    f068:	602b      	str	r3, [r5, #0]
    if (fValue == 0.0f)
    f06a:	f000 835d 	beq.w	f728 <am_util_stdio_vsprintf+0x860>
    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    f06e:	f3c0 51c7 	ubfx	r1, r0, #23, #8
    f072:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
    unFloatValue.F = fValue;
    f076:	4603      	mov	r3, r0
    if (iExp2 >= 31)
    f078:	2a1e      	cmp	r2, #30
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    f07a:	f3c0 0016 	ubfx	r0, r0, #0, #23
    f07e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    if (iExp2 >= 31)
    f082:	f300 837c 	bgt.w	f77e <am_util_stdio_vsprintf+0x8b6>
    else if (iExp2 < -23)
    f086:	f112 0f17 	cmn.w	r2, #23
    f08a:	f2c0 8374 	blt.w	f776 <am_util_stdio_vsprintf+0x8ae>
    else if (iExp2 >= 23)
    f08e:	2a16      	cmp	r2, #22
    f090:	f340 8246 	ble.w	f520 <am_util_stdio_vsprintf+0x658>
        i32IntPart = i32Significand << (iExp2 - 23);
    f094:	3996      	subs	r1, #150	; 0x96
    if (unFloatValue.I32 < 0)
    f096:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand << (iExp2 - 23);
    f098:	fa00 f001 	lsl.w	r0, r0, r1
    if (unFloatValue.I32 < 0)
    f09c:	f2c0 8287 	blt.w	f5ae <am_util_stdio_vsprintf+0x6e6>
    f0a0:	462b      	mov	r3, r5
    i32FracPart = 0;
    f0a2:	f04f 0800 	mov.w	r8, #0
    if (i32IntPart == 0)
    f0a6:	2800      	cmp	r0, #0
    f0a8:	f000 827c 	beq.w	f5a4 <am_util_stdio_vsprintf+0x6dc>
            *pcBuf++ = '-';
    f0ac:	461a      	mov	r2, r3
    f0ae:	bfde      	ittt	le
    f0b0:	232d      	movle	r3, #45	; 0x2d
    f0b2:	f802 3b01 	strble.w	r3, [r2], #1
            uint64_to_str(-i32IntPart, pcBuf);
    f0b6:	4240      	negle	r0, r0
    f0b8:	17c1      	asrs	r1, r0, #31
    f0ba:	f7ff fe7d 	bl	edb8 <uint64_to_str>
        while (*pcBuf)    // Get to end of new string
    f0be:	7813      	ldrb	r3, [r2, #0]
    f0c0:	b11b      	cbz	r3, f0ca <am_util_stdio_vsprintf+0x202>
    f0c2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    f0c6:	2b00      	cmp	r3, #0
    f0c8:	d1fb      	bne.n	f0c2 <am_util_stdio_vsprintf+0x1fa>
    *pcBuf++ = '.';
    f0ca:	232e      	movs	r3, #46	; 0x2e
    f0cc:	7013      	strb	r3, [r2, #0]
    if (i32FracPart == 0)
    f0ce:	f1b8 0f00 	cmp.w	r8, #0
    f0d2:	f040 8291 	bne.w	f5f8 <am_util_stdio_vsprintf+0x730>
        *pcBuf++ = '0';
    f0d6:	1c90      	adds	r0, r2, #2
    f0d8:	2330      	movs	r3, #48	; 0x30
    f0da:	7053      	strb	r3, [r2, #1]
    return (pcBuf - pcBufInitial);
    f0dc:	1b41      	subs	r1, r0, r5
    *pcBuf = 0x00;
    f0de:	2300      	movs	r3, #0
                    if ( iVal < 0 )
    f0e0:	4299      	cmp	r1, r3
    *pcBuf = 0x00;
    f0e2:	7003      	strb	r3, [r0, #0]
                    if ( iVal < 0 )
    f0e4:	f2c0 82c3 	blt.w	f66e <am_util_stdio_vsprintf+0x7a6>
                    ui32CharCnt += iVal;
    f0e8:	460b      	mov	r3, r1
    f0ea:	441e      	add	r6, r3
                    pcBuf += iVal;
    f0ec:	441d      	add	r5, r3
        ++pcFmt;
    f0ee:	1c61      	adds	r1, r4, #1
    f0f0:	e6fd      	b.n	eeee <am_util_stdio_vsprintf+0x26>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f0f2:	f857 9b04 	ldr.w	r9, [r7], #4
    f0f6:	ea4f 7ae9 	mov.w	sl, r9, asr #31
                if ( i64Val < 0 )
    f0fa:	f1ba 0f00 	cmp.w	sl, #0
    f0fe:	f2c0 8113 	blt.w	f328 <am_util_stdio_vsprintf+0x460>
                if ( iWidth )
    f102:	2900      	cmp	r1, #0
    f104:	f040 82bd 	bne.w	f682 <am_util_stdio_vsprintf+0x7ba>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f108:	4648      	mov	r0, r9
    f10a:	4651      	mov	r1, sl
    f10c:	462a      	mov	r2, r5
    f10e:	f7ff fe53 	bl	edb8 <uint64_to_str>
                if ( pcBuf )
    f112:	b9d5      	cbnz	r5, f14a <am_util_stdio_vsprintf+0x282>
                ui32CharCnt += iVal;
    f114:	2500      	movs	r5, #0
    f116:	4406      	add	r6, r0
        ++pcFmt;
    f118:	1c61      	adds	r1, r4, #1
    f11a:	e6e8      	b.n	eeee <am_util_stdio_vsprintf+0x26>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    f11c:	1d3b      	adds	r3, r7, #4
                if ( pcBuf )
    f11e:	b115      	cbz	r5, f126 <am_util_stdio_vsprintf+0x25e>
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    f120:	683a      	ldr	r2, [r7, #0]
    f122:	f805 2b01 	strb.w	r2, [r5], #1
                ++ui32CharCnt;
    f126:	3601      	adds	r6, #1
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
    f128:	461f      	mov	r7, r3
        ++pcFmt;
    f12a:	1c61      	adds	r1, r4, #1
    f12c:	e6df      	b.n	eeee <am_util_stdio_vsprintf+0x26>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f12e:	f857 ab04 	ldr.w	sl, [r7], #4
    f132:	f04f 0900 	mov.w	r9, #0
                if ( iWidth )
    f136:	2900      	cmp	r1, #0
    f138:	f040 81b0 	bne.w	f49c <am_util_stdio_vsprintf+0x5d4>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f13c:	4650      	mov	r0, sl
    f13e:	4649      	mov	r1, r9
    f140:	462a      	mov	r2, r5
    f142:	f7ff fe39 	bl	edb8 <uint64_to_str>
                if ( pcBuf )
    f146:	2d00      	cmp	r5, #0
    f148:	d0e4      	beq.n	f114 <am_util_stdio_vsprintf+0x24c>
                    pcBuf += iVal;
    f14a:	4405      	add	r5, r0
                ui32CharCnt += iVal;
    f14c:	4406      	add	r6, r0
                break;
    f14e:	e7e3      	b.n	f118 <am_util_stdio_vsprintf+0x250>
    if ( *pcStr == '-')
    f150:	7860      	ldrb	r0, [r4, #1]
    f152:	282d      	cmp	r0, #45	; 0x2d
            ++pcFmt;
    f154:	f104 0c01 	add.w	ip, r4, #1
    if ( *pcStr == '-')
    f158:	f000 8195 	beq.w	f486 <am_util_stdio_vsprintf+0x5be>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f15c:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    f160:	2b09      	cmp	r3, #9
    f162:	f200 82ea 	bhi.w	f73a <am_util_stdio_vsprintf+0x872>
    uint32_t ui32Val = 0, uCnt = 0;
    f166:	2300      	movs	r3, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f168:	4664      	mov	r4, ip
    bool bNeg = false;
    f16a:	4699      	mov	r9, r3
    f16c:	3301      	adds	r3, #1
    f16e:	eba3 0e04 	sub.w	lr, r3, r4
    f172:	2300      	movs	r3, #0
        ui32Val *= 10;
    f174:	eb03 0383 	add.w	r3, r3, r3, lsl #2
        ui32Val += (*pcStr - '0');
    f178:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    f17c:	eb04 0a0e 	add.w	sl, r4, lr
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f180:	f814 0f01 	ldrb.w	r0, [r4, #1]!
    f184:	f1a0 0b30 	sub.w	fp, r0, #48	; 0x30
    f188:	f1bb 0f09 	cmp.w	fp, #9
        ui32Val += (*pcStr - '0');
    f18c:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f190:	d9f0      	bls.n	f174 <am_util_stdio_vsprintf+0x2ac>
    return bNeg ? -ui32Val : ui32Val;
    f192:	f1b9 0f00 	cmp.w	r9, #0
    f196:	d000      	beq.n	f19a <am_util_stdio_vsprintf+0x2d2>
    f198:	425b      	negs	r3, r3
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    f19a:	4699      	mov	r9, r3
            pcFmt += ui32NumChars;
    f19c:	eb0c 040a 	add.w	r4, ip, sl
        if ( *pcFmt == 'l' )
    f1a0:	f81c 300a 	ldrb.w	r3, [ip, sl]
    f1a4:	e6e4      	b.n	ef70 <am_util_stdio_vsprintf+0xa8>
        switch ( *pcFmt )
    f1a6:	4640      	mov	r0, r8
                pcStr = va_arg(pArgs, char *);
    f1a8:	46b9      	mov	r9, r7
    f1aa:	f859 3b04 	ldr.w	r3, [r9], #4
    if ( !pcBuf )
    f1ae:	2b00      	cmp	r3, #0
    f1b0:	f000 81c6 	beq.w	f540 <am_util_stdio_vsprintf+0x678>
    while ( *pcBuf++ )
    f1b4:	469c      	mov	ip, r3
    f1b6:	f81c 1b01 	ldrb.w	r1, [ip], #1
    f1ba:	2900      	cmp	r1, #0
    f1bc:	f000 82c1 	beq.w	f742 <am_util_stdio_vsprintf+0x87a>
    uint32_t ui32RetVal = 0;
    f1c0:	f04f 0e00 	mov.w	lr, #0
    while ( *pcBuf++ )
    f1c4:	f81c 7b01 	ldrb.w	r7, [ip], #1
        ui32RetVal++;
    f1c8:	f10e 0e01 	add.w	lr, lr, #1
    while ( *pcBuf++ )
    f1cc:	2f00      	cmp	r7, #0
    f1ce:	d1f9      	bne.n	f1c4 <am_util_stdio_vsprintf+0x2fc>
                if ( iWidth > 0 )
    f1d0:	2800      	cmp	r0, #0
    f1d2:	dd02      	ble.n	f1da <am_util_stdio_vsprintf+0x312>
                    if ( ui32strlen < iWidth )
    f1d4:	4570      	cmp	r0, lr
    f1d6:	f200 81d6 	bhi.w	f586 <am_util_stdio_vsprintf+0x6be>
    f1da:	f1c3 0801 	rsb	r8, r3, #1
                while (*pcStr != 0x0)
    f1de:	46b2      	mov	sl, r6
    f1e0:	462f      	mov	r7, r5
    f1e2:	eb08 0c06 	add.w	ip, r8, r6
    f1e6:	e000      	b.n	f1ea <am_util_stdio_vsprintf+0x322>
                        *pcBuf++ = *pcStr;
    f1e8:	462f      	mov	r7, r5
    f1ea:	eb0c 0603 	add.w	r6, ip, r3
                    if ( pcBuf )
    f1ee:	2d00      	cmp	r5, #0
    f1f0:	f000 8131 	beq.w	f456 <am_util_stdio_vsprintf+0x58e>
                        *pcBuf++ = *pcStr;
    f1f4:	7039      	strb	r1, [r7, #0]
                while (*pcStr != 0x0)
    f1f6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
                        *pcBuf++ = *pcStr;
    f1fa:	3501      	adds	r5, #1
                while (*pcStr != 0x0)
    f1fc:	2900      	cmp	r1, #0
    f1fe:	d1f3      	bne.n	f1e8 <am_util_stdio_vsprintf+0x320>
                if ( iWidth )
    f200:	b1e0      	cbz	r0, f23c <am_util_stdio_vsprintf+0x374>
                    iWidth = -iWidth;
    f202:	f1c0 0800 	rsb	r8, r0, #0
                    if ( ui32strlen < iWidth )
    f206:	45f0      	cmp	r8, lr
    f208:	d918      	bls.n	f23c <am_util_stdio_vsprintf+0x374>
                        iWidth -= ui32strlen;
    f20a:	eba8 030e 	sub.w	r3, r8, lr
    if ( i32NumChars <= 0 )
    f20e:	2b00      	cmp	r3, #0
    f210:	f340 82b3 	ble.w	f77a <am_util_stdio_vsprintf+0x8b2>
    while ( i32NumChars-- )
    f214:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f216:	4694      	mov	ip, r2
    f218:	2000      	movs	r0, #0
    f21a:	461a      	mov	r2, r3
    f21c:	462b      	mov	r3, r5
            *pcBuf++ = cPadChar;
    f21e:	4619      	mov	r1, r3
        if ( pcBuf )
    f220:	2b00      	cmp	r3, #0
    f222:	f000 8129 	beq.w	f478 <am_util_stdio_vsprintf+0x5b0>
            *pcBuf++ = cPadChar;
    f226:	f801 cb01 	strb.w	ip, [r1], #1
    f22a:	4617      	mov	r7, r2
    f22c:	460b      	mov	r3, r1
        i32Cnt++;
    f22e:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f230:	1e7a      	subs	r2, r7, #1
    f232:	2f00      	cmp	r7, #0
    f234:	d1f3      	bne.n	f21e <am_util_stdio_vsprintf+0x356>
                        ui32CharCnt += iWidth;
    f236:	4406      	add	r6, r0
                        pcBuf += pcBuf ? iWidth : 0;
    f238:	b105      	cbz	r5, f23c <am_util_stdio_vsprintf+0x374>
    f23a:	4405      	add	r5, r0
                pcStr = va_arg(pArgs, char *);
    f23c:	464f      	mov	r7, r9
        ++pcFmt;
    f23e:	1c61      	adds	r1, r4, #1
    f240:	e655      	b.n	eeee <am_util_stdio_vsprintf+0x26>
        switch ( *pcFmt )
    f242:	78a3      	ldrb	r3, [r4, #2]
    f244:	f1a3 0046 	sub.w	r0, r3, #70	; 0x46
                pcFmt++;
    f248:	3402      	adds	r4, #2
        switch ( *pcFmt )
    f24a:	2832      	cmp	r0, #50	; 0x32
    f24c:	f63f aef6 	bhi.w	f03c <am_util_stdio_vsprintf+0x174>
    f250:	f20f 0c04 	addw	ip, pc, #4
    f254:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
    f258:	0000f049 	.word	0x0000f049
    f25c:	0000f03d 	.word	0x0000f03d
    f260:	0000f03d 	.word	0x0000f03d
    f264:	0000f03d 	.word	0x0000f03d
    f268:	0000f03d 	.word	0x0000f03d
    f26c:	0000f03d 	.word	0x0000f03d
    f270:	0000f03d 	.word	0x0000f03d
    f274:	0000f03d 	.word	0x0000f03d
    f278:	0000f03d 	.word	0x0000f03d
    f27c:	0000f03d 	.word	0x0000f03d
    f280:	0000f03d 	.word	0x0000f03d
    f284:	0000f03d 	.word	0x0000f03d
    f288:	0000f03d 	.word	0x0000f03d
    f28c:	0000f03d 	.word	0x0000f03d
    f290:	0000f03d 	.word	0x0000f03d
    f294:	0000f03d 	.word	0x0000f03d
    f298:	0000f03d 	.word	0x0000f03d
    f29c:	0000f03d 	.word	0x0000f03d
    f2a0:	0000f5d1 	.word	0x0000f5d1
    f2a4:	0000f03d 	.word	0x0000f03d
    f2a8:	0000f03d 	.word	0x0000f03d
    f2ac:	0000f03d 	.word	0x0000f03d
    f2b0:	0000f03d 	.word	0x0000f03d
    f2b4:	0000f03d 	.word	0x0000f03d
    f2b8:	0000f03d 	.word	0x0000f03d
    f2bc:	0000f03d 	.word	0x0000f03d
    f2c0:	0000f03d 	.word	0x0000f03d
    f2c4:	0000f03d 	.word	0x0000f03d
    f2c8:	0000f03d 	.word	0x0000f03d
    f2cc:	0000f11d 	.word	0x0000f11d
    f2d0:	0000f371 	.word	0x0000f371
    f2d4:	0000f03d 	.word	0x0000f03d
    f2d8:	0000f049 	.word	0x0000f049
    f2dc:	0000f03d 	.word	0x0000f03d
    f2e0:	0000f03d 	.word	0x0000f03d
    f2e4:	0000f371 	.word	0x0000f371
    f2e8:	0000f03d 	.word	0x0000f03d
    f2ec:	0000f03d 	.word	0x0000f03d
    f2f0:	0000f03d 	.word	0x0000f03d
    f2f4:	0000f03d 	.word	0x0000f03d
    f2f8:	0000f03d 	.word	0x0000f03d
    f2fc:	0000f03d 	.word	0x0000f03d
    f300:	0000f03d 	.word	0x0000f03d
    f304:	0000f03d 	.word	0x0000f03d
    f308:	0000f03d 	.word	0x0000f03d
    f30c:	0000f1a7 	.word	0x0000f1a7
    f310:	0000f03d 	.word	0x0000f03d
    f314:	0000f381 	.word	0x0000f381
    f318:	0000f03d 	.word	0x0000f03d
    f31c:	0000f03d 	.word	0x0000f03d
    f320:	0000f5e5 	.word	0x0000f5e5
    f324:	10001468 	.word	0x10001468
                    ui64Val = -i64Val;          // Get absolute value
    f328:	f1d9 0900 	rsbs	r9, r9, #0
    f32c:	eb6a 0a4a 	sbc.w	sl, sl, sl, lsl #1
                if ( iWidth )
    f330:	2900      	cmp	r1, #0
    f332:	f040 81fd 	bne.w	f730 <am_util_stdio_vsprintf+0x868>
                        if ( pcBuf )
    f336:	b115      	cbz	r5, f33e <am_util_stdio_vsprintf+0x476>
                            *pcBuf++ = '-';
    f338:	232d      	movs	r3, #45	; 0x2d
    f33a:	f805 3b01 	strb.w	r3, [r5], #1
                        ++ui32CharCnt;
    f33e:	3601      	adds	r6, #1
    f340:	e6e2      	b.n	f108 <am_util_stdio_vsprintf+0x240>
        bLower = bLongLong = false;
    f342:	f04f 0e00 	mov.w	lr, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f346:	f857 0b04 	ldr.w	r0, [r7], #4
    f34a:	f04f 0c00 	mov.w	ip, #0
                if ( iWidth )
    f34e:	b9f9      	cbnz	r1, f390 <am_util_stdio_vsprintf+0x4c8>
    if ( ui64Val == 0 )
    f350:	ea50 030c 	orrs.w	r3, r0, ip
    f354:	d14d      	bne.n	f3f2 <am_util_stdio_vsprintf+0x52a>
    if (pcBuf)
    f356:	2d00      	cmp	r5, #0
    f358:	d079      	beq.n	f44e <am_util_stdio_vsprintf+0x586>
            *pcBuf++ = tbuf[ix];
    f35a:	462b      	mov	r3, r5
    f35c:	2230      	movs	r2, #48	; 0x30
    f35e:	f803 2b01 	strb.w	r2, [r3], #1
    f362:	2201      	movs	r2, #1
    f364:	461d      	mov	r5, r3
        *pcBuf = 0;
    f366:	2100      	movs	r1, #0
    f368:	7019      	strb	r1, [r3, #0]
                ui32CharCnt += iVal;
    f36a:	4416      	add	r6, r2
        ++pcFmt;
    f36c:	1c61      	adds	r1, r4, #1
    f36e:	e5be      	b.n	eeee <am_util_stdio_vsprintf+0x26>
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
    f370:	3707      	adds	r7, #7
    f372:	f027 0707 	bic.w	r7, r7, #7
    f376:	f8d7 a004 	ldr.w	sl, [r7, #4]
    f37a:	f857 9b08 	ldr.w	r9, [r7], #8
    f37e:	e6bc      	b.n	f0fa <am_util_stdio_vsprintf+0x232>
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f380:	3707      	adds	r7, #7
    f382:	f027 0707 	bic.w	r7, r7, #7
    f386:	f8d7 9004 	ldr.w	r9, [r7, #4]
    f38a:	f857 ab08 	ldr.w	sl, [r7], #8
    f38e:	e6d2      	b.n	f136 <am_util_stdio_vsprintf+0x26e>
    int iDigits = ui64Val ? 0 : 1;
    f390:	ea50 030c 	orrs.w	r3, r0, ip
    f394:	bf0c      	ite	eq
    f396:	2101      	moveq	r1, #1
    f398:	2100      	movne	r1, #0
    while ( ui64Val )
    f39a:	d00b      	beq.n	f3b4 <am_util_stdio_vsprintf+0x4ec>
    f39c:	4603      	mov	r3, r0
    f39e:	46e1      	mov	r9, ip
        ui64Val >>= 4;
    f3a0:	091b      	lsrs	r3, r3, #4
    f3a2:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
    f3a6:	ea4f 1919 	mov.w	r9, r9, lsr #4
    while ( ui64Val )
    f3aa:	ea53 0a09 	orrs.w	sl, r3, r9
        ++iDigits;
    f3ae:	f101 0101 	add.w	r1, r1, #1
    while ( ui64Val )
    f3b2:	d1f5      	bne.n	f3a0 <am_util_stdio_vsprintf+0x4d8>
                    iWidth -= ndigits_in_hex(ui64Val);
    f3b4:	eba8 0301 	sub.w	r3, r8, r1
    if ( i32NumChars <= 0 )
    f3b8:	2b00      	cmp	r3, #0
    f3ba:	f340 81b2 	ble.w	f722 <am_util_stdio_vsprintf+0x85a>
    while ( i32NumChars-- )
    f3be:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f3c0:	4691      	mov	r9, r2
    f3c2:	4682      	mov	sl, r0
    f3c4:	f04f 0800 	mov.w	r8, #0
    f3c8:	462a      	mov	r2, r5
    f3ca:	4618      	mov	r0, r3
            *pcBuf++ = cPadChar;
    f3cc:	4611      	mov	r1, r2
        if ( pcBuf )
    f3ce:	2a00      	cmp	r2, #0
    f3d0:	d04c      	beq.n	f46c <am_util_stdio_vsprintf+0x5a4>
            *pcBuf++ = cPadChar;
    f3d2:	f801 9b01 	strb.w	r9, [r1], #1
    f3d6:	4603      	mov	r3, r0
    f3d8:	460a      	mov	r2, r1
        i32Cnt++;
    f3da:	f108 0801 	add.w	r8, r8, #1
    while ( i32NumChars-- )
    f3de:	1e58      	subs	r0, r3, #1
    f3e0:	2b00      	cmp	r3, #0
    f3e2:	d1f3      	bne.n	f3cc <am_util_stdio_vsprintf+0x504>
                    ui32CharCnt += iWidth;
    f3e4:	4650      	mov	r0, sl
    f3e6:	4446      	add	r6, r8
                    pcBuf += pcBuf ? iWidth : 0;
    f3e8:	b375      	cbz	r5, f448 <am_util_stdio_vsprintf+0x580>
    if ( ui64Val == 0 )
    f3ea:	ea50 030c 	orrs.w	r3, r0, ip
                    pcBuf += pcBuf ? iWidth : 0;
    f3ee:	4445      	add	r5, r8
    if ( ui64Val == 0 )
    f3f0:	d0b3      	beq.n	f35a <am_util_stdio_vsprintf+0x492>
    f3f2:	f1be 0f00 	cmp.w	lr, #0
    f3f6:	f10d 080c 	add.w	r8, sp, #12
    f3fa:	bf14      	ite	ne
    f3fc:	f04f 0927 	movne.w	r9, #39	; 0x27
    f400:	f04f 0907 	moveq.w	r9, #7
    f404:	4641      	mov	r1, r8
    int iNumDig, ix = 0;
    f406:	2200      	movs	r2, #0
        cCh = ui64Val & 0xf;
    f408:	f000 030f 	and.w	r3, r0, #15
        if ( cCh > 9 )
    f40c:	2b09      	cmp	r3, #9
            cCh += bLower ? 0x27 : 0x7;
    f40e:	bf88      	it	hi
    f410:	444b      	addhi	r3, r9
        ui64Val >>= 4;
    f412:	ea4f 1e10 	mov.w	lr, r0, lsr #4
    f416:	ea4e 700c 	orr.w	r0, lr, ip, lsl #28
        tbuf[ix++] = cCh + '0';
    f41a:	3330      	adds	r3, #48	; 0x30
        ui64Val >>= 4;
    f41c:	ea4f 1c1c 	mov.w	ip, ip, lsr #4
        tbuf[ix++] = cCh + '0';
    f420:	f801 3b01 	strb.w	r3, [r1], #1
    while ( ui64Val )
    f424:	ea50 030c 	orrs.w	r3, r0, ip
        tbuf[ix++] = cCh + '0';
    f428:	f102 0201 	add.w	r2, r2, #1
    while ( ui64Val )
    f42c:	d1ec      	bne.n	f408 <am_util_stdio_vsprintf+0x540>
    if (pcBuf)
    f42e:	b17d      	cbz	r5, f450 <am_util_stdio_vsprintf+0x588>
    f430:	eb08 0302 	add.w	r3, r8, r2
    f434:	1e69      	subs	r1, r5, #1
            *pcBuf++ = tbuf[ix];
    f436:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    f43a:	f801 0f01 	strb.w	r0, [r1, #1]!
        while (ix--)
    f43e:	4543      	cmp	r3, r8
    f440:	d1f9      	bne.n	f436 <am_util_stdio_vsprintf+0x56e>
            *pcBuf++ = tbuf[ix];
    f442:	18ab      	adds	r3, r5, r2
                    pcBuf += iVal;
    f444:	461d      	mov	r5, r3
    f446:	e78e      	b.n	f366 <am_util_stdio_vsprintf+0x49e>
    if ( ui64Val == 0 )
    f448:	ea50 030c 	orrs.w	r3, r0, ip
    f44c:	d1d1      	bne.n	f3f2 <am_util_stdio_vsprintf+0x52a>
    f44e:	2201      	movs	r2, #1
                if ( pcBuf )
    f450:	2500      	movs	r5, #0
                ui32CharCnt += iVal;
    f452:	4416      	add	r6, r2
                break;
    f454:	e78a      	b.n	f36c <am_util_stdio_vsprintf+0x4a4>
    f456:	eb08 010a 	add.w	r1, r8, sl
                    ++ui32CharCnt;
    f45a:	18ce      	adds	r6, r1, r3
                while (*pcStr != 0x0)
    f45c:	f813 7f01 	ldrb.w	r7, [r3, #1]!
    f460:	2f00      	cmp	r7, #0
    f462:	d1fa      	bne.n	f45a <am_util_stdio_vsprintf+0x592>
                if ( iWidth )
    f464:	2800      	cmp	r0, #0
    f466:	f43f aee9 	beq.w	f23c <am_util_stdio_vsprintf+0x374>
    f46a:	e6ca      	b.n	f202 <am_util_stdio_vsprintf+0x33a>
    while ( i32NumChars-- )
    f46c:	1e43      	subs	r3, r0, #1
        i32Cnt++;
    f46e:	f108 0801 	add.w	r8, r8, #1
    while ( i32NumChars-- )
    f472:	2800      	cmp	r0, #0
    f474:	d1b1      	bne.n	f3da <am_util_stdio_vsprintf+0x512>
    f476:	e7b5      	b.n	f3e4 <am_util_stdio_vsprintf+0x51c>
    f478:	1e57      	subs	r7, r2, #1
        i32Cnt++;
    f47a:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f47c:	2a00      	cmp	r2, #0
    f47e:	f47f aed6 	bne.w	f22e <am_util_stdio_vsprintf+0x366>
                        ui32CharCnt += iWidth;
    f482:	4406      	add	r6, r0
    f484:	e6d8      	b.n	f238 <am_util_stdio_vsprintf+0x370>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f486:	78a0      	ldrb	r0, [r4, #2]
    f488:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    f48c:	2b09      	cmp	r3, #9
        pcStr++;
    f48e:	f104 0402 	add.w	r4, r4, #2
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f492:	f200 8176 	bhi.w	f782 <am_util_stdio_vsprintf+0x8ba>
        uCnt++;
    f496:	2301      	movs	r3, #1
        bNeg = true;
    f498:	4699      	mov	r9, r3
    f49a:	e667      	b.n	f16c <am_util_stdio_vsprintf+0x2a4>
    int iNDigits = ui64Val ? 0 : 1;
    f49c:	ea5a 0309 	orrs.w	r3, sl, r9
    f4a0:	bf0c      	ite	eq
    f4a2:	f04f 0b01 	moveq.w	fp, #1
    f4a6:	f04f 0b00 	movne.w	fp, #0
    while ( ui64Val )
    f4aa:	d012      	beq.n	f4d2 <am_util_stdio_vsprintf+0x60a>
    f4ac:	4649      	mov	r1, r9
    f4ae:	9400      	str	r4, [sp, #0]
    f4b0:	4650      	mov	r0, sl
    f4b2:	465c      	mov	r4, fp
    f4b4:	46cb      	mov	fp, r9
    f4b6:	46a9      	mov	r9, r5
    f4b8:	4615      	mov	r5, r2
        ui64Val = divu64_10(ui64Val);
    f4ba:	f7ff fc21 	bl	ed00 <divu64_10>
    while ( ui64Val )
    f4be:	ea50 0301 	orrs.w	r3, r0, r1
        ++iNDigits;
    f4c2:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    f4c6:	d1f8      	bne.n	f4ba <am_util_stdio_vsprintf+0x5f2>
    f4c8:	462a      	mov	r2, r5
    f4ca:	464d      	mov	r5, r9
    f4cc:	46d9      	mov	r9, fp
    f4ce:	46a3      	mov	fp, r4
    f4d0:	9c00      	ldr	r4, [sp, #0]
                    iWidth -= ndigits_in_u64(ui64Val);
    f4d2:	eba8 030b 	sub.w	r3, r8, fp
    if ( i32NumChars <= 0 )
    f4d6:	2b00      	cmp	r3, #0
    f4d8:	f340 8149 	ble.w	f76e <am_util_stdio_vsprintf+0x8a6>
    while ( i32NumChars-- )
    f4dc:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f4de:	4694      	mov	ip, r2
    f4e0:	46a6      	mov	lr, r4
    f4e2:	2000      	movs	r0, #0
    f4e4:	462a      	mov	r2, r5
    f4e6:	461c      	mov	r4, r3
            *pcBuf++ = cPadChar;
    f4e8:	4611      	mov	r1, r2
        if ( pcBuf )
    f4ea:	b1a2      	cbz	r2, f516 <am_util_stdio_vsprintf+0x64e>
            *pcBuf++ = cPadChar;
    f4ec:	f801 cb01 	strb.w	ip, [r1], #1
    f4f0:	4623      	mov	r3, r4
    f4f2:	460a      	mov	r2, r1
        i32Cnt++;
    f4f4:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f4f6:	1e5c      	subs	r4, r3, #1
    f4f8:	2b00      	cmp	r3, #0
    f4fa:	d1f5      	bne.n	f4e8 <am_util_stdio_vsprintf+0x620>
                    ui32CharCnt += iWidth;
    f4fc:	4674      	mov	r4, lr
    f4fe:	4406      	add	r6, r0
                    pcBuf += pcBuf ? iWidth : 0;
    f500:	2d00      	cmp	r5, #0
    f502:	f000 8123 	beq.w	f74c <am_util_stdio_vsprintf+0x884>
    f506:	4405      	add	r5, r0
                iVal = uint64_to_str(ui64Val, pcBuf);
    f508:	462a      	mov	r2, r5
    f50a:	4650      	mov	r0, sl
    f50c:	4649      	mov	r1, r9
    f50e:	f7ff fc53 	bl	edb8 <uint64_to_str>
                    pcBuf += iVal;
    f512:	4405      	add	r5, r0
    f514:	e61a      	b.n	f14c <am_util_stdio_vsprintf+0x284>
    while ( i32NumChars-- )
    f516:	1e63      	subs	r3, r4, #1
        i32Cnt++;
    f518:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f51a:	2c00      	cmp	r4, #0
    f51c:	d1ea      	bne.n	f4f4 <am_util_stdio_vsprintf+0x62c>
    f51e:	e7ed      	b.n	f4fc <am_util_stdio_vsprintf+0x634>
    else if (iExp2 >= 0)
    f520:	2a00      	cmp	r2, #0
    f522:	db36      	blt.n	f592 <am_util_stdio_vsprintf+0x6ca>
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f524:	f1a1 087e 	sub.w	r8, r1, #126	; 0x7e
    f528:	fa00 f808 	lsl.w	r8, r0, r8
        i32IntPart = i32Significand >> (23 - iExp2);
    f52c:	f1c2 0217 	rsb	r2, r2, #23
    if (unFloatValue.I32 < 0)
    f530:	2b00      	cmp	r3, #0
        i32IntPart = i32Significand >> (23 - iExp2);
    f532:	fa40 f002 	asr.w	r0, r0, r2
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    f536:	f028 487f 	bic.w	r8, r8, #4278190080	; 0xff000000
    if (unFloatValue.I32 < 0)
    f53a:	db3a      	blt.n	f5b2 <am_util_stdio_vsprintf+0x6ea>
    f53c:	462a      	mov	r2, r5
    f53e:	e5bb      	b.n	f0b8 <am_util_stdio_vsprintf+0x1f0>
                if ( iWidth > 0 )
    f540:	2800      	cmp	r0, #0
    f542:	dd3b      	ble.n	f5bc <am_util_stdio_vsprintf+0x6f4>
        return ui32RetVal;
    f544:	469e      	mov	lr, r3
    int32_t i32Cnt = 0;
    f546:	469c      	mov	ip, r3
    while ( i32NumChars-- )
    f548:	f100 38ff 	add.w	r8, r0, #4294967295
    int32_t i32Cnt = 0;
    f54c:	2100      	movs	r1, #0
    f54e:	462b      	mov	r3, r5
            *pcBuf++ = cPadChar;
    f550:	4618      	mov	r0, r3
        if ( pcBuf )
    f552:	2b00      	cmp	r3, #0
    f554:	d049      	beq.n	f5ea <am_util_stdio_vsprintf+0x722>
            *pcBuf++ = cPadChar;
    f556:	f800 2b01 	strb.w	r2, [r0], #1
    f55a:	4647      	mov	r7, r8
    f55c:	4603      	mov	r3, r0
        i32Cnt++;
    f55e:	3101      	adds	r1, #1
    while ( i32NumChars-- )
    f560:	f107 38ff 	add.w	r8, r7, #4294967295
    f564:	2f00      	cmp	r7, #0
    f566:	d1f3      	bne.n	f550 <am_util_stdio_vsprintf+0x688>
                        ui32CharCnt += iWidth;
    f568:	4608      	mov	r0, r1
    f56a:	440e      	add	r6, r1
                while (*pcStr != 0x0)
    f56c:	f89c 1000 	ldrb.w	r1, [ip]
                        ui32CharCnt += iWidth;
    f570:	4663      	mov	r3, ip
                        pcBuf += pcBuf ? iWidth : 0;
    f572:	b105      	cbz	r5, f576 <am_util_stdio_vsprintf+0x6ae>
    f574:	4405      	add	r5, r0
                while (*pcStr != 0x0)
    f576:	2900      	cmp	r1, #0
    f578:	f43f ae60 	beq.w	f23c <am_util_stdio_vsprintf+0x374>
                        iWidth = 0;
    f57c:	2000      	movs	r0, #0
    f57e:	e62c      	b.n	f1da <am_util_stdio_vsprintf+0x312>
        switch ( *pcFmt )
    f580:	f04f 0e01 	mov.w	lr, #1
    f584:	e6df      	b.n	f346 <am_util_stdio_vsprintf+0x47e>
                        iWidth -= ui32strlen;
    f586:	eba0 000e 	sub.w	r0, r0, lr
    if ( i32NumChars <= 0 )
    f58a:	2800      	cmp	r0, #0
    f58c:	dcdb      	bgt.n	f546 <am_util_stdio_vsprintf+0x67e>
    f58e:	4638      	mov	r0, r7
    f590:	e7ef      	b.n	f572 <am_util_stdio_vsprintf+0x6aa>
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f592:	43d2      	mvns	r2, r2
    if (unFloatValue.I32 < 0)
    f594:	2b00      	cmp	r3, #0
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    f596:	fa40 f802 	asr.w	r8, r0, r2
        *pcBuf++ = '-';
    f59a:	462b      	mov	r3, r5
    if (unFloatValue.I32 < 0)
    f59c:	da02      	bge.n	f5a4 <am_util_stdio_vsprintf+0x6dc>
        *pcBuf++ = '-';
    f59e:	222d      	movs	r2, #45	; 0x2d
    f5a0:	f803 2b01 	strb.w	r2, [r3], #1
        *pcBuf++ = '0';
    f5a4:	461a      	mov	r2, r3
    f5a6:	2330      	movs	r3, #48	; 0x30
    f5a8:	f802 3b01 	strb.w	r3, [r2], #1
    f5ac:	e58d      	b.n	f0ca <am_util_stdio_vsprintf+0x202>
    i32FracPart = 0;
    f5ae:	f04f 0800 	mov.w	r8, #0
        *pcBuf++ = '-';
    f5b2:	462b      	mov	r3, r5
    f5b4:	222d      	movs	r2, #45	; 0x2d
    f5b6:	f803 2b01 	strb.w	r2, [r3], #1
    f5ba:	e574      	b.n	f0a6 <am_util_stdio_vsprintf+0x1de>
    while ( *pcBuf++ )
    f5bc:	7819      	ldrb	r1, [r3, #0]
                while (*pcStr != 0x0)
    f5be:	469e      	mov	lr, r3
    f5c0:	2900      	cmp	r1, #0
    f5c2:	f47f ae0a 	bne.w	f1da <am_util_stdio_vsprintf+0x312>
    f5c6:	468e      	mov	lr, r1
                if ( iWidth )
    f5c8:	2800      	cmp	r0, #0
    f5ca:	f43f ae37 	beq.w	f23c <am_util_stdio_vsprintf+0x374>
    f5ce:	e618      	b.n	f202 <am_util_stdio_vsprintf+0x33a>
        bLower = bLongLong = false;
    f5d0:	f04f 0e00 	mov.w	lr, #0
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    f5d4:	3707      	adds	r7, #7
    f5d6:	f027 0707 	bic.w	r7, r7, #7
    f5da:	f8d7 c004 	ldr.w	ip, [r7, #4]
    f5de:	f857 0b08 	ldr.w	r0, [r7], #8
    f5e2:	e6b4      	b.n	f34e <am_util_stdio_vsprintf+0x486>
        switch ( *pcFmt )
    f5e4:	f04f 0e01 	mov.w	lr, #1
    f5e8:	e7f4      	b.n	f5d4 <am_util_stdio_vsprintf+0x70c>
    while ( i32NumChars-- )
    f5ea:	f108 37ff 	add.w	r7, r8, #4294967295
        i32Cnt++;
    f5ee:	3101      	adds	r1, #1
    while ( i32NumChars-- )
    f5f0:	f1b8 0f00 	cmp.w	r8, #0
    f5f4:	d1b3      	bne.n	f55e <am_util_stdio_vsprintf+0x696>
    f5f6:	e7b7      	b.n	f568 <am_util_stdio_vsprintf+0x6a0>
    *pcBuf++ = '.';
    f5f8:	f102 0c01 	add.w	ip, r2, #1
        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    f5fc:	ebac 0105 	sub.w	r1, ip, r5
    f600:	f1c1 0313 	rsb	r3, r1, #19
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
    f604:	454b      	cmp	r3, r9
    f606:	bfa8      	it	ge
    f608:	464b      	movge	r3, r9
        for (jx = 0; jx < iMax; jx++)
    f60a:	2b00      	cmp	r3, #0
    f60c:	f340 80ca 	ble.w	f7a4 <am_util_stdio_vsprintf+0x8dc>
    f610:	1c58      	adds	r0, r3, #1
    f612:	4410      	add	r0, r2
            i32FracPart *= 10;
    f614:	eb08 0888 	add.w	r8, r8, r8, lsl #2
            *pcBuf++ = (i32FracPart >> 24) + '0';
    f618:	ea4f 51e8 	mov.w	r1, r8, asr #23
    f61c:	3130      	adds	r1, #48	; 0x30
    f61e:	f80c 1b01 	strb.w	r1, [ip], #1
            i32FracPart *= 10;
    f622:	ea4f 0848 	mov.w	r8, r8, lsl #1
        for (jx = 0; jx < iMax; jx++)
    f626:	4560      	cmp	r0, ip
            i32FracPart &= 0x00FFFFFF;
    f628:	f028 487f 	bic.w	r8, r8, #4278190080	; 0xff000000
        for (jx = 0; jx < iMax; jx++)
    f62c:	d1f2      	bne.n	f614 <am_util_stdio_vsprintf+0x74c>
    f62e:	441a      	add	r2, r3
    return (pcBuf - pcBufInitial);
    f630:	1b41      	subs	r1, r0, r5
        if ( ((i32FracPart * 10) >> 24) >= 5 )
    f632:	eb08 0888 	add.w	r8, r8, r8, lsl #2
    f636:	f348 53c7 	sbfx	r3, r8, #23, #8
    f63a:	2b04      	cmp	r3, #4
    f63c:	f77f ad4f 	ble.w	f0de <am_util_stdio_vsprintf+0x216>
            while ( pcBuftmp >= pcBufInitial )
    f640:	4295      	cmp	r5, r2
    f642:	f63f ad4c 	bhi.w	f0de <am_util_stdio_vsprintf+0x216>
    f646:	4613      	mov	r3, r2
                    *pcBuftmp = '0';
    f648:	f04f 0e30 	mov.w	lr, #48	; 0x30
    f64c:	e004      	b.n	f658 <am_util_stdio_vsprintf+0x790>
    f64e:	f883 e001 	strb.w	lr, [r3, #1]
            while ( pcBuftmp >= pcBufInitial )
    f652:	429d      	cmp	r5, r3
    f654:	f63f ad43 	bhi.w	f0de <am_util_stdio_vsprintf+0x216>
                    *pcBuftmp = '0';
    f658:	469c      	mov	ip, r3
                if ( *pcBuftmp == '.' )
    f65a:	f813 2901 	ldrb.w	r2, [r3], #-1
    f65e:	2a2e      	cmp	r2, #46	; 0x2e
    f660:	d0f7      	beq.n	f652 <am_util_stdio_vsprintf+0x78a>
                else if ( *pcBuftmp == '9' )
    f662:	2a39      	cmp	r2, #57	; 0x39
    f664:	d0f3      	beq.n	f64e <am_util_stdio_vsprintf+0x786>
                    *pcBuftmp += 1;
    f666:	3201      	adds	r2, #1
    f668:	f88c 2000 	strb.w	r2, [ip]
                    break;
    f66c:	e537      	b.n	f0de <am_util_stdio_vsprintf+0x216>
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
    f66e:	1c4b      	adds	r3, r1, #1
    f670:	f000 8081 	beq.w	f776 <am_util_stdio_vsprintf+0x8ae>
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
    f674:	3102      	adds	r1, #2
    f676:	f000 8082 	beq.w	f77e <am_util_stdio_vsprintf+0x8b6>
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
    f67a:	4b4e      	ldr	r3, [pc, #312]	; (f7b4 <am_util_stdio_vsprintf+0x8ec>)
                        *(uint32_t*)pcBuf = u32PrntErrVal;
    f67c:	602b      	str	r3, [r5, #0]
    f67e:	2303      	movs	r3, #3
    f680:	e533      	b.n	f0ea <am_util_stdio_vsprintf+0x222>
    int iNDigits = ui64Val ? 0 : 1;
    f682:	ea59 010a 	orrs.w	r1, r9, sl
    f686:	bf0c      	ite	eq
    f688:	f04f 0b01 	moveq.w	fp, #1
    f68c:	f04f 0b00 	movne.w	fp, #0
    while ( ui64Val )
    f690:	f000 808a 	beq.w	f7a8 <am_util_stdio_vsprintf+0x8e0>
                    bNeg = false;
    f694:	2300      	movs	r3, #0
    f696:	9300      	str	r3, [sp, #0]
    f698:	4648      	mov	r0, r9
    f69a:	4651      	mov	r1, sl
    f69c:	9401      	str	r4, [sp, #4]
    f69e:	465c      	mov	r4, fp
    f6a0:	46d3      	mov	fp, sl
    f6a2:	46ca      	mov	sl, r9
    f6a4:	46a9      	mov	r9, r5
    f6a6:	4615      	mov	r5, r2
        ui64Val = divu64_10(ui64Val);
    f6a8:	f7ff fb2a 	bl	ed00 <divu64_10>
    while ( ui64Val )
    f6ac:	ea50 0301 	orrs.w	r3, r0, r1
        ++iNDigits;
    f6b0:	f104 0401 	add.w	r4, r4, #1
    while ( ui64Val )
    f6b4:	d1f8      	bne.n	f6a8 <am_util_stdio_vsprintf+0x7e0>
                    if ( bNeg )
    f6b6:	9900      	ldr	r1, [sp, #0]
                    iWidth -= ndigits_in_i64(ui64Val);
    f6b8:	462a      	mov	r2, r5
    f6ba:	464d      	mov	r5, r9
    f6bc:	46d1      	mov	r9, sl
    f6be:	46da      	mov	sl, fp
    f6c0:	46a3      	mov	fp, r4
    f6c2:	eba8 030b 	sub.w	r3, r8, fp
    f6c6:	9c01      	ldr	r4, [sp, #4]
                    if ( bNeg )
    f6c8:	b119      	cbz	r1, f6d2 <am_util_stdio_vsprintf+0x80a>
                        if ( ui8PadChar == '0' )
    f6ca:	2a30      	cmp	r2, #48	; 0x30
                        --iWidth;
    f6cc:	f103 33ff 	add.w	r3, r3, #4294967295
                        if ( ui8PadChar == '0' )
    f6d0:	d062      	beq.n	f798 <am_util_stdio_vsprintf+0x8d0>
    if ( i32NumChars <= 0 )
    f6d2:	2b00      	cmp	r3, #0
    f6d4:	dd4d      	ble.n	f772 <am_util_stdio_vsprintf+0x8aa>
    while ( i32NumChars-- )
    f6d6:	3b01      	subs	r3, #1
    int32_t i32Cnt = 0;
    f6d8:	4694      	mov	ip, r2
    f6da:	46a6      	mov	lr, r4
    f6dc:	2000      	movs	r0, #0
    f6de:	462a      	mov	r2, r5
    f6e0:	461c      	mov	r4, r3
            *pcBuf++ = cPadChar;
    f6e2:	4611      	mov	r1, r2
        if ( pcBuf )
    f6e4:	b1c2      	cbz	r2, f718 <am_util_stdio_vsprintf+0x850>
            *pcBuf++ = cPadChar;
    f6e6:	f801 cb01 	strb.w	ip, [r1], #1
    f6ea:	4623      	mov	r3, r4
    f6ec:	460a      	mov	r2, r1
        i32Cnt++;
    f6ee:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f6f0:	1e5c      	subs	r4, r3, #1
    f6f2:	2b00      	cmp	r3, #0
    f6f4:	d1f5      	bne.n	f6e2 <am_util_stdio_vsprintf+0x81a>
    f6f6:	4674      	mov	r4, lr
    f6f8:	4662      	mov	r2, ip
                    ui32CharCnt += iWidth;
    f6fa:	4406      	add	r6, r0
                    pcBuf += pcBuf ? iWidth : 0;
    f6fc:	b365      	cbz	r5, f758 <am_util_stdio_vsprintf+0x890>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f6fe:	9b00      	ldr	r3, [sp, #0]
                    pcBuf += pcBuf ? iWidth : 0;
    f700:	4405      	add	r5, r0
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f702:	b113      	cbz	r3, f70a <am_util_stdio_vsprintf+0x842>
    f704:	2a20      	cmp	r2, #32
    f706:	f43f ae17 	beq.w	f338 <am_util_stdio_vsprintf+0x470>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f70a:	462a      	mov	r2, r5
    f70c:	4648      	mov	r0, r9
    f70e:	4651      	mov	r1, sl
    f710:	f7ff fb52 	bl	edb8 <uint64_to_str>
                    pcBuf += iVal;
    f714:	4405      	add	r5, r0
    f716:	e519      	b.n	f14c <am_util_stdio_vsprintf+0x284>
    while ( i32NumChars-- )
    f718:	1e63      	subs	r3, r4, #1
        i32Cnt++;
    f71a:	3001      	adds	r0, #1
    while ( i32NumChars-- )
    f71c:	2c00      	cmp	r4, #0
    f71e:	d1e6      	bne.n	f6ee <am_util_stdio_vsprintf+0x826>
    f720:	e7e9      	b.n	f6f6 <am_util_stdio_vsprintf+0x82e>
    f722:	f04f 0800 	mov.w	r8, #0
    f726:	e65f      	b.n	f3e8 <am_util_stdio_vsprintf+0x520>
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    f728:	4b23      	ldr	r3, [pc, #140]	; (f7b8 <am_util_stdio_vsprintf+0x8f0>)
    f72a:	602b      	str	r3, [r5, #0]
    f72c:	2303      	movs	r3, #3
    f72e:	e4dc      	b.n	f0ea <am_util_stdio_vsprintf+0x222>
                    bNeg = true;
    f730:	2301      	movs	r3, #1
    f732:	9300      	str	r3, [sp, #0]
    int iNDigits = ui64Val ? 0 : 1;
    f734:	f04f 0b00 	mov.w	fp, #0
    f738:	e7ae      	b.n	f698 <am_util_stdio_vsprintf+0x7d0>
    uint32_t ui32Val = 0, uCnt = 0;
    f73a:	f04f 0a00 	mov.w	sl, #0
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f73e:	4653      	mov	r3, sl
    f740:	e52b      	b.n	f19a <am_util_stdio_vsprintf+0x2d2>
                if ( iWidth > 0 )
    f742:	2800      	cmp	r0, #0
    f744:	f77f af3f 	ble.w	f5c6 <am_util_stdio_vsprintf+0x6fe>
    uint32_t ui32RetVal = 0;
    f748:	468e      	mov	lr, r1
    f74a:	e6fc      	b.n	f546 <am_util_stdio_vsprintf+0x67e>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f74c:	462a      	mov	r2, r5
    f74e:	4650      	mov	r0, sl
    f750:	4649      	mov	r1, r9
    f752:	f7ff fb31 	bl	edb8 <uint64_to_str>
                if ( pcBuf )
    f756:	e4dd      	b.n	f114 <am_util_stdio_vsprintf+0x24c>
                    if ( bNeg  &&  (ui8PadChar == ' ') )
    f758:	9b00      	ldr	r3, [sp, #0]
    f75a:	b1b3      	cbz	r3, f78a <am_util_stdio_vsprintf+0x8c2>
    f75c:	2a20      	cmp	r2, #32
    f75e:	f43f adee 	beq.w	f33e <am_util_stdio_vsprintf+0x476>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f762:	462a      	mov	r2, r5
    f764:	4648      	mov	r0, r9
    f766:	4651      	mov	r1, sl
    f768:	f7ff fb26 	bl	edb8 <uint64_to_str>
                if ( pcBuf )
    f76c:	e4d2      	b.n	f114 <am_util_stdio_vsprintf+0x24c>
    f76e:	2000      	movs	r0, #0
    f770:	e6c6      	b.n	f500 <am_util_stdio_vsprintf+0x638>
    f772:	2000      	movs	r0, #0
    f774:	e7c2      	b.n	f6fc <am_util_stdio_vsprintf+0x834>
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
    f776:	4b10      	ldr	r3, [pc, #64]	; (f7b8 <am_util_stdio_vsprintf+0x8f0>)
    f778:	e780      	b.n	f67c <am_util_stdio_vsprintf+0x7b4>
    f77a:	2000      	movs	r0, #0
    f77c:	e55c      	b.n	f238 <am_util_stdio_vsprintf+0x370>
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
    f77e:	4b0f      	ldr	r3, [pc, #60]	; (f7bc <am_util_stdio_vsprintf+0x8f4>)
    f780:	e77c      	b.n	f67c <am_util_stdio_vsprintf+0x7b4>
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    f782:	2300      	movs	r3, #0
        uCnt++;
    f784:	f04f 0a01 	mov.w	sl, #1
    f788:	e506      	b.n	f198 <am_util_stdio_vsprintf+0x2d0>
                iVal = uint64_to_str(ui64Val, pcBuf);
    f78a:	4648      	mov	r0, r9
    f78c:	4651      	mov	r1, sl
    f78e:	462a      	mov	r2, r5
    f790:	f7ff fb12 	bl	edb8 <uint64_to_str>
                ui32CharCnt += iVal;
    f794:	4406      	add	r6, r0
                break;
    f796:	e4bf      	b.n	f118 <am_util_stdio_vsprintf+0x250>
                            if ( pcBuf )
    f798:	b115      	cbz	r5, f7a0 <am_util_stdio_vsprintf+0x8d8>
                                *pcBuf++ = '-';
    f79a:	212d      	movs	r1, #45	; 0x2d
    f79c:	f805 1b01 	strb.w	r1, [r5], #1
                            ++ui32CharCnt;
    f7a0:	3601      	adds	r6, #1
    f7a2:	e796      	b.n	f6d2 <am_util_stdio_vsprintf+0x80a>
    *pcBuf++ = '.';
    f7a4:	4660      	mov	r0, ip
    f7a6:	e744      	b.n	f632 <am_util_stdio_vsprintf+0x76a>
                    iWidth -= ndigits_in_i64(ui64Val);
    f7a8:	eba8 030b 	sub.w	r3, r8, fp
                    bNeg = false;
    f7ac:	468a      	mov	sl, r1
    f7ae:	9100      	str	r1, [sp, #0]
                    ui64Val = i64Val;
    f7b0:	4689      	mov	r9, r1
    f7b2:	e78e      	b.n	f6d2 <am_util_stdio_vsprintf+0x80a>
    f7b4:	003f2e3f 	.word	0x003f2e3f
    f7b8:	00302e30 	.word	0x00302e30
    f7bc:	00232e23 	.word	0x00232e23

0000f7c0 <am_util_stdio_sprintf>:
//! @return uint32_t representing the number of characters printed.
//
//******************************************************************************
uint32_t
am_util_stdio_sprintf(char *pcBuf, const char *pcFmt, ...)
{
    f7c0:	b40e      	push	{r1, r2, r3}
    f7c2:	b500      	push	{lr}
    f7c4:	b082      	sub	sp, #8
    f7c6:	aa03      	add	r2, sp, #12
    f7c8:	f852 1b04 	ldr.w	r1, [r2], #4
    uint32_t ui32CharCnt;

    va_list pArgs;
    va_start(pArgs, pcFmt);
    f7cc:	9201      	str	r2, [sp, #4]
    ui32CharCnt = am_util_stdio_vsprintf(pcBuf, pcFmt, pArgs);
    f7ce:	f7ff fb7b 	bl	eec8 <am_util_stdio_vsprintf>
    va_end(pArgs);

    return ui32CharCnt;
}
    f7d2:	b002      	add	sp, #8
    f7d4:	f85d eb04 	ldr.w	lr, [sp], #4
    f7d8:	b003      	add	sp, #12
    f7da:	4770      	bx	lr

0000f7dc <am_util_stdio_printf>:
//! @return uint32_t representing the number of characters printed.
//
// *****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
    f7dc:	b40f      	push	{r0, r1, r2, r3}
    f7de:	b530      	push	{r4, r5, lr}
    uint32_t ui32NumChars;

    if (!g_pfnCharPrint)
    f7e0:	4d09      	ldr	r5, [pc, #36]	; (f808 <am_util_stdio_printf+0x2c>)
    f7e2:	682c      	ldr	r4, [r5, #0]
{
    f7e4:	b083      	sub	sp, #12
    if (!g_pfnCharPrint)
    f7e6:	b14c      	cbz	r4, f7fc <am_util_stdio_printf+0x20>

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
    f7e8:	aa07      	add	r2, sp, #28
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f7ea:	9906      	ldr	r1, [sp, #24]
    f7ec:	4807      	ldr	r0, [pc, #28]	; (f80c <am_util_stdio_printf+0x30>)
    va_start(pArgs, pcFmt);
    f7ee:	9201      	str	r2, [sp, #4]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f7f0:	f7ff fb6a 	bl	eec8 <am_util_stdio_vsprintf>
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
    f7f4:	682b      	ldr	r3, [r5, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
    f7f6:	4604      	mov	r4, r0
    g_pfnCharPrint(g_prfbuf);
    f7f8:	4804      	ldr	r0, [pc, #16]	; (f80c <am_util_stdio_printf+0x30>)
    f7fa:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
}
    f7fc:	4620      	mov	r0, r4
    f7fe:	b003      	add	sp, #12
    f800:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    f804:	b004      	add	sp, #16
    f806:	4770      	bx	lr
    f808:	1000146c 	.word	0x1000146c
    f80c:	10001470 	.word	0x10001470

0000f810 <am_util_stdio_terminal_clear>:
    // left corner.
    // We'll first print a number of spaces, which helps get the ITM in sync
    // with AM Flash, especially after a reset event or a system clock
    // frequency change.
    //
    am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    f810:	4801      	ldr	r0, [pc, #4]	; (f818 <am_util_stdio_terminal_clear+0x8>)
    f812:	f7ff bfe3 	b.w	f7dc <am_util_stdio_printf>
    f816:	bf00      	nop
    f818:	00011684 	.word	0x00011684

0000f81c <NMI_Handler>:
NMI_Handler(void)
{
    //
    // Go into an infinite loop.
    //
    while(1)
    f81c:	e7fe      	b.n	f81c <NMI_Handler>
    f81e:	bf00      	nop

0000f820 <BusFault_Handler>:
HardFault_Handler(void)
{
    //
    // Go into an infinite loop.
    //
    while(1)
    f820:	e7fe      	b.n	f820 <BusFault_Handler>
    f822:	bf00      	nop

0000f824 <DebugMon_Handler>:
am_default_isr(void)
{
    //
    // Go into an infinite loop.
    //
    while(1)
    f824:	e7fe      	b.n	f824 <DebugMon_Handler>
    f826:	bf00      	nop

0000f828 <Reset_Handler>:
    __asm("    ldr    r0, =0xE000ED08\n"
    f828:	4811      	ldr	r0, [pc, #68]	; (f870 <zero_loop+0x12>)
    f82a:	4912      	ldr	r1, [pc, #72]	; (f874 <zero_loop+0x16>)
    f82c:	6001      	str	r1, [r0, #0]
    __asm("    ldr    sp, [r1]");
    f82e:	f8d1 d000 	ldr.w	sp, [r1]
    __asm("ldr  r0, =0xE000ED88\n"
    f832:	4811      	ldr	r0, [pc, #68]	; (f878 <zero_loop+0x1a>)
    f834:	6801      	ldr	r1, [r0, #0]
    f836:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    f83a:	6001      	str	r1, [r0, #0]
    f83c:	f3bf 8f4f 	dsb	sy
    f840:	f3bf 8f6f 	isb	sy
    __asm("    ldr     r0, =_init_data\n"
    f844:	480d      	ldr	r0, [pc, #52]	; (f87c <zero_loop+0x1e>)
    f846:	490e      	ldr	r1, [pc, #56]	; (f880 <zero_loop+0x22>)
    f848:	4a0e      	ldr	r2, [pc, #56]	; (f884 <zero_loop+0x26>)

0000f84a <copy_loop>:
    f84a:	f850 3b04 	ldr.w	r3, [r0], #4
    f84e:	f841 3b04 	str.w	r3, [r1], #4
    f852:	4291      	cmp	r1, r2
    f854:	dbf9      	blt.n	f84a <copy_loop>
    __asm("    ldr     r0, =_sbss\n"
    f856:	480c      	ldr	r0, [pc, #48]	; (f888 <zero_loop+0x2a>)
    f858:	490c      	ldr	r1, [pc, #48]	; (f88c <zero_loop+0x2e>)
    f85a:	f04f 0200 	mov.w	r2, #0

0000f85e <zero_loop>:
    f85e:	4288      	cmp	r0, r1
    f860:	bfb8      	it	lt
    f862:	f840 2b04 	strlt.w	r2, [r0], #4
    f866:	dbfa      	blt.n	f85e <zero_loop>
    main();
    f868:	f7fd fc0a 	bl	d080 <main>
    __asm("    bkpt     ");
    f86c:	be00      	bkpt	0x0000
}
    f86e:	0000      	.short	0x0000
    f870:	e000ed08 	.word	0xe000ed08
    f874:	0000c000 	.word	0x0000c000
    f878:	e000ed88 	.word	0xe000ed88
    f87c:	00011b30 	.word	0x00011b30
    f880:	10001000 	.word	0x10001000
    f884:	10001040 	.word	0x10001040
    f888:	10001040 	.word	0x10001040
    f88c:	10001644 	.word	0x10001644

0000f890 <memset>:
    f890:	0783      	lsls	r3, r0, #30
    f892:	b530      	push	{r4, r5, lr}
    f894:	d048      	beq.n	f928 <memset+0x98>
    f896:	1e54      	subs	r4, r2, #1
    f898:	2a00      	cmp	r2, #0
    f89a:	d03f      	beq.n	f91c <memset+0x8c>
    f89c:	b2ca      	uxtb	r2, r1
    f89e:	4603      	mov	r3, r0
    f8a0:	e001      	b.n	f8a6 <memset+0x16>
    f8a2:	3c01      	subs	r4, #1
    f8a4:	d33a      	bcc.n	f91c <memset+0x8c>
    f8a6:	f803 2b01 	strb.w	r2, [r3], #1
    f8aa:	079d      	lsls	r5, r3, #30
    f8ac:	d1f9      	bne.n	f8a2 <memset+0x12>
    f8ae:	2c03      	cmp	r4, #3
    f8b0:	d92d      	bls.n	f90e <memset+0x7e>
    f8b2:	b2cd      	uxtb	r5, r1
    f8b4:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    f8b8:	2c0f      	cmp	r4, #15
    f8ba:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    f8be:	d936      	bls.n	f92e <memset+0x9e>
    f8c0:	f1a4 0210 	sub.w	r2, r4, #16
    f8c4:	f022 0c0f 	bic.w	ip, r2, #15
    f8c8:	f103 0e20 	add.w	lr, r3, #32
    f8cc:	44e6      	add	lr, ip
    f8ce:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    f8d2:	f103 0210 	add.w	r2, r3, #16
    f8d6:	e942 5504 	strd	r5, r5, [r2, #-16]
    f8da:	e942 5502 	strd	r5, r5, [r2, #-8]
    f8de:	3210      	adds	r2, #16
    f8e0:	4572      	cmp	r2, lr
    f8e2:	d1f8      	bne.n	f8d6 <memset+0x46>
    f8e4:	f10c 0201 	add.w	r2, ip, #1
    f8e8:	f014 0f0c 	tst.w	r4, #12
    f8ec:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    f8f0:	f004 0c0f 	and.w	ip, r4, #15
    f8f4:	d013      	beq.n	f91e <memset+0x8e>
    f8f6:	f1ac 0304 	sub.w	r3, ip, #4
    f8fa:	f023 0303 	bic.w	r3, r3, #3
    f8fe:	3304      	adds	r3, #4
    f900:	4413      	add	r3, r2
    f902:	f842 5b04 	str.w	r5, [r2], #4
    f906:	4293      	cmp	r3, r2
    f908:	d1fb      	bne.n	f902 <memset+0x72>
    f90a:	f00c 0403 	and.w	r4, ip, #3
    f90e:	b12c      	cbz	r4, f91c <memset+0x8c>
    f910:	b2ca      	uxtb	r2, r1
    f912:	441c      	add	r4, r3
    f914:	f803 2b01 	strb.w	r2, [r3], #1
    f918:	429c      	cmp	r4, r3
    f91a:	d1fb      	bne.n	f914 <memset+0x84>
    f91c:	bd30      	pop	{r4, r5, pc}
    f91e:	4664      	mov	r4, ip
    f920:	4613      	mov	r3, r2
    f922:	2c00      	cmp	r4, #0
    f924:	d1f4      	bne.n	f910 <memset+0x80>
    f926:	e7f9      	b.n	f91c <memset+0x8c>
    f928:	4603      	mov	r3, r0
    f92a:	4614      	mov	r4, r2
    f92c:	e7bf      	b.n	f8ae <memset+0x1e>
    f92e:	461a      	mov	r2, r3
    f930:	46a4      	mov	ip, r4
    f932:	e7e0      	b.n	f8f6 <memset+0x66>

0000f934 <am_bsp_uart_string_print>:
    f934:	b530      	push	{r4, r5, lr}
    f936:	b087      	sub	sp, #28
    f938:	7804      	ldrb	r4, [r0, #0]
    f93a:	2300      	movs	r3, #0
    f93c:	4605      	mov	r5, r0
    f93e:	9300      	str	r3, [sp, #0]
    f940:	b13c      	cbz	r4, f952 <am_bsp_uart_string_print+0x1e>
    f942:	4603      	mov	r3, r0
    f944:	f1c0 0101 	rsb	r1, r0, #1
    f948:	18cc      	adds	r4, r1, r3
    f94a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
    f94e:	2a00      	cmp	r2, #0
    f950:	d1fa      	bne.n	f948 <am_bsp_uart_string_print+0x14>
    f952:	4b0a      	ldr	r3, [pc, #40]	; (f97c <am_bsp_uart_string_print+0x48>)
    f954:	f8cd d014 	str.w	sp, [sp, #20]
    f958:	6818      	ldr	r0, [r3, #0]
    f95a:	2200      	movs	r2, #0
    f95c:	f04f 33ff 	mov.w	r3, #4294967295
    f960:	a901      	add	r1, sp, #4
    f962:	e9cd 4303 	strd	r4, r3, [sp, #12]
    f966:	e9cd 2501 	strd	r2, r5, [sp, #4]
    f96a:	f001 f8c9 	bl	10b00 <am_hal_uart_transfer>
    f96e:	9b00      	ldr	r3, [sp, #0]
    f970:	42a3      	cmp	r3, r4
    f972:	d000      	beq.n	f976 <am_bsp_uart_string_print+0x42>
    f974:	e7fe      	b.n	f974 <am_bsp_uart_string_print+0x40>
    f976:	b007      	add	sp, #28
    f978:	bd30      	pop	{r4, r5, pc}
    f97a:	bf00      	nop
    f97c:	10001570 	.word	0x10001570

0000f980 <am_bsp_low_power_init>:
    f980:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f982:	f000 fddf 	bl	10544 <am_hal_pwrctrl_low_power_init>
    f986:	f000 febb 	bl	10700 <am_hal_rtc_osc_disable>
    f98a:	4b0b      	ldr	r3, [pc, #44]	; (f9b8 <am_bsp_low_power_init+0x38>)
    f98c:	4f0b      	ldr	r7, [pc, #44]	; (f9bc <am_bsp_low_power_init+0x3c>)
    f98e:	681e      	ldr	r6, [r3, #0]
    f990:	2400      	movs	r4, #0
    f992:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
    f996:	4631      	mov	r1, r6
    f998:	4628      	mov	r0, r5
    f99a:	f000 fb13 	bl	ffc4 <am_hal_gpio_pinconfig>
    f99e:	2103      	movs	r1, #3
    f9a0:	4628      	mov	r0, r5
    f9a2:	f000 fc45 	bl	10230 <am_hal_gpio_state_write>
    f9a6:	3401      	adds	r4, #1
    f9a8:	2100      	movs	r1, #0
    f9aa:	4628      	mov	r0, r5
    f9ac:	f000 fc40 	bl	10230 <am_hal_gpio_state_write>
    f9b0:	2c05      	cmp	r4, #5
    f9b2:	d1ee      	bne.n	f992 <am_bsp_low_power_init+0x12>
    f9b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f9b6:	bf00      	nop
    f9b8:	000116d0 	.word	0x000116d0
    f9bc:	1000100c 	.word	0x1000100c

0000f9c0 <am_bsp_uart_printf_enable>:
    f9c0:	b510      	push	{r4, lr}
    f9c2:	4c10      	ldr	r4, [pc, #64]	; (fa04 <am_bsp_uart_printf_enable+0x44>)
    f9c4:	4b10      	ldr	r3, [pc, #64]	; (fa08 <am_bsp_uart_printf_enable+0x48>)
    f9c6:	4621      	mov	r1, r4
    f9c8:	2202      	movs	r2, #2
    f9ca:	2000      	movs	r0, #0
    f9cc:	601a      	str	r2, [r3, #0]
    f9ce:	f000 fee5 	bl	1079c <am_hal_uart_initialize>
    f9d2:	2200      	movs	r2, #0
    f9d4:	4611      	mov	r1, r2
    f9d6:	6820      	ldr	r0, [r4, #0]
    f9d8:	f000 ff1c 	bl	10814 <am_hal_uart_power_control>
    f9dc:	490b      	ldr	r1, [pc, #44]	; (fa0c <am_bsp_uart_printf_enable+0x4c>)
    f9de:	6820      	ldr	r0, [r4, #0]
    f9e0:	f000 ff90 	bl	10904 <am_hal_uart_configure>
    f9e4:	4b0a      	ldr	r3, [pc, #40]	; (fa10 <am_bsp_uart_printf_enable+0x50>)
    f9e6:	2016      	movs	r0, #22
    f9e8:	6819      	ldr	r1, [r3, #0]
    f9ea:	f000 faeb 	bl	ffc4 <am_hal_gpio_pinconfig>
    f9ee:	4b09      	ldr	r3, [pc, #36]	; (fa14 <am_bsp_uart_printf_enable+0x54>)
    f9f0:	2017      	movs	r0, #23
    f9f2:	6819      	ldr	r1, [r3, #0]
    f9f4:	f000 fae6 	bl	ffc4 <am_hal_gpio_pinconfig>
    f9f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f9fc:	4806      	ldr	r0, [pc, #24]	; (fa18 <am_bsp_uart_printf_enable+0x58>)
    f9fe:	f7ff ba5d 	b.w	eebc <am_util_stdio_printf_init>
    fa02:	bf00      	nop
    fa04:	10001570 	.word	0x10001570
    fa08:	10001574 	.word	0x10001574
    fa0c:	00011698 	.word	0x00011698
    fa10:	000116c4 	.word	0x000116c4
    fa14:	000116c0 	.word	0x000116c0
    fa18:	0000f935 	.word	0x0000f935

0000fa1c <am_bsp_uart_printf_disable>:
    fa1c:	b510      	push	{r4, lr}
    fa1e:	4c0e      	ldr	r4, [pc, #56]	; (fa58 <am_bsp_uart_printf_disable+0x3c>)
    fa20:	b082      	sub	sp, #8
    fa22:	6820      	ldr	r0, [r4, #0]
    fa24:	f001 fa6c 	bl	10f00 <am_hal_uart_tx_flush>
    fa28:	2000      	movs	r0, #0
    fa2a:	f7ff fa47 	bl	eebc <am_util_stdio_printf_init>
    fa2e:	2200      	movs	r2, #0
    fa30:	2102      	movs	r1, #2
    fa32:	6820      	ldr	r0, [r4, #0]
    fa34:	f000 feee 	bl	10814 <am_hal_uart_power_control>
    fa38:	6820      	ldr	r0, [r4, #0]
    fa3a:	f000 fed7 	bl	107ec <am_hal_uart_deinitialize>
    fa3e:	4b07      	ldr	r3, [pc, #28]	; (fa5c <am_bsp_uart_printf_disable+0x40>)
    fa40:	2016      	movs	r0, #22
    fa42:	6819      	ldr	r1, [r3, #0]
    fa44:	9101      	str	r1, [sp, #4]
    fa46:	f000 fabd 	bl	ffc4 <am_hal_gpio_pinconfig>
    fa4a:	9901      	ldr	r1, [sp, #4]
    fa4c:	2017      	movs	r0, #23
    fa4e:	b002      	add	sp, #8
    fa50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fa54:	f000 bab6 	b.w	ffc4 <am_hal_gpio_pinconfig>
    fa58:	10001570 	.word	0x10001570
    fa5c:	000116cc 	.word	0x000116cc

0000fa60 <am_hal_cachectrl_config>:
    fa60:	b530      	push	{r4, r5, lr}
    fa62:	b083      	sub	sp, #12
    fa64:	4604      	mov	r4, r0
    fa66:	f000 fc27 	bl	102b8 <am_hal_interrupt_master_disable>
    fa6a:	4d0e      	ldr	r5, [pc, #56]	; (faa4 <am_hal_cachectrl_config+0x44>)
    fa6c:	9001      	str	r0, [sp, #4]
    fa6e:	682b      	ldr	r3, [r5, #0]
    fa70:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    fa74:	602b      	str	r3, [r5, #0]
    fa76:	9801      	ldr	r0, [sp, #4]
    fa78:	f000 fc22 	bl	102c0 <am_hal_interrupt_master_set>
    fa7c:	7863      	ldrb	r3, [r4, #1]
    fa7e:	7822      	ldrb	r2, [r4, #0]
    fa80:	78a1      	ldrb	r1, [r4, #2]
    fa82:	021b      	lsls	r3, r3, #8
    fa84:	f403 7340 	and.w	r3, r3, #768	; 0x300
    fa88:	0112      	lsls	r2, r2, #4
    fa8a:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    fa8e:	b2d2      	uxtb	r2, r2
    fa90:	4313      	orrs	r3, r2
    fa92:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    fa96:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    fa9a:	2000      	movs	r0, #0
    fa9c:	602b      	str	r3, [r5, #0]
    fa9e:	b003      	add	sp, #12
    faa0:	bd30      	pop	{r4, r5, pc}
    faa2:	bf00      	nop
    faa4:	40018000 	.word	0x40018000

0000faa8 <am_hal_cachectrl_enable>:
    faa8:	4a03      	ldr	r2, [pc, #12]	; (fab8 <am_hal_cachectrl_enable+0x10>)
    faaa:	6813      	ldr	r3, [r2, #0]
    faac:	f043 0301 	orr.w	r3, r3, #1
    fab0:	2000      	movs	r0, #0
    fab2:	6013      	str	r3, [r2, #0]
    fab4:	4770      	bx	lr
    fab6:	bf00      	nop
    fab8:	40018000 	.word	0x40018000

0000fabc <am_hal_cachectrl_control>:
    fabc:	b510      	push	{r4, lr}
    fabe:	3801      	subs	r0, #1
    fac0:	b08e      	sub	sp, #56	; 0x38
    fac2:	2810      	cmp	r0, #16
    fac4:	f200 815e 	bhi.w	fd84 <am_hal_cachectrl_control+0x2c8>
    fac8:	e8df f010 	tbh	[pc, r0, lsl #1]
    facc:	00360018 	.word	0x00360018
    fad0:	0040003d 	.word	0x0040003d
    fad4:	00450043 	.word	0x00450043
    fad8:	0011001a 	.word	0x0011001a
    fadc:	00540047 	.word	0x00540047
    fae0:	009a0061 	.word	0x009a0061
    fae4:	010c00d3 	.word	0x010c00d3
    fae8:	013f0126 	.word	0x013f0126
    faec:	001d      	.short	0x001d
    faee:	f44f 7300 	mov.w	r3, #512	; 0x200
    faf2:	4aac      	ldr	r2, [pc, #688]	; (fda4 <am_hal_cachectrl_control+0x2e8>)
    faf4:	2000      	movs	r0, #0
    faf6:	6093      	str	r3, [r2, #8]
    faf8:	b00e      	add	sp, #56	; 0x38
    fafa:	bd10      	pop	{r4, pc}
    fafc:	2301      	movs	r3, #1
    fafe:	e7f8      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb00:	f44f 6380 	mov.w	r3, #1024	; 0x400
    fb04:	e7f5      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb06:	2900      	cmp	r1, #0
    fb08:	f000 813c 	beq.w	fd84 <am_hal_cachectrl_control+0x2c8>
    fb0c:	684a      	ldr	r2, [r1, #4]
    fb0e:	48a6      	ldr	r0, [pc, #664]	; (fda8 <am_hal_cachectrl_control+0x2ec>)
    fb10:	4202      	tst	r2, r0
    fb12:	f040 8137 	bne.w	fd84 <am_hal_cachectrl_control+0x2c8>
    fb16:	688b      	ldr	r3, [r1, #8]
    fb18:	4018      	ands	r0, r3
    fb1a:	f040 8133 	bne.w	fd84 <am_hal_cachectrl_control+0x2c8>
    fb1e:	780c      	ldrb	r4, [r1, #0]
    fb20:	2c00      	cmp	r4, #0
    fb22:	f040 8133 	bne.w	fd8c <am_hal_cachectrl_control+0x2d0>
    fb26:	4c9f      	ldr	r4, [pc, #636]	; (fda4 <am_hal_cachectrl_control+0x2e8>)
    fb28:	7849      	ldrb	r1, [r1, #1]
    fb2a:	6122      	str	r2, [r4, #16]
    fb2c:	6163      	str	r3, [r4, #20]
    fb2e:	6823      	ldr	r3, [r4, #0]
    fb30:	f361 0382 	bfi	r3, r1, #2, #1
    fb34:	6023      	str	r3, [r4, #0]
    fb36:	e7df      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fb38:	4b9a      	ldr	r3, [pc, #616]	; (fda4 <am_hal_cachectrl_control+0x2e8>)
    fb3a:	681b      	ldr	r3, [r3, #0]
    fb3c:	01db      	lsls	r3, r3, #7
    fb3e:	f140 811f 	bpl.w	fd80 <am_hal_cachectrl_control+0x2c4>
    fb42:	2302      	movs	r3, #2
    fb44:	e7d5      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb46:	f44f 6388 	mov.w	r3, #1088	; 0x440
    fb4a:	e7d2      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb4c:	f44f 7308 	mov.w	r3, #544	; 0x220
    fb50:	e7cf      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb52:	2340      	movs	r3, #64	; 0x40
    fb54:	e7cd      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb56:	2320      	movs	r3, #32
    fb58:	e7cb      	b.n	faf2 <am_hal_cachectrl_control+0x36>
    fb5a:	f000 fbad 	bl	102b8 <am_hal_interrupt_master_disable>
    fb5e:	4a91      	ldr	r2, [pc, #580]	; (fda4 <am_hal_cachectrl_control+0x2e8>)
    fb60:	9000      	str	r0, [sp, #0]
    fb62:	6813      	ldr	r3, [r2, #0]
    fb64:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    fb68:	6013      	str	r3, [r2, #0]
    fb6a:	9800      	ldr	r0, [sp, #0]
    fb6c:	f000 fba8 	bl	102c0 <am_hal_interrupt_master_set>
    fb70:	2000      	movs	r0, #0
    fb72:	e7c1      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fb74:	f000 fba0 	bl	102b8 <am_hal_interrupt_master_disable>
    fb78:	4a8a      	ldr	r2, [pc, #552]	; (fda4 <am_hal_cachectrl_control+0x2e8>)
    fb7a:	9001      	str	r0, [sp, #4]
    fb7c:	6813      	ldr	r3, [r2, #0]
    fb7e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    fb82:	6013      	str	r3, [r2, #0]
    fb84:	9801      	ldr	r0, [sp, #4]
    fb86:	f000 fb9b 	bl	102c0 <am_hal_interrupt_master_set>
    fb8a:	2000      	movs	r0, #0
    fb8c:	e7b4      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fb8e:	f000 fb93 	bl	102b8 <am_hal_interrupt_master_disable>
    fb92:	4603      	mov	r3, r0
    fb94:	4885      	ldr	r0, [pc, #532]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fb96:	9302      	str	r3, [sp, #8]
    fb98:	f000 fa0a 	bl	ffb0 <am_hal_flash_load_ui32>
    fb9c:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fba0:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fba4:	4881      	ldr	r0, [pc, #516]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fba6:	f000 fa07 	bl	ffb8 <am_hal_flash_store_ui32>
    fbaa:	9802      	ldr	r0, [sp, #8]
    fbac:	f000 fb88 	bl	102c0 <am_hal_interrupt_master_set>
    fbb0:	f000 fb82 	bl	102b8 <am_hal_interrupt_master_disable>
    fbb4:	4603      	mov	r3, r0
    fbb6:	487d      	ldr	r0, [pc, #500]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fbb8:	9303      	str	r3, [sp, #12]
    fbba:	f000 f9f9 	bl	ffb0 <am_hal_flash_load_ui32>
    fbbe:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fbc2:	f440 61ee 	orr.w	r1, r0, #1904	; 0x770
    fbc6:	4879      	ldr	r0, [pc, #484]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fbc8:	f000 f9f6 	bl	ffb8 <am_hal_flash_store_ui32>
    fbcc:	9803      	ldr	r0, [sp, #12]
    fbce:	f000 fb77 	bl	102c0 <am_hal_interrupt_master_set>
    fbd2:	f000 fb71 	bl	102b8 <am_hal_interrupt_master_disable>
    fbd6:	4603      	mov	r3, r0
    fbd8:	4874      	ldr	r0, [pc, #464]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fbda:	9304      	str	r3, [sp, #16]
    fbdc:	f000 f9e8 	bl	ffb0 <am_hal_flash_load_ui32>
    fbe0:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fbe4:	f020 000f 	bic.w	r0, r0, #15
    fbe8:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fbec:	f041 0103 	orr.w	r1, r1, #3
    fbf0:	486e      	ldr	r0, [pc, #440]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fbf2:	f000 f9e1 	bl	ffb8 <am_hal_flash_store_ui32>
    fbf6:	9804      	ldr	r0, [sp, #16]
    fbf8:	f000 fb62 	bl	102c0 <am_hal_interrupt_master_set>
    fbfc:	2000      	movs	r0, #0
    fbfe:	e77b      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fc00:	f000 fb5a 	bl	102b8 <am_hal_interrupt_master_disable>
    fc04:	4603      	mov	r3, r0
    fc06:	4869      	ldr	r0, [pc, #420]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc08:	9305      	str	r3, [sp, #20]
    fc0a:	f000 f9d1 	bl	ffb0 <am_hal_flash_load_ui32>
    fc0e:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fc12:	f440 51b8 	orr.w	r1, r0, #5888	; 0x1700
    fc16:	4865      	ldr	r0, [pc, #404]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc18:	f000 f9ce 	bl	ffb8 <am_hal_flash_store_ui32>
    fc1c:	9805      	ldr	r0, [sp, #20]
    fc1e:	f000 fb4f 	bl	102c0 <am_hal_interrupt_master_set>
    fc22:	f000 fb49 	bl	102b8 <am_hal_interrupt_master_disable>
    fc26:	4603      	mov	r3, r0
    fc28:	4860      	ldr	r0, [pc, #384]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc2a:	9306      	str	r3, [sp, #24]
    fc2c:	f000 f9c0 	bl	ffb0 <am_hal_flash_load_ui32>
    fc30:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fc34:	f440 61ea 	orr.w	r1, r0, #1872	; 0x750
    fc38:	485c      	ldr	r0, [pc, #368]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc3a:	f000 f9bd 	bl	ffb8 <am_hal_flash_store_ui32>
    fc3e:	9806      	ldr	r0, [sp, #24]
    fc40:	f000 fb3e 	bl	102c0 <am_hal_interrupt_master_set>
    fc44:	f000 fb38 	bl	102b8 <am_hal_interrupt_master_disable>
    fc48:	4603      	mov	r3, r0
    fc4a:	4858      	ldr	r0, [pc, #352]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc4c:	9307      	str	r3, [sp, #28]
    fc4e:	f000 f9af 	bl	ffb0 <am_hal_flash_load_ui32>
    fc52:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fc56:	f020 000f 	bic.w	r0, r0, #15
    fc5a:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fc5e:	f041 0101 	orr.w	r1, r1, #1
    fc62:	4852      	ldr	r0, [pc, #328]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc64:	f000 f9a8 	bl	ffb8 <am_hal_flash_store_ui32>
    fc68:	9807      	ldr	r0, [sp, #28]
    fc6a:	f000 fb29 	bl	102c0 <am_hal_interrupt_master_set>
    fc6e:	2000      	movs	r0, #0
    fc70:	e742      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fc72:	f000 fb21 	bl	102b8 <am_hal_interrupt_master_disable>
    fc76:	4603      	mov	r3, r0
    fc78:	484c      	ldr	r0, [pc, #304]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc7a:	9308      	str	r3, [sp, #32]
    fc7c:	f000 f998 	bl	ffb0 <am_hal_flash_load_ui32>
    fc80:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fc84:	f440 51b8 	orr.w	r1, r0, #5888	; 0x1700
    fc88:	4848      	ldr	r0, [pc, #288]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc8a:	f000 f995 	bl	ffb8 <am_hal_flash_store_ui32>
    fc8e:	9808      	ldr	r0, [sp, #32]
    fc90:	f000 fb16 	bl	102c0 <am_hal_interrupt_master_set>
    fc94:	f000 fb10 	bl	102b8 <am_hal_interrupt_master_disable>
    fc98:	4603      	mov	r3, r0
    fc9a:	4844      	ldr	r0, [pc, #272]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fc9c:	9309      	str	r3, [sp, #36]	; 0x24
    fc9e:	f000 f987 	bl	ffb0 <am_hal_flash_load_ui32>
    fca2:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fca6:	f440 61ec 	orr.w	r1, r0, #1888	; 0x760
    fcaa:	4840      	ldr	r0, [pc, #256]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fcac:	f000 f984 	bl	ffb8 <am_hal_flash_store_ui32>
    fcb0:	9809      	ldr	r0, [sp, #36]	; 0x24
    fcb2:	f000 fb05 	bl	102c0 <am_hal_interrupt_master_set>
    fcb6:	f000 faff 	bl	102b8 <am_hal_interrupt_master_disable>
    fcba:	4603      	mov	r3, r0
    fcbc:	483b      	ldr	r0, [pc, #236]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fcbe:	930a      	str	r3, [sp, #40]	; 0x28
    fcc0:	f000 f976 	bl	ffb0 <am_hal_flash_load_ui32>
    fcc4:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fcc8:	f020 000f 	bic.w	r0, r0, #15
    fccc:	f440 61e0 	orr.w	r1, r0, #1792	; 0x700
    fcd0:	f041 0101 	orr.w	r1, r1, #1
    fcd4:	4835      	ldr	r0, [pc, #212]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fcd6:	f000 f96f 	bl	ffb8 <am_hal_flash_store_ui32>
    fcda:	980a      	ldr	r0, [sp, #40]	; 0x28
    fcdc:	f000 faf0 	bl	102c0 <am_hal_interrupt_master_set>
    fce0:	2000      	movs	r0, #0
    fce2:	e709      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fce4:	2900      	cmp	r1, #0
    fce6:	d04d      	beq.n	fd84 <am_hal_cachectrl_control+0x2c8>
    fce8:	680c      	ldr	r4, [r1, #0]
    fcea:	2c03      	cmp	r4, #3
    fcec:	d84c      	bhi.n	fd88 <am_hal_cachectrl_control+0x2cc>
    fcee:	f000 fae3 	bl	102b8 <am_hal_interrupt_master_disable>
    fcf2:	4603      	mov	r3, r0
    fcf4:	482d      	ldr	r0, [pc, #180]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fcf6:	930b      	str	r3, [sp, #44]	; 0x2c
    fcf8:	f000 f95a 	bl	ffb0 <am_hal_flash_load_ui32>
    fcfc:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
    fd00:	ea40 3104 	orr.w	r1, r0, r4, lsl #12
    fd04:	f441 61e0 	orr.w	r1, r1, #1792	; 0x700
    fd08:	4828      	ldr	r0, [pc, #160]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fd0a:	f000 f955 	bl	ffb8 <am_hal_flash_store_ui32>
    fd0e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    fd10:	f000 fad6 	bl	102c0 <am_hal_interrupt_master_set>
    fd14:	2000      	movs	r0, #0
    fd16:	e6ef      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fd18:	b3a1      	cbz	r1, fd84 <am_hal_cachectrl_control+0x2c8>
    fd1a:	680c      	ldr	r4, [r1, #0]
    fd1c:	2c07      	cmp	r4, #7
    fd1e:	d833      	bhi.n	fd88 <am_hal_cachectrl_control+0x2cc>
    fd20:	f000 faca 	bl	102b8 <am_hal_interrupt_master_disable>
    fd24:	4603      	mov	r3, r0
    fd26:	4821      	ldr	r0, [pc, #132]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fd28:	930c      	str	r3, [sp, #48]	; 0x30
    fd2a:	f000 f941 	bl	ffb0 <am_hal_flash_load_ui32>
    fd2e:	f420 6077 	bic.w	r0, r0, #3952	; 0xf70
    fd32:	ea40 1104 	orr.w	r1, r0, r4, lsl #4
    fd36:	f441 61e0 	orr.w	r1, r1, #1792	; 0x700
    fd3a:	481c      	ldr	r0, [pc, #112]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fd3c:	f000 f93c 	bl	ffb8 <am_hal_flash_store_ui32>
    fd40:	980c      	ldr	r0, [sp, #48]	; 0x30
    fd42:	f000 fabd 	bl	102c0 <am_hal_interrupt_master_set>
    fd46:	2000      	movs	r0, #0
    fd48:	e6d6      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fd4a:	b1d9      	cbz	r1, fd84 <am_hal_cachectrl_control+0x2c8>
    fd4c:	680c      	ldr	r4, [r1, #0]
    fd4e:	2c0f      	cmp	r4, #15
    fd50:	d81a      	bhi.n	fd88 <am_hal_cachectrl_control+0x2cc>
    fd52:	f000 fab1 	bl	102b8 <am_hal_interrupt_master_disable>
    fd56:	4603      	mov	r3, r0
    fd58:	4814      	ldr	r0, [pc, #80]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fd5a:	930d      	str	r3, [sp, #52]	; 0x34
    fd5c:	f000 f928 	bl	ffb0 <am_hal_flash_load_ui32>
    fd60:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
    fd64:	f020 000f 	bic.w	r0, r0, #15
    fd68:	ea40 0104 	orr.w	r1, r0, r4
    fd6c:	f441 61e0 	orr.w	r1, r1, #1792	; 0x700
    fd70:	480e      	ldr	r0, [pc, #56]	; (fdac <am_hal_cachectrl_control+0x2f0>)
    fd72:	f000 f921 	bl	ffb8 <am_hal_flash_store_ui32>
    fd76:	980d      	ldr	r0, [sp, #52]	; 0x34
    fd78:	f000 faa2 	bl	102c0 <am_hal_interrupt_master_set>
    fd7c:	2000      	movs	r0, #0
    fd7e:	e6bb      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fd80:	2007      	movs	r0, #7
    fd82:	e6b9      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fd84:	2006      	movs	r0, #6
    fd86:	e6b7      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fd88:	2001      	movs	r0, #1
    fd8a:	e6b5      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fd8c:	2c01      	cmp	r4, #1
    fd8e:	d1f9      	bne.n	fd84 <am_hal_cachectrl_control+0x2c8>
    fd90:	4c04      	ldr	r4, [pc, #16]	; (fda4 <am_hal_cachectrl_control+0x2e8>)
    fd92:	7849      	ldrb	r1, [r1, #1]
    fd94:	61a2      	str	r2, [r4, #24]
    fd96:	61e3      	str	r3, [r4, #28]
    fd98:	6823      	ldr	r3, [r4, #0]
    fd9a:	f361 03c3 	bfi	r3, r1, #3, #1
    fd9e:	6023      	str	r3, [r4, #0]
    fda0:	e6aa      	b.n	faf8 <am_hal_cachectrl_control+0x3c>
    fda2:	bf00      	nop
    fda4:	40018000 	.word	0x40018000
    fda8:	f800000f 	.word	0xf800000f
    fdac:	40018004 	.word	0x40018004

0000fdb0 <am_hal_clkgen_control>:
    fdb0:	4b49      	ldr	r3, [pc, #292]	; (fed8 <am_hal_clkgen_control+0x128>)
    fdb2:	681a      	ldr	r2, [r3, #0]
    fdb4:	b912      	cbnz	r2, fdbc <am_hal_clkgen_control+0xc>
    fdb6:	4a49      	ldr	r2, [pc, #292]	; (fedc <am_hal_clkgen_control+0x12c>)
    fdb8:	6812      	ldr	r2, [r2, #0]
    fdba:	601a      	str	r2, [r3, #0]
    fdbc:	2809      	cmp	r0, #9
    fdbe:	f200 8089 	bhi.w	fed4 <am_hal_clkgen_control+0x124>
    fdc2:	e8df f000 	tbb	[pc, r0]
    fdc6:	160d      	.short	0x160d
    fdc8:	423a261e 	.word	0x423a261e
    fdcc:	055c544c 	.word	0x055c544c
    fdd0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fdd4:	2000      	movs	r0, #0
    fdd6:	6a1a      	ldr	r2, [r3, #32]
    fdd8:	f36f 0200 	bfc	r2, #0, #1
    fddc:	621a      	str	r2, [r3, #32]
    fdde:	4770      	bx	lr
    fde0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fde4:	2200      	movs	r2, #0
    fde6:	2147      	movs	r1, #71	; 0x47
    fde8:	6159      	str	r1, [r3, #20]
    fdea:	4610      	mov	r0, r2
    fdec:	619a      	str	r2, [r3, #24]
    fdee:	615a      	str	r2, [r3, #20]
    fdf0:	4770      	bx	lr
    fdf2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fdf6:	2000      	movs	r0, #0
    fdf8:	899a      	ldrh	r2, [r3, #12]
    fdfa:	f36f 0200 	bfc	r2, #0, #1
    fdfe:	819a      	strh	r2, [r3, #12]
    fe00:	4770      	bx	lr
    fe02:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fe06:	2000      	movs	r0, #0
    fe08:	899a      	ldrh	r2, [r3, #12]
    fe0a:	f36f 0241 	bfc	r2, #1, #1
    fe0e:	819a      	strh	r2, [r3, #12]
    fe10:	4770      	bx	lr
    fe12:	4a33      	ldr	r2, [pc, #204]	; (fee0 <am_hal_clkgen_control+0x130>)
    fe14:	68d3      	ldr	r3, [r2, #12]
    fe16:	b2db      	uxtb	r3, r3
    fe18:	2b21      	cmp	r3, #33	; 0x21
    fe1a:	d106      	bne.n	fe2a <am_hal_clkgen_control+0x7a>
    fe1c:	f8b2 3120 	ldrh.w	r3, [r2, #288]	; 0x120
    fe20:	2101      	movs	r1, #1
    fe22:	f361 2309 	bfi	r3, r1, #8, #2
    fe26:	f8a2 3120 	strh.w	r3, [r2, #288]	; 0x120
    fe2a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fe2e:	2000      	movs	r0, #0
    fe30:	8993      	ldrh	r3, [r2, #12]
    fe32:	f043 0301 	orr.w	r3, r3, #1
    fe36:	8193      	strh	r3, [r2, #12]
    fe38:	4770      	bx	lr
    fe3a:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fe3e:	2000      	movs	r0, #0
    fe40:	8993      	ldrh	r3, [r2, #12]
    fe42:	f043 0302 	orr.w	r3, r3, #2
    fe46:	8193      	strh	r3, [r2, #12]
    fe48:	4770      	bx	lr
    fe4a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fe4e:	2200      	movs	r2, #0
    fe50:	2047      	movs	r0, #71	; 0x47
    fe52:	2101      	movs	r1, #1
    fe54:	6158      	str	r0, [r3, #20]
    fe56:	6199      	str	r1, [r3, #24]
    fe58:	4610      	mov	r0, r2
    fe5a:	615a      	str	r2, [r3, #20]
    fe5c:	4770      	bx	lr
    fe5e:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    fe62:	2000      	movs	r0, #0
    fe64:	899a      	ldrh	r2, [r3, #12]
    fe66:	f36f 12c7 	bfc	r2, #7, #1
    fe6a:	819a      	strh	r2, [r3, #12]
    fe6c:	4770      	bx	lr
    fe6e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fe72:	2000      	movs	r0, #0
    fe74:	8993      	ldrh	r3, [r2, #12]
    fe76:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fe7a:	8193      	strh	r3, [r2, #12]
    fe7c:	4770      	bx	lr
    fe7e:	4a18      	ldr	r2, [pc, #96]	; (fee0 <am_hal_clkgen_control+0x130>)
    fe80:	68d3      	ldr	r3, [r2, #12]
    fe82:	b2db      	uxtb	r3, r3
    fe84:	2b21      	cmp	r3, #33	; 0x21
    fe86:	d00a      	beq.n	fe9e <am_hal_clkgen_control+0xee>
    fe88:	b139      	cbz	r1, fe9a <am_hal_clkgen_control+0xea>
    fe8a:	680b      	ldr	r3, [r1, #0]
    fe8c:	f043 0301 	orr.w	r3, r3, #1
    fe90:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fe94:	2000      	movs	r0, #0
    fe96:	6213      	str	r3, [r2, #32]
    fe98:	4770      	bx	lr
    fe9a:	4b12      	ldr	r3, [pc, #72]	; (fee4 <am_hal_clkgen_control+0x134>)
    fe9c:	e7f8      	b.n	fe90 <am_hal_clkgen_control+0xe0>
    fe9e:	b500      	push	{lr}
    fea0:	b083      	sub	sp, #12
    fea2:	f44f 507a 	mov.w	r0, #16000	; 0x3e80
    fea6:	9101      	str	r1, [sp, #4]
    fea8:	f8b2 3120 	ldrh.w	r3, [r2, #288]	; 0x120
    feac:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    feb0:	f8a2 3120 	strh.w	r3, [r2, #288]	; 0x120
    feb4:	f000 f836 	bl	ff24 <am_hal_flash_delay>
    feb8:	9901      	ldr	r1, [sp, #4]
    feba:	b149      	cbz	r1, fed0 <am_hal_clkgen_control+0x120>
    febc:	680b      	ldr	r3, [r1, #0]
    febe:	f043 0301 	orr.w	r3, r3, #1
    fec2:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    fec6:	2000      	movs	r0, #0
    fec8:	6213      	str	r3, [r2, #32]
    feca:	b003      	add	sp, #12
    fecc:	f85d fb04 	ldr.w	pc, [sp], #4
    fed0:	4b04      	ldr	r3, [pc, #16]	; (fee4 <am_hal_clkgen_control+0x134>)
    fed2:	e7f6      	b.n	fec2 <am_hal_clkgen_control+0x112>
    fed4:	2006      	movs	r0, #6
    fed6:	4770      	bx	lr
    fed8:	10001578 	.word	0x10001578
    fedc:	4ffff000 	.word	0x4ffff000
    fee0:	40020000 	.word	0x40020000
    fee4:	0025b801 	.word	0x0025b801

0000fee8 <am_hal_clkgen_status_get>:
    fee8:	b1b0      	cbz	r0, ff18 <am_hal_clkgen_status_get+0x30>
    feea:	b410      	push	{r4}
    feec:	f04f 2140 	mov.w	r1, #1073758208	; 0x40004000
    fef0:	4603      	mov	r3, r0
    fef2:	698c      	ldr	r4, [r1, #24]
    fef4:	4809      	ldr	r0, [pc, #36]	; (ff1c <am_hal_clkgen_status_get+0x34>)
    fef6:	4a0a      	ldr	r2, [pc, #40]	; (ff20 <am_hal_clkgen_status_get+0x38>)
    fef8:	f014 0f01 	tst.w	r4, #1
    fefc:	bf08      	it	eq
    fefe:	4602      	moveq	r2, r0
    ff00:	601a      	str	r2, [r3, #0]
    ff02:	69ca      	ldr	r2, [r1, #28]
    ff04:	f85d 4b04 	ldr.w	r4, [sp], #4
    ff08:	f002 0101 	and.w	r1, r2, #1
    ff0c:	f3c2 0240 	ubfx	r2, r2, #1, #1
    ff10:	2000      	movs	r0, #0
    ff12:	6059      	str	r1, [r3, #4]
    ff14:	721a      	strb	r2, [r3, #8]
    ff16:	4770      	bx	lr
    ff18:	2006      	movs	r0, #6
    ff1a:	4770      	bx	lr
    ff1c:	02dc6c00 	.word	0x02dc6c00
    ff20:	016e3600 	.word	0x016e3600

0000ff24 <am_hal_flash_delay>:
    ff24:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
    ff28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ff2a:	075b      	lsls	r3, r3, #29
    ff2c:	bf46      	itte	mi
    ff2e:	0040      	lslmi	r0, r0, #1
    ff30:	230e      	movmi	r3, #14
    ff32:	230b      	movpl	r3, #11
    ff34:	4298      	cmp	r0, r3
    ff36:	d902      	bls.n	ff3e <am_hal_flash_delay+0x1a>
    ff38:	4a01      	ldr	r2, [pc, #4]	; (ff40 <am_hal_flash_delay+0x1c>)
    ff3a:	1ac0      	subs	r0, r0, r3
    ff3c:	4710      	bx	r2
    ff3e:	4770      	bx	lr
    ff40:	0800009d 	.word	0x0800009d

0000ff44 <am_hal_flash_delay_status_check>:
    ff44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ff48:	f89d c020 	ldrb.w	ip, [sp, #32]
    ff4c:	f8df 805c 	ldr.w	r8, [pc, #92]	; ffac <am_hal_flash_delay_status_check+0x68>
    ff50:	4604      	mov	r4, r0
    ff52:	460d      	mov	r5, r1
    ff54:	4616      	mov	r6, r2
    ff56:	461f      	mov	r7, r3
    ff58:	f04f 2940 	mov.w	r9, #1073758208	; 0x40004000
    ff5c:	f1bc 0f00 	cmp.w	ip, #0
    ff60:	d00a      	beq.n	ff78 <am_hal_flash_delay_status_check+0x34>
    ff62:	e01a      	b.n	ff9a <am_hal_flash_delay_status_check+0x56>
    ff64:	b1f4      	cbz	r4, ffa4 <am_hal_flash_delay_status_check+0x60>
    ff66:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
    ff6a:	f013 0f04 	tst.w	r3, #4
    ff6e:	bf0c      	ite	eq
    ff70:	2005      	moveq	r0, #5
    ff72:	2012      	movne	r0, #18
    ff74:	3c01      	subs	r4, #1
    ff76:	47c0      	blx	r8
    ff78:	6828      	ldr	r0, [r5, #0]
    ff7a:	4030      	ands	r0, r6
    ff7c:	42b8      	cmp	r0, r7
    ff7e:	d0f1      	beq.n	ff64 <am_hal_flash_delay_status_check+0x20>
    ff80:	2000      	movs	r0, #0
    ff82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ff86:	b16c      	cbz	r4, ffa4 <am_hal_flash_delay_status_check+0x60>
    ff88:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
    ff8c:	f013 0f04 	tst.w	r3, #4
    ff90:	bf0c      	ite	eq
    ff92:	2005      	moveq	r0, #5
    ff94:	2012      	movne	r0, #18
    ff96:	3c01      	subs	r4, #1
    ff98:	47c0      	blx	r8
    ff9a:	6828      	ldr	r0, [r5, #0]
    ff9c:	4030      	ands	r0, r6
    ff9e:	42b8      	cmp	r0, r7
    ffa0:	d1f1      	bne.n	ff86 <am_hal_flash_delay_status_check+0x42>
    ffa2:	e7ed      	b.n	ff80 <am_hal_flash_delay_status_check+0x3c>
    ffa4:	2004      	movs	r0, #4
    ffa6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ffaa:	bf00      	nop
    ffac:	0800009d 	.word	0x0800009d

0000ffb0 <am_hal_flash_load_ui32>:
    ffb0:	4b00      	ldr	r3, [pc, #0]	; (ffb4 <am_hal_flash_load_ui32+0x4>)
    ffb2:	4718      	bx	r3
    ffb4:	08000075 	.word	0x08000075

0000ffb8 <am_hal_flash_store_ui32>:
    ffb8:	4b01      	ldr	r3, [pc, #4]	; (ffc0 <am_hal_flash_store_ui32+0x8>)
    ffba:	f043 0301 	orr.w	r3, r3, #1
    ffbe:	4718      	bx	r3
    ffc0:	10001034 	.word	0x10001034

0000ffc4 <am_hal_gpio_pinconfig>:
    ffc4:	2831      	cmp	r0, #49	; 0x31
    ffc6:	f200 80c3 	bhi.w	10150 <am_hal_gpio_pinconfig+0x18c>
    ffca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ffce:	4604      	mov	r4, r0
    ffd0:	f011 07e0 	ands.w	r7, r1, #224	; 0xe0
    ffd4:	f001 0007 	and.w	r0, r1, #7
    ffd8:	b085      	sub	sp, #20
    ffda:	f3c1 03c1 	ubfx	r3, r1, #3, #2
    ffde:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    ffe2:	d00f      	beq.n	10004 <am_hal_gpio_pinconfig+0x40>
    ffe4:	f3c1 1642 	ubfx	r6, r1, #5, #3
    ffe8:	1db5      	adds	r5, r6, #6
    ffea:	f005 0507 	and.w	r5, r5, #7
    ffee:	2d03      	cmp	r5, #3
    fff0:	f042 0201 	orr.w	r2, r2, #1
    fff4:	f240 80ae 	bls.w	10154 <am_hal_gpio_pinconfig+0x190>
    fff8:	2fc0      	cmp	r7, #192	; 0xc0
    fffa:	f000 80e1 	beq.w	101c0 <am_hal_gpio_pinconfig+0x1fc>
    fffe:	2f20      	cmp	r7, #32
   10000:	f000 80e3 	beq.w	101ca <am_hal_gpio_pinconfig+0x206>
   10004:	b163      	cbz	r3, 10020 <am_hal_gpio_pinconfig+0x5c>
   10006:	2b01      	cmp	r3, #1
   10008:	f000 80d3 	beq.w	101b2 <am_hal_gpio_pinconfig+0x1ee>
   1000c:	2b02      	cmp	r3, #2
   1000e:	f040 80c9 	bne.w	101a4 <am_hal_gpio_pinconfig+0x1e0>
   10012:	4b79      	ldr	r3, [pc, #484]	; (101f8 <am_hal_gpio_pinconfig+0x234>)
   10014:	5d1b      	ldrb	r3, [r3, r4]
   10016:	075b      	lsls	r3, r3, #29
   10018:	f140 80c4 	bpl.w	101a4 <am_hal_gpio_pinconfig+0x1e0>
   1001c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   10020:	4b76      	ldr	r3, [pc, #472]	; (101fc <am_hal_gpio_pinconfig+0x238>)
   10022:	5d1b      	ldrb	r3, [r3, r4]
   10024:	4103      	asrs	r3, r0
   10026:	005b      	lsls	r3, r3, #1
   10028:	f003 0302 	and.w	r3, r3, #2
   1002c:	4313      	orrs	r3, r2
   1002e:	4a74      	ldr	r2, [pc, #464]	; (10200 <am_hal_gpio_pinconfig+0x23c>)
   10030:	5d12      	ldrb	r2, [r2, r4]
   10032:	4282      	cmp	r2, r0
   10034:	f000 8099 	beq.w	1016a <am_hal_gpio_pinconfig+0x1a6>
   10038:	f3c1 3000 	ubfx	r0, r1, #12, #1
   1003c:	f3c1 2581 	ubfx	r5, r1, #10, #2
   10040:	f3c1 3280 	ubfx	r2, r1, #14, #1
   10044:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
   10048:	0a88      	lsrs	r0, r1, #10
   1004a:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
   1004e:	f000 0008 	and.w	r0, r0, #8
   10052:	4302      	orrs	r2, r0
   10054:	f3c1 2007 	ubfx	r0, r1, #8, #8
   10058:	f000 050c 	and.w	r5, r0, #12
   1005c:	2d04      	cmp	r5, #4
   1005e:	f000 80a5 	beq.w	101ac <am_hal_gpio_pinconfig+0x1e8>
   10062:	4d68      	ldr	r5, [pc, #416]	; (10204 <am_hal_gpio_pinconfig+0x240>)
   10064:	682d      	ldr	r5, [r5, #0]
   10066:	eba1 0805 	sub.w	r8, r1, r5
   1006a:	fab8 f888 	clz	r8, r8
   1006e:	ea4f 1858 	mov.w	r8, r8, lsr #5
   10072:	f010 0f60 	tst.w	r0, #96	; 0x60
   10076:	bf04      	itt	eq
   10078:	f3c1 30c0 	ubfxeq	r0, r1, #15, #1
   1007c:	f360 0200 	bfieq	r2, r0, #0, #1
   10080:	00a0      	lsls	r0, r4, #2
   10082:	f3c1 2101 	ubfx	r1, r1, #8, #2
   10086:	2902      	cmp	r1, #2
   10088:	d05c      	beq.n	10144 <am_hal_gpio_pinconfig+0x180>
   1008a:	2903      	cmp	r1, #3
   1008c:	d058      	beq.n	10140 <am_hal_gpio_pinconfig+0x17c>
   1008e:	2901      	cmp	r1, #1
   10090:	ea4f 01c4 	mov.w	r1, r4, lsl #3
   10094:	bf08      	it	eq
   10096:	f043 0304 	orreq.w	r3, r3, #4
   1009a:	f001 0118 	and.w	r1, r1, #24
   1009e:	2700      	movs	r7, #0
   100a0:	f000 001c 	and.w	r0, r0, #28
   100a4:	fa02 f600 	lsl.w	r6, r2, r0
   100a8:	220f      	movs	r2, #15
   100aa:	4082      	lsls	r2, r0
   100ac:	43d2      	mvns	r2, r2
   100ae:	f04f 09ff 	mov.w	r9, #255	; 0xff
   100b2:	fa03 f501 	lsl.w	r5, r3, r1
   100b6:	fa09 f901 	lsl.w	r9, r9, r1
   100ba:	9201      	str	r2, [sp, #4]
   100bc:	f000 f8fc 	bl	102b8 <am_hal_interrupt_master_disable>
   100c0:	f024 0a03 	bic.w	sl, r4, #3
   100c4:	ea4f 0b54 	mov.w	fp, r4, lsr #1
   100c8:	f10a 4c80 	add.w	ip, sl, #1073741824	; 0x40000000
   100cc:	4b4e      	ldr	r3, [pc, #312]	; (10208 <am_hal_gpio_pinconfig+0x244>)
   100ce:	494f      	ldr	r1, [pc, #316]	; (1020c <am_hal_gpio_pinconfig+0x248>)
   100d0:	9a01      	ldr	r2, [sp, #4]
   100d2:	9003      	str	r0, [sp, #12]
   100d4:	ea6f 0909 	mvn.w	r9, r9
   100d8:	f02b 0b03 	bic.w	fp, fp, #3
   100dc:	f50c 3c80 	add.w	ip, ip, #65536	; 0x10000
   100e0:	f1b8 0f00 	cmp.w	r8, #0
   100e4:	d00b      	beq.n	100fe <am_hal_gpio_pinconfig+0x13a>
   100e6:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
   100ea:	f004 081f 	and.w	r8, r4, #31
   100ee:	4848      	ldr	r0, [pc, #288]	; (10210 <am_hal_gpio_pinconfig+0x24c>)
   100f0:	f00e 0e04 	and.w	lr, lr, #4
   100f4:	2401      	movs	r4, #1
   100f6:	fa04 f408 	lsl.w	r4, r4, r8
   100fa:	f84e 4000 	str.w	r4, [lr, r0]
   100fe:	4845      	ldr	r0, [pc, #276]	; (10214 <am_hal_gpio_pinconfig+0x250>)
   10100:	2473      	movs	r4, #115	; 0x73
   10102:	6604      	str	r4, [r0, #96]	; 0x60
   10104:	f8dc 4000 	ldr.w	r4, [ip]
   10108:	ea04 0409 	and.w	r4, r4, r9
   1010c:	4325      	orrs	r5, r4
   1010e:	f8cc 5000 	str.w	r5, [ip]
   10112:	f85b 4003 	ldr.w	r4, [fp, r3]
   10116:	4022      	ands	r2, r4
   10118:	4332      	orrs	r2, r6
   1011a:	f84b 2003 	str.w	r2, [fp, r3]
   1011e:	f85a 3001 	ldr.w	r3, [sl, r1]
   10122:	ea03 0909 	and.w	r9, r3, r9
   10126:	2400      	movs	r4, #0
   10128:	ea49 0707 	orr.w	r7, r9, r7
   1012c:	f84a 7001 	str.w	r7, [sl, r1]
   10130:	6604      	str	r4, [r0, #96]	; 0x60
   10132:	9803      	ldr	r0, [sp, #12]
   10134:	f000 f8c4 	bl	102c0 <am_hal_interrupt_master_set>
   10138:	4620      	mov	r0, r4
   1013a:	b005      	add	sp, #20
   1013c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10140:	f043 0304 	orr.w	r3, r3, #4
   10144:	00e1      	lsls	r1, r4, #3
   10146:	f001 0118 	and.w	r1, r1, #24
   1014a:	2701      	movs	r7, #1
   1014c:	408f      	lsls	r7, r1
   1014e:	e7a7      	b.n	100a0 <am_hal_gpio_pinconfig+0xdc>
   10150:	2006      	movs	r0, #6
   10152:	4770      	bx	lr
   10154:	4d28      	ldr	r5, [pc, #160]	; (101f8 <am_hal_gpio_pinconfig+0x234>)
   10156:	5d2d      	ldrb	r5, [r5, r4]
   10158:	3e02      	subs	r6, #2
   1015a:	ea42 1286 	orr.w	r2, r2, r6, lsl #6
   1015e:	07ee      	lsls	r6, r5, #31
   10160:	d536      	bpl.n	101d0 <am_hal_gpio_pinconfig+0x20c>
   10162:	2b00      	cmp	r3, #0
   10164:	f43f af5c 	beq.w	10020 <am_hal_gpio_pinconfig+0x5c>
   10168:	e74d      	b.n	10006 <am_hal_gpio_pinconfig+0x42>
   1016a:	f3c1 4202 	ubfx	r2, r1, #16, #3
   1016e:	2a07      	cmp	r2, #7
   10170:	d030      	beq.n	101d4 <am_hal_gpio_pinconfig+0x210>
   10172:	4d29      	ldr	r5, [pc, #164]	; (10218 <am_hal_gpio_pinconfig+0x254>)
   10174:	f3c1 40c1 	ubfx	r0, r1, #19, #2
   10178:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
   1017c:	f815 0024 	ldrb.w	r0, [r5, r4, lsl #2]
   10180:	4290      	cmp	r0, r2
   10182:	d029      	beq.n	101d8 <am_hal_gpio_pinconfig+0x214>
   10184:	eb05 0584 	add.w	r5, r5, r4, lsl #2
   10188:	00a0      	lsls	r0, r4, #2
   1018a:	786e      	ldrb	r6, [r5, #1]
   1018c:	4296      	cmp	r6, r2
   1018e:	d02d      	beq.n	101ec <am_hal_gpio_pinconfig+0x228>
   10190:	78ae      	ldrb	r6, [r5, #2]
   10192:	4296      	cmp	r6, r2
   10194:	d02c      	beq.n	101f0 <am_hal_gpio_pinconfig+0x22c>
   10196:	78ed      	ldrb	r5, [r5, #3]
   10198:	4295      	cmp	r5, r2
   1019a:	d02b      	beq.n	101f4 <am_hal_gpio_pinconfig+0x230>
   1019c:	481f      	ldr	r0, [pc, #124]	; (1021c <am_hal_gpio_pinconfig+0x258>)
   1019e:	b005      	add	sp, #20
   101a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   101a4:	481e      	ldr	r0, [pc, #120]	; (10220 <am_hal_gpio_pinconfig+0x25c>)
   101a6:	b005      	add	sp, #20
   101a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   101ac:	f04f 0801 	mov.w	r8, #1
   101b0:	e75f      	b.n	10072 <am_hal_gpio_pinconfig+0xae>
   101b2:	4b11      	ldr	r3, [pc, #68]	; (101f8 <am_hal_gpio_pinconfig+0x234>)
   101b4:	5d1b      	ldrb	r3, [r3, r4]
   101b6:	079d      	lsls	r5, r3, #30
   101b8:	d5f4      	bpl.n	101a4 <am_hal_gpio_pinconfig+0x1e0>
   101ba:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   101be:	e72f      	b.n	10020 <am_hal_gpio_pinconfig+0x5c>
   101c0:	2c14      	cmp	r4, #20
   101c2:	f43f af1f 	beq.w	10004 <am_hal_gpio_pinconfig+0x40>
   101c6:	4817      	ldr	r0, [pc, #92]	; (10224 <am_hal_gpio_pinconfig+0x260>)
   101c8:	e7b7      	b.n	1013a <am_hal_gpio_pinconfig+0x176>
   101ca:	2c14      	cmp	r4, #20
   101cc:	f47f af1a 	bne.w	10004 <am_hal_gpio_pinconfig+0x40>
   101d0:	4815      	ldr	r0, [pc, #84]	; (10228 <am_hal_gpio_pinconfig+0x264>)
   101d2:	e7b2      	b.n	1013a <am_hal_gpio_pinconfig+0x176>
   101d4:	4815      	ldr	r0, [pc, #84]	; (1022c <am_hal_gpio_pinconfig+0x268>)
   101d6:	e7b0      	b.n	1013a <am_hal_gpio_pinconfig+0x176>
   101d8:	2200      	movs	r2, #0
   101da:	00a0      	lsls	r0, r4, #2
   101dc:	0052      	lsls	r2, r2, #1
   101de:	f3c1 5540 	ubfx	r5, r1, #21, #1
   101e2:	ea42 02c5 	orr.w	r2, r2, r5, lsl #3
   101e6:	f04f 0800 	mov.w	r8, #0
   101ea:	e74a      	b.n	10082 <am_hal_gpio_pinconfig+0xbe>
   101ec:	2201      	movs	r2, #1
   101ee:	e7f5      	b.n	101dc <am_hal_gpio_pinconfig+0x218>
   101f0:	2202      	movs	r2, #2
   101f2:	e7f3      	b.n	101dc <am_hal_gpio_pinconfig+0x218>
   101f4:	2203      	movs	r2, #3
   101f6:	e7f1      	b.n	101dc <am_hal_gpio_pinconfig+0x218>
   101f8:	000116d8 	.word	0x000116d8
   101fc:	0001170c 	.word	0x0001170c
   10200:	00011808 	.word	0x00011808
   10204:	000116cc 	.word	0x000116cc
   10208:	40010040 	.word	0x40010040
   1020c:	400100e0 	.word	0x400100e0
   10210:	400100b4 	.word	0x400100b4
   10214:	40010000 	.word	0x40010000
   10218:	00011740 	.word	0x00011740
   1021c:	08000104 	.word	0x08000104
   10220:	08000102 	.word	0x08000102
   10224:	08000101 	.word	0x08000101
   10228:	08000100 	.word	0x08000100
   1022c:	08000103 	.word	0x08000103

00010230 <am_hal_gpio_state_write>:
   10230:	2831      	cmp	r0, #49	; 0x31
   10232:	d81a      	bhi.n	1026a <am_hal_gpio_state_write+0x3a>
   10234:	b570      	push	{r4, r5, r6, lr}
   10236:	2905      	cmp	r1, #5
   10238:	b082      	sub	sp, #8
   1023a:	460d      	mov	r5, r1
   1023c:	d812      	bhi.n	10264 <am_hal_gpio_state_write+0x34>
   1023e:	f000 031f 	and.w	r3, r0, #31
   10242:	2201      	movs	r2, #1
   10244:	08c0      	lsrs	r0, r0, #3
   10246:	fa02 f603 	lsl.w	r6, r2, r3
   1024a:	f000 0404 	and.w	r4, r0, #4
   1024e:	f000 f833 	bl	102b8 <am_hal_interrupt_master_disable>
   10252:	3d01      	subs	r5, #1
   10254:	9001      	str	r0, [sp, #4]
   10256:	2d04      	cmp	r5, #4
   10258:	d821      	bhi.n	1029e <am_hal_gpio_state_write+0x6e>
   1025a:	e8df f005 	tbb	[pc, r5]
   1025e:	1512      	.short	0x1512
   10260:	1d1a      	.short	0x1d1a
   10262:	08          	.byte	0x08
   10263:	00          	.byte	0x00
   10264:	2006      	movs	r0, #6
   10266:	b002      	add	sp, #8
   10268:	bd70      	pop	{r4, r5, r6, pc}
   1026a:	2005      	movs	r0, #5
   1026c:	4770      	bx	lr
   1026e:	4a0d      	ldr	r2, [pc, #52]	; (102a4 <am_hal_gpio_state_write+0x74>)
   10270:	58a3      	ldr	r3, [r4, r2]
   10272:	4073      	eors	r3, r6
   10274:	50a3      	str	r3, [r4, r2]
   10276:	9801      	ldr	r0, [sp, #4]
   10278:	f000 f822 	bl	102c0 <am_hal_interrupt_master_set>
   1027c:	2000      	movs	r0, #0
   1027e:	b002      	add	sp, #8
   10280:	bd70      	pop	{r4, r5, r6, pc}
   10282:	4b09      	ldr	r3, [pc, #36]	; (102a8 <am_hal_gpio_state_write+0x78>)
   10284:	50e6      	str	r6, [r4, r3]
   10286:	e7f6      	b.n	10276 <am_hal_gpio_state_write+0x46>
   10288:	4a08      	ldr	r2, [pc, #32]	; (102ac <am_hal_gpio_state_write+0x7c>)
   1028a:	58a3      	ldr	r3, [r4, r2]
   1028c:	4073      	eors	r3, r6
   1028e:	50a3      	str	r3, [r4, r2]
   10290:	e7f1      	b.n	10276 <am_hal_gpio_state_write+0x46>
   10292:	4b04      	ldr	r3, [pc, #16]	; (102a4 <am_hal_gpio_state_write+0x74>)
   10294:	50e6      	str	r6, [r4, r3]
   10296:	e7ee      	b.n	10276 <am_hal_gpio_state_write+0x46>
   10298:	4b05      	ldr	r3, [pc, #20]	; (102b0 <am_hal_gpio_state_write+0x80>)
   1029a:	50e6      	str	r6, [r4, r3]
   1029c:	e7eb      	b.n	10276 <am_hal_gpio_state_write+0x46>
   1029e:	4b05      	ldr	r3, [pc, #20]	; (102b4 <am_hal_gpio_state_write+0x84>)
   102a0:	50e6      	str	r6, [r4, r3]
   102a2:	e7e8      	b.n	10276 <am_hal_gpio_state_write+0x46>
   102a4:	400100b4 	.word	0x400100b4
   102a8:	40010090 	.word	0x40010090
   102ac:	40010088 	.word	0x40010088
   102b0:	400100a8 	.word	0x400100a8
   102b4:	40010098 	.word	0x40010098

000102b8 <am_hal_interrupt_master_disable>:
   102b8:	f3ef 8010 	mrs	r0, PRIMASK
   102bc:	b672      	cpsid	i
   102be:	4770      	bx	lr

000102c0 <am_hal_interrupt_master_set>:
   102c0:	f380 8810 	msr	PRIMASK, r0
   102c4:	4770      	bx	lr
   102c6:	bf00      	nop

000102c8 <am_hal_mcuctrl_info_get>:
   102c8:	2900      	cmp	r1, #0
   102ca:	f000 808f 	beq.w	103ec <am_hal_mcuctrl_info_get+0x124>
   102ce:	2801      	cmp	r0, #1
   102d0:	b430      	push	{r4, r5}
   102d2:	d006      	beq.n	102e2 <am_hal_mcuctrl_info_get+0x1a>
   102d4:	2802      	cmp	r0, #2
   102d6:	d06d      	beq.n	103b4 <am_hal_mcuctrl_info_get+0xec>
   102d8:	2800      	cmp	r0, #0
   102da:	d055      	beq.n	10388 <am_hal_mcuctrl_info_get+0xc0>
   102dc:	2006      	movs	r0, #6
   102de:	bc30      	pop	{r4, r5}
   102e0:	4770      	bx	lr
   102e2:	4a43      	ldr	r2, [pc, #268]	; (103f0 <am_hal_mcuctrl_info_get+0x128>)
   102e4:	4843      	ldr	r0, [pc, #268]	; (103f4 <am_hal_mcuctrl_info_get+0x12c>)
   102e6:	6813      	ldr	r3, [r2, #0]
   102e8:	600b      	str	r3, [r1, #0]
   102ea:	6854      	ldr	r4, [r2, #4]
   102ec:	604c      	str	r4, [r1, #4]
   102ee:	6894      	ldr	r4, [r2, #8]
   102f0:	608c      	str	r4, [r1, #8]
   102f2:	68d4      	ldr	r4, [r2, #12]
   102f4:	60cc      	str	r4, [r1, #12]
   102f6:	f3c3 5503 	ubfx	r5, r3, #20, #4
   102fa:	6914      	ldr	r4, [r2, #16]
   102fc:	610c      	str	r4, [r1, #16]
   102fe:	f850 5025 	ldr.w	r5, [r0, r5, lsl #2]
   10302:	4c3d      	ldr	r4, [pc, #244]	; (103f8 <am_hal_mcuctrl_info_get+0x130>)
   10304:	6950      	ldr	r0, [r2, #20]
   10306:	6148      	str	r0, [r1, #20]
   10308:	f003 0201 	and.w	r2, r3, #1
   1030c:	f3c3 4303 	ubfx	r3, r3, #16, #4
   10310:	e9c1 2506 	strd	r2, r5, [r1, #24]
   10314:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
   10318:	4a38      	ldr	r2, [pc, #224]	; (103fc <am_hal_mcuctrl_info_get+0x134>)
   1031a:	620b      	str	r3, [r1, #32]
   1031c:	f8d2 30e0 	ldr.w	r3, [r2, #224]	; 0xe0
   10320:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
   10324:	b2db      	uxtb	r3, r3
   10326:	f000 000f 	and.w	r0, r0, #15
   1032a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   1032e:	624b      	str	r3, [r1, #36]	; 0x24
   10330:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
   10334:	f8d2 00e8 	ldr.w	r0, [r2, #232]	; 0xe8
   10338:	f3c3 1303 	ubfx	r3, r3, #4, #4
   1033c:	f000 000f 	and.w	r0, r0, #15
   10340:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
   10344:	628b      	str	r3, [r1, #40]	; 0x28
   10346:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
   1034a:	f8d2 00ec 	ldr.w	r0, [r2, #236]	; 0xec
   1034e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   10352:	f3c0 1003 	ubfx	r0, r0, #4, #4
   10356:	4303      	orrs	r3, r0
   10358:	62cb      	str	r3, [r1, #44]	; 0x2c
   1035a:	f8d2 40fc 	ldr.w	r4, [r2, #252]	; 0xfc
   1035e:	f8d2 30f8 	ldr.w	r3, [r2, #248]	; 0xf8
   10362:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
   10366:	f8d2 20f0 	ldr.w	r2, [r2, #240]	; 0xf0
   1036a:	b2db      	uxtb	r3, r3
   1036c:	041b      	lsls	r3, r3, #16
   1036e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
   10372:	fa5f fc82 	uxtb.w	ip, r2
   10376:	ea43 030c 	orr.w	r3, r3, ip
   1037a:	b2c2      	uxtb	r2, r0
   1037c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   10380:	630b      	str	r3, [r1, #48]	; 0x30
   10382:	2000      	movs	r0, #0
   10384:	bc30      	pop	{r4, r5}
   10386:	4770      	bx	lr
   10388:	4a19      	ldr	r2, [pc, #100]	; (103f0 <am_hal_mcuctrl_info_get+0x128>)
   1038a:	6993      	ldr	r3, [r2, #24]
   1038c:	f3c3 1480 	ubfx	r4, r3, #6, #1
   10390:	700c      	strb	r4, [r1, #0]
   10392:	f8d2 41a0 	ldr.w	r4, [r2, #416]	; 0x1a0
   10396:	f3c3 0380 	ubfx	r3, r3, #2, #1
   1039a:	704b      	strb	r3, [r1, #1]
   1039c:	f3c4 6381 	ubfx	r3, r4, #26, #2
   103a0:	710b      	strb	r3, [r1, #4]
   103a2:	6953      	ldr	r3, [r2, #20]
   103a4:	f3c3 0240 	ubfx	r2, r3, #1, #1
   103a8:	f003 0301 	and.w	r3, r3, #1
   103ac:	bc30      	pop	{r4, r5}
   103ae:	708a      	strb	r2, [r1, #2]
   103b0:	70cb      	strb	r3, [r1, #3]
   103b2:	4770      	bx	lr
   103b4:	4a0e      	ldr	r2, [pc, #56]	; (103f0 <am_hal_mcuctrl_info_get+0x128>)
   103b6:	6848      	ldr	r0, [r1, #4]
   103b8:	f8d2 31cc 	ldr.w	r3, [r2, #460]	; 0x1cc
   103bc:	f003 0401 	and.w	r4, r3, #1
   103c0:	700c      	strb	r4, [r1, #0]
   103c2:	f3c3 0440 	ubfx	r4, r3, #1, #1
   103c6:	720c      	strb	r4, [r1, #8]
   103c8:	f8d2 41c4 	ldr.w	r4, [r2, #452]	; 0x1c4
   103cc:	60cc      	str	r4, [r1, #12]
   103ce:	f8d2 41c0 	ldr.w	r4, [r2, #448]	; 0x1c0
   103d2:	4320      	orrs	r0, r4
   103d4:	f3c3 0380 	ubfx	r3, r3, #2, #1
   103d8:	6048      	str	r0, [r1, #4]
   103da:	f8d2 21c8 	ldr.w	r2, [r2, #456]	; 0x1c8
   103de:	740b      	strb	r3, [r1, #16]
   103e0:	694b      	ldr	r3, [r1, #20]
   103e2:	4313      	orrs	r3, r2
   103e4:	2000      	movs	r0, #0
   103e6:	bc30      	pop	{r4, r5}
   103e8:	614b      	str	r3, [r1, #20]
   103ea:	4770      	bx	lr
   103ec:	2006      	movs	r0, #6
   103ee:	4770      	bx	lr
   103f0:	40020000 	.word	0x40020000
   103f4:	0001183c 	.word	0x0001183c
   103f8:	0001187c 	.word	0x0001187c
   103fc:	f0000f00 	.word	0xf0000f00

00010400 <am_hal_pwrctrl_periph_enable>:
   10400:	b570      	push	{r4, r5, r6, lr}
   10402:	b082      	sub	sp, #8
   10404:	4604      	mov	r4, r0
   10406:	f7ff ff57 	bl	102b8 <am_hal_interrupt_master_disable>
   1040a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1040e:	4e0f      	ldr	r6, [pc, #60]	; (1044c <am_hal_pwrctrl_periph_enable+0x4c>)
   10410:	4d0f      	ldr	r5, [pc, #60]	; (10450 <am_hal_pwrctrl_periph_enable+0x50>)
   10412:	9001      	str	r0, [sp, #4]
   10414:	00a4      	lsls	r4, r4, #2
   10416:	68b3      	ldr	r3, [r6, #8]
   10418:	592a      	ldr	r2, [r5, r4]
   1041a:	4313      	orrs	r3, r2
   1041c:	60b3      	str	r3, [r6, #8]
   1041e:	9801      	ldr	r0, [sp, #4]
   10420:	442c      	add	r4, r5
   10422:	f7ff ff4d 	bl	102c0 <am_hal_interrupt_master_set>
   10426:	20a0      	movs	r0, #160	; 0xa0
   10428:	f7ff fd7c 	bl	ff24 <am_hal_flash_delay>
   1042c:	69b3      	ldr	r3, [r6, #24]
   1042e:	6864      	ldr	r4, [r4, #4]
   10430:	4223      	tst	r3, r4
   10432:	d103      	bne.n	1043c <am_hal_pwrctrl_periph_enable+0x3c>
   10434:	20a0      	movs	r0, #160	; 0xa0
   10436:	f7ff fd75 	bl	ff24 <am_hal_flash_delay>
   1043a:	69b3      	ldr	r3, [r6, #24]
   1043c:	4b03      	ldr	r3, [pc, #12]	; (1044c <am_hal_pwrctrl_periph_enable+0x4c>)
   1043e:	699b      	ldr	r3, [r3, #24]
   10440:	4223      	tst	r3, r4
   10442:	bf0c      	ite	eq
   10444:	2001      	moveq	r0, #1
   10446:	2000      	movne	r0, #0
   10448:	b002      	add	sp, #8
   1044a:	bd70      	pop	{r4, r5, r6, pc}
   1044c:	40021000 	.word	0x40021000
   10450:	00011a6c 	.word	0x00011a6c

00010454 <am_hal_pwrctrl_periph_disable>:
   10454:	b570      	push	{r4, r5, r6, lr}
   10456:	b082      	sub	sp, #8
   10458:	4604      	mov	r4, r0
   1045a:	f7ff ff2d 	bl	102b8 <am_hal_interrupt_master_disable>
   1045e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   10462:	4e10      	ldr	r6, [pc, #64]	; (104a4 <am_hal_pwrctrl_periph_disable+0x50>)
   10464:	4d10      	ldr	r5, [pc, #64]	; (104a8 <am_hal_pwrctrl_periph_disable+0x54>)
   10466:	9001      	str	r0, [sp, #4]
   10468:	00a4      	lsls	r4, r4, #2
   1046a:	68b3      	ldr	r3, [r6, #8]
   1046c:	592a      	ldr	r2, [r5, r4]
   1046e:	ea23 0302 	bic.w	r3, r3, r2
   10472:	60b3      	str	r3, [r6, #8]
   10474:	9801      	ldr	r0, [sp, #4]
   10476:	442c      	add	r4, r5
   10478:	f7ff ff22 	bl	102c0 <am_hal_interrupt_master_set>
   1047c:	20a0      	movs	r0, #160	; 0xa0
   1047e:	f7ff fd51 	bl	ff24 <am_hal_flash_delay>
   10482:	69b3      	ldr	r3, [r6, #24]
   10484:	6864      	ldr	r4, [r4, #4]
   10486:	4223      	tst	r3, r4
   10488:	d003      	beq.n	10492 <am_hal_pwrctrl_periph_disable+0x3e>
   1048a:	20a0      	movs	r0, #160	; 0xa0
   1048c:	f7ff fd4a 	bl	ff24 <am_hal_flash_delay>
   10490:	69b3      	ldr	r3, [r6, #24]
   10492:	4b04      	ldr	r3, [pc, #16]	; (104a4 <am_hal_pwrctrl_periph_disable+0x50>)
   10494:	699b      	ldr	r3, [r3, #24]
   10496:	4223      	tst	r3, r4
   10498:	bf14      	ite	ne
   1049a:	2001      	movne	r0, #1
   1049c:	2000      	moveq	r0, #0
   1049e:	b002      	add	sp, #8
   104a0:	bd70      	pop	{r4, r5, r6, pc}
   104a2:	bf00      	nop
   104a4:	40021000 	.word	0x40021000
   104a8:	00011a6c 	.word	0x00011a6c

000104ac <am_hal_pwrctrl_memory_enable>:
   104ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   104b0:	4d22      	ldr	r5, [pc, #136]	; (1053c <am_hal_pwrctrl_memory_enable+0x90>)
   104b2:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   104b6:	eb05 09c3 	add.w	r9, r5, r3, lsl #3
   104ba:	f855 8033 	ldr.w	r8, [r5, r3, lsl #3]
   104be:	f8d9 6010 	ldr.w	r6, [r9, #16]
   104c2:	f1b8 3fff 	cmp.w	r8, #4294967295
   104c6:	4604      	mov	r4, r0
   104c8:	ea4f 0740 	mov.w	r7, r0, lsl #1
   104cc:	d120      	bne.n	10510 <am_hal_pwrctrl_memory_enable+0x64>
   104ce:	f8df 9070 	ldr.w	r9, [pc, #112]	; 10540 <am_hal_pwrctrl_memory_enable+0x94>
   104d2:	f8d9 3010 	ldr.w	r3, [r9, #16]
   104d6:	443c      	add	r4, r7
   104d8:	ea43 0308 	orr.w	r3, r3, r8
   104dc:	f8c9 3010 	str.w	r3, [r9, #16]
   104e0:	20a0      	movs	r0, #160	; 0xa0
   104e2:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
   104e6:	f7ff fd1d 	bl	ff24 <am_hal_flash_delay>
   104ea:	f8d9 3014 	ldr.w	r3, [r9, #20]
   104ee:	686c      	ldr	r4, [r5, #4]
   104f0:	4033      	ands	r3, r6
   104f2:	42a3      	cmp	r3, r4
   104f4:	d004      	beq.n	10500 <am_hal_pwrctrl_memory_enable+0x54>
   104f6:	20a0      	movs	r0, #160	; 0xa0
   104f8:	f7ff fd14 	bl	ff24 <am_hal_flash_delay>
   104fc:	f8d9 3014 	ldr.w	r3, [r9, #20]
   10500:	4b0f      	ldr	r3, [pc, #60]	; (10540 <am_hal_pwrctrl_memory_enable+0x94>)
   10502:	6958      	ldr	r0, [r3, #20]
   10504:	4030      	ands	r0, r6
   10506:	1b00      	subs	r0, r0, r4
   10508:	bf18      	it	ne
   1050a:	2001      	movne	r0, #1
   1050c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10510:	f8d9 300c 	ldr.w	r3, [r9, #12]
   10514:	4a0a      	ldr	r2, [pc, #40]	; (10540 <am_hal_pwrctrl_memory_enable+0x94>)
   10516:	ea68 0303 	orn	r3, r8, r3
   1051a:	6911      	ldr	r1, [r2, #16]
   1051c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10520:	f043 0301 	orr.w	r3, r3, #1
   10524:	400b      	ands	r3, r1
   10526:	2010      	movs	r0, #16
   10528:	6113      	str	r3, [r2, #16]
   1052a:	f7ff fcfb 	bl	ff24 <am_hal_flash_delay>
   1052e:	f1b8 0f00 	cmp.w	r8, #0
   10532:	d1cc      	bne.n	104ce <am_hal_pwrctrl_memory_enable+0x22>
   10534:	f8d9 4004 	ldr.w	r4, [r9, #4]
   10538:	e7e2      	b.n	10500 <am_hal_pwrctrl_memory_enable+0x54>
   1053a:	bf00      	nop
   1053c:	000118bc 	.word	0x000118bc
   10540:	40021000 	.word	0x40021000

00010544 <am_hal_pwrctrl_low_power_init>:
   10544:	b530      	push	{r4, r5, lr}
   10546:	4b69      	ldr	r3, [pc, #420]	; (106ec <am_hal_pwrctrl_low_power_init+0x1a8>)
   10548:	681a      	ldr	r2, [r3, #0]
   1054a:	b085      	sub	sp, #20
   1054c:	b912      	cbnz	r2, 10554 <am_hal_pwrctrl_low_power_init+0x10>
   1054e:	4a68      	ldr	r2, [pc, #416]	; (106f0 <am_hal_pwrctrl_low_power_init+0x1ac>)
   10550:	6812      	ldr	r2, [r2, #0]
   10552:	601a      	str	r2, [r3, #0]
   10554:	4b67      	ldr	r3, [pc, #412]	; (106f4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   10556:	68db      	ldr	r3, [r3, #12]
   10558:	b2db      	uxtb	r3, r3
   1055a:	2b12      	cmp	r3, #18
   1055c:	d104      	bne.n	10568 <am_hal_pwrctrl_low_power_init+0x24>
   1055e:	4c66      	ldr	r4, [pc, #408]	; (106f8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   10560:	6863      	ldr	r3, [r4, #4]
   10562:	07d8      	lsls	r0, r3, #31
   10564:	f100 8088 	bmi.w	10678 <am_hal_pwrctrl_low_power_init+0x134>
   10568:	4b62      	ldr	r3, [pc, #392]	; (106f4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   1056a:	68da      	ldr	r2, [r3, #12]
   1056c:	b2d2      	uxtb	r2, r2
   1056e:	2a20      	cmp	r2, #32
   10570:	d934      	bls.n	105dc <am_hal_pwrctrl_low_power_init+0x98>
   10572:	f8d3 2354 	ldr.w	r2, [r3, #852]	; 0x354
   10576:	2002      	movs	r0, #2
   10578:	f360 4213 	bfi	r2, r0, #16, #4
   1057c:	f8c3 2354 	str.w	r2, [r3, #852]	; 0x354
   10580:	f8d3 1354 	ldr.w	r1, [r3, #852]	; 0x354
   10584:	2203      	movs	r2, #3
   10586:	f362 5117 	bfi	r1, r2, #20, #4
   1058a:	f8c3 1354 	str.w	r1, [r3, #852]	; 0x354
   1058e:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   10592:	2405      	movs	r4, #5
   10594:	f364 0103 	bfi	r1, r4, #0, #4
   10598:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   1059c:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   105a0:	f360 1107 	bfi	r1, r0, #4, #4
   105a4:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   105a8:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   105ac:	2406      	movs	r4, #6
   105ae:	f364 210b 	bfi	r1, r4, #8, #4
   105b2:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   105b6:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   105ba:	2001      	movs	r0, #1
   105bc:	f360 310f 	bfi	r1, r0, #12, #4
   105c0:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   105c4:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   105c8:	f362 61de 	bfi	r1, r2, #27, #4
   105cc:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   105d0:	f8d3 135c 	ldr.w	r1, [r3, #860]	; 0x35c
   105d4:	f362 0103 	bfi	r1, r2, #0, #4
   105d8:	f8c3 135c 	str.w	r1, [r3, #860]	; 0x35c
   105dc:	4a45      	ldr	r2, [pc, #276]	; (106f4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   105de:	68d3      	ldr	r3, [r2, #12]
   105e0:	b2db      	uxtb	r3, r3
   105e2:	2b11      	cmp	r3, #17
   105e4:	d905      	bls.n	105f2 <am_hal_pwrctrl_low_power_init+0xae>
   105e6:	f8d2 335c 	ldr.w	r3, [r2, #860]	; 0x35c
   105ea:	f36f 6318 	bfc	r3, #24, #1
   105ee:	f8c2 335c 	str.w	r3, [r2, #860]	; 0x35c
   105f2:	2100      	movs	r1, #0
   105f4:	200c      	movs	r0, #12
   105f6:	f7ff fa61 	bl	fabc <am_hal_cachectrl_control>
   105fa:	4b3f      	ldr	r3, [pc, #252]	; (106f8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   105fc:	699b      	ldr	r3, [r3, #24]
   105fe:	f3c3 2500 	ubfx	r5, r3, #8, #1
   10602:	05db      	lsls	r3, r3, #23
   10604:	d420      	bmi.n	10648 <am_hal_pwrctrl_low_power_init+0x104>
   10606:	4c3b      	ldr	r4, [pc, #236]	; (106f4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   10608:	68e3      	ldr	r3, [r4, #12]
   1060a:	b2db      	uxtb	r3, r3
   1060c:	2b11      	cmp	r3, #17
   1060e:	d84e      	bhi.n	106ae <am_hal_pwrctrl_low_power_init+0x16a>
   10610:	4c38      	ldr	r4, [pc, #224]	; (106f4 <am_hal_pwrctrl_low_power_init+0x1b0>)
   10612:	493a      	ldr	r1, [pc, #232]	; (106fc <am_hal_pwrctrl_low_power_init+0x1b8>)
   10614:	7e22      	ldrb	r2, [r4, #24]
   10616:	2001      	movs	r0, #1
   10618:	4302      	orrs	r2, r0
   1061a:	2307      	movs	r3, #7
   1061c:	7622      	strb	r2, [r4, #24]
   1061e:	9000      	str	r0, [sp, #0]
   10620:	461a      	mov	r2, r3
   10622:	f242 7010 	movw	r0, #10000	; 0x2710
   10626:	f7ff fc8d 	bl	ff44 <am_hal_flash_delay_status_check>
   1062a:	2800      	cmp	r0, #0
   1062c:	d15a      	bne.n	106e4 <am_hal_pwrctrl_low_power_init+0x1a0>
   1062e:	4b32      	ldr	r3, [pc, #200]	; (106f8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   10630:	681a      	ldr	r2, [r3, #0]
   10632:	f042 0201 	orr.w	r2, r2, #1
   10636:	601a      	str	r2, [r3, #0]
   10638:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1063a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   1063e:	625a      	str	r2, [r3, #36]	; 0x24
   10640:	68e3      	ldr	r3, [r4, #12]
   10642:	b2db      	uxtb	r3, r3
   10644:	2b11      	cmp	r3, #17
   10646:	d002      	beq.n	1064e <am_hal_pwrctrl_low_power_init+0x10a>
   10648:	2000      	movs	r0, #0
   1064a:	b005      	add	sp, #20
   1064c:	bd30      	pop	{r4, r5, pc}
   1064e:	f8d4 335c 	ldr.w	r3, [r4, #860]	; 0x35c
   10652:	f360 5356 	bfi	r3, r0, #21, #2
   10656:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
   1065a:	f8d4 3368 	ldr.w	r3, [r4, #872]	; 0x368
   1065e:	220f      	movs	r2, #15
   10660:	f362 138b 	bfi	r3, r2, #6, #6
   10664:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
   10668:	f8d4 3368 	ldr.w	r3, [r4, #872]	; 0x368
   1066c:	f362 0305 	bfi	r3, r2, #0, #6
   10670:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
   10674:	b005      	add	sp, #20
   10676:	bd30      	pop	{r4, r5, pc}
   10678:	f7ff fe1e 	bl	102b8 <am_hal_interrupt_master_disable>
   1067c:	9002      	str	r0, [sp, #8]
   1067e:	68a3      	ldr	r3, [r4, #8]
   10680:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   10684:	60a3      	str	r3, [r4, #8]
   10686:	9802      	ldr	r0, [sp, #8]
   10688:	f7ff fe1a 	bl	102c0 <am_hal_interrupt_master_set>
   1068c:	20a0      	movs	r0, #160	; 0xa0
   1068e:	f7ff fc49 	bl	ff24 <am_hal_flash_delay>
   10692:	69a3      	ldr	r3, [r4, #24]
   10694:	0619      	lsls	r1, r3, #24
   10696:	d403      	bmi.n	106a0 <am_hal_pwrctrl_low_power_init+0x15c>
   10698:	20a0      	movs	r0, #160	; 0xa0
   1069a:	f7ff fc43 	bl	ff24 <am_hal_flash_delay>
   1069e:	69a3      	ldr	r3, [r4, #24]
   106a0:	4b15      	ldr	r3, [pc, #84]	; (106f8 <am_hal_pwrctrl_low_power_init+0x1b4>)
   106a2:	699b      	ldr	r3, [r3, #24]
   106a4:	061a      	lsls	r2, r3, #24
   106a6:	f53f af5f 	bmi.w	10568 <am_hal_pwrctrl_low_power_init+0x24>
   106aa:	2001      	movs	r0, #1
   106ac:	e7cd      	b.n	1064a <am_hal_pwrctrl_low_power_init+0x106>
   106ae:	f7ff fe03 	bl	102b8 <am_hal_interrupt_master_disable>
   106b2:	9003      	str	r0, [sp, #12]
   106b4:	f8d4 3368 	ldr.w	r3, [r4, #872]	; 0x368
   106b8:	2219      	movs	r2, #25
   106ba:	f362 138b 	bfi	r3, r2, #6, #6
   106be:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
   106c2:	f8d4 2368 	ldr.w	r2, [r4, #872]	; 0x368
   106c6:	210c      	movs	r1, #12
   106c8:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   106cc:	f361 0205 	bfi	r2, r1, #0, #6
   106d0:	f8c4 2368 	str.w	r2, [r4, #872]	; 0x368
   106d4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   106d6:	f365 5296 	bfi	r2, r5, #22, #1
   106da:	63da      	str	r2, [r3, #60]	; 0x3c
   106dc:	9803      	ldr	r0, [sp, #12]
   106de:	f7ff fdef 	bl	102c0 <am_hal_interrupt_master_set>
   106e2:	e795      	b.n	10610 <am_hal_pwrctrl_low_power_init+0xcc>
   106e4:	2004      	movs	r0, #4
   106e6:	b005      	add	sp, #20
   106e8:	bd30      	pop	{r4, r5, pc}
   106ea:	bf00      	nop
   106ec:	10001578 	.word	0x10001578
   106f0:	4ffff000 	.word	0x4ffff000
   106f4:	40020000 	.word	0x40020000
   106f8:	40021000 	.word	0x40021000
   106fc:	40020018 	.word	0x40020018

00010700 <am_hal_rtc_osc_disable>:
   10700:	4a03      	ldr	r2, [pc, #12]	; (10710 <am_hal_rtc_osc_disable+0x10>)
   10702:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
   10706:	f043 0310 	orr.w	r3, r3, #16
   1070a:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
   1070e:	4770      	bx	lr
   10710:	40004200 	.word	0x40004200

00010714 <am_hal_sysctrl_fpu_enable>:
   10714:	4b02      	ldr	r3, [pc, #8]	; (10720 <am_hal_sysctrl_fpu_enable+0xc>)
   10716:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
   1071a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
   1071e:	4770      	bx	lr
   10720:	e000ed00 	.word	0xe000ed00

00010724 <am_hal_sysctrl_fpu_stacking_enable>:
   10724:	b510      	push	{r4, lr}
   10726:	b082      	sub	sp, #8
   10728:	4604      	mov	r4, r0
   1072a:	f7ff fdc5 	bl	102b8 <am_hal_interrupt_master_disable>
   1072e:	4909      	ldr	r1, [pc, #36]	; (10754 <am_hal_sysctrl_fpu_stacking_enable+0x30>)
   10730:	9001      	str	r0, [sp, #4]
   10732:	6b4a      	ldr	r2, [r1, #52]	; 0x34
   10734:	2c00      	cmp	r4, #0
   10736:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
   1073a:	bf14      	ite	ne
   1073c:	f04f 4340 	movne.w	r3, #3221225472	; 0xc0000000
   10740:	f04f 4300 	moveq.w	r3, #2147483648	; 0x80000000
   10744:	4313      	orrs	r3, r2
   10746:	634b      	str	r3, [r1, #52]	; 0x34
   10748:	9801      	ldr	r0, [sp, #4]
   1074a:	b002      	add	sp, #8
   1074c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10750:	f7ff bdb6 	b.w	102c0 <am_hal_interrupt_master_set>
   10754:	e000ef00 	.word	0xe000ef00

00010758 <am_hal_systick_start>:
   10758:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
   1075c:	6913      	ldr	r3, [r2, #16]
   1075e:	f043 0301 	orr.w	r3, r3, #1
   10762:	6113      	str	r3, [r2, #16]
   10764:	4770      	bx	lr
   10766:	bf00      	nop

00010768 <am_hal_systick_stop>:
   10768:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
   1076c:	6913      	ldr	r3, [r2, #16]
   1076e:	f023 0301 	bic.w	r3, r3, #1
   10772:	6113      	str	r3, [r2, #16]
   10774:	4770      	bx	lr
   10776:	bf00      	nop

00010778 <am_hal_systick_int_enable>:
   10778:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
   1077c:	6913      	ldr	r3, [r2, #16]
   1077e:	f043 0302 	orr.w	r3, r3, #2
   10782:	6113      	str	r3, [r2, #16]
   10784:	4770      	bx	lr
   10786:	bf00      	nop

00010788 <am_hal_systick_load>:
   10788:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
   1078c:	2200      	movs	r2, #0
   1078e:	6158      	str	r0, [r3, #20]
   10790:	619a      	str	r2, [r3, #24]
   10792:	4770      	bx	lr

00010794 <am_hal_systick_count>:
   10794:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
   10798:	6998      	ldr	r0, [r3, #24]
   1079a:	4770      	bx	lr

0001079c <am_hal_uart_initialize>:
   1079c:	2801      	cmp	r0, #1
   1079e:	d81a      	bhi.n	107d6 <am_hal_uart_initialize+0x3a>
   107a0:	b1e9      	cbz	r1, 107de <am_hal_uart_initialize+0x42>
   107a2:	b530      	push	{r4, r5, lr}
   107a4:	2264      	movs	r2, #100	; 0x64
   107a6:	4d0f      	ldr	r5, [pc, #60]	; (107e4 <am_hal_uart_initialize+0x48>)
   107a8:	fb00 f202 	mul.w	r2, r0, r2
   107ac:	18ac      	adds	r4, r5, r2
   107ae:	78e3      	ldrb	r3, [r4, #3]
   107b0:	f3c3 0e00 	ubfx	lr, r3, #0, #1
   107b4:	f013 0301 	ands.w	r3, r3, #1
   107b8:	d10f      	bne.n	107da <am_hal_uart_initialize+0x3e>
   107ba:	6260      	str	r0, [r4, #36]	; 0x24
   107bc:	58a8      	ldr	r0, [r5, r2]
   107be:	f000 4c7e 	and.w	ip, r0, #4261412864	; 0xfe000000
   107c2:	4809      	ldr	r0, [pc, #36]	; (107e8 <am_hal_uart_initialize+0x4c>)
   107c4:	ea4c 0000 	orr.w	r0, ip, r0
   107c8:	50a8      	str	r0, [r5, r2]
   107ca:	f884 e004 	strb.w	lr, [r4, #4]
   107ce:	6623      	str	r3, [r4, #96]	; 0x60
   107d0:	4618      	mov	r0, r3
   107d2:	600c      	str	r4, [r1, #0]
   107d4:	bd30      	pop	{r4, r5, pc}
   107d6:	2005      	movs	r0, #5
   107d8:	4770      	bx	lr
   107da:	2007      	movs	r0, #7
   107dc:	bd30      	pop	{r4, r5, pc}
   107de:	2006      	movs	r0, #6
   107e0:	4770      	bx	lr
   107e2:	bf00      	nop
   107e4:	1000157c 	.word	0x1000157c
   107e8:	01ea9e06 	.word	0x01ea9e06

000107ec <am_hal_uart_deinitialize>:
   107ec:	b170      	cbz	r0, 1080c <am_hal_uart_deinitialize+0x20>
   107ee:	6803      	ldr	r3, [r0, #0]
   107f0:	4a07      	ldr	r2, [pc, #28]	; (10810 <am_hal_uart_deinitialize+0x24>)
   107f2:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   107f6:	4293      	cmp	r3, r2
   107f8:	d108      	bne.n	1080c <am_hal_uart_deinitialize+0x20>
   107fa:	78c2      	ldrb	r2, [r0, #3]
   107fc:	2300      	movs	r3, #0
   107fe:	f36f 0200 	bfc	r2, #0, #1
   10802:	70c2      	strb	r2, [r0, #3]
   10804:	6243      	str	r3, [r0, #36]	; 0x24
   10806:	7103      	strb	r3, [r0, #4]
   10808:	4618      	mov	r0, r3
   1080a:	4770      	bx	lr
   1080c:	2002      	movs	r0, #2
   1080e:	4770      	bx	lr
   10810:	01ea9e06 	.word	0x01ea9e06

00010814 <am_hal_uart_power_control>:
   10814:	b5f0      	push	{r4, r5, r6, r7, lr}
   10816:	4604      	mov	r4, r0
   10818:	6800      	ldr	r0, [r0, #0]
   1081a:	4b39      	ldr	r3, [pc, #228]	; (10900 <am_hal_uart_power_control+0xec>)
   1081c:	f020 467e 	bic.w	r6, r0, #4261412864	; 0xfe000000
   10820:	429e      	cmp	r6, r3
   10822:	b085      	sub	sp, #20
   10824:	d13f      	bne.n	108a6 <am_hal_uart_power_control+0x92>
   10826:	6a65      	ldr	r5, [r4, #36]	; 0x24
   10828:	f105 0008 	add.w	r0, r5, #8
   1082c:	b2c7      	uxtb	r7, r0
   1082e:	b189      	cbz	r1, 10854 <am_hal_uart_power_control+0x40>
   10830:	3901      	subs	r1, #1
   10832:	2901      	cmp	r1, #1
   10834:	d834      	bhi.n	108a0 <am_hal_uart_power_control+0x8c>
   10836:	2a00      	cmp	r2, #0
   10838:	d138      	bne.n	108ac <am_hal_uart_power_control+0x98>
   1083a:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   1083e:	351c      	adds	r5, #28
   10840:	032d      	lsls	r5, r5, #12
   10842:	f04f 33ff 	mov.w	r3, #4294967295
   10846:	646b      	str	r3, [r5, #68]	; 0x44
   10848:	4638      	mov	r0, r7
   1084a:	f7ff fe03 	bl	10454 <am_hal_pwrctrl_periph_disable>
   1084e:	2000      	movs	r0, #0
   10850:	b005      	add	sp, #20
   10852:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10854:	2a00      	cmp	r2, #0
   10856:	d04a      	beq.n	108ee <am_hal_uart_power_control+0xda>
   10858:	7923      	ldrb	r3, [r4, #4]
   1085a:	2b00      	cmp	r3, #0
   1085c:	d04e      	beq.n	108fc <am_hal_uart_power_control+0xe8>
   1085e:	4638      	mov	r0, r7
   10860:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   10864:	9101      	str	r1, [sp, #4]
   10866:	351c      	adds	r5, #28
   10868:	f7ff fdca 	bl	10400 <am_hal_pwrctrl_periph_enable>
   1086c:	f7ff fd24 	bl	102b8 <am_hal_interrupt_master_disable>
   10870:	032d      	lsls	r5, r5, #12
   10872:	68a3      	ldr	r3, [r4, #8]
   10874:	9002      	str	r0, [sp, #8]
   10876:	622b      	str	r3, [r5, #32]
   10878:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
   1087c:	626a      	str	r2, [r5, #36]	; 0x24
   1087e:	62ab      	str	r3, [r5, #40]	; 0x28
   10880:	e9d4 2305 	ldrd	r2, r3, [r4, #20]
   10884:	62ea      	str	r2, [r5, #44]	; 0x2c
   10886:	632b      	str	r3, [r5, #48]	; 0x30
   10888:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
   1088c:	9901      	ldr	r1, [sp, #4]
   1088e:	636a      	str	r2, [r5, #52]	; 0x34
   10890:	63ab      	str	r3, [r5, #56]	; 0x38
   10892:	9802      	ldr	r0, [sp, #8]
   10894:	7121      	strb	r1, [r4, #4]
   10896:	f7ff fd13 	bl	102c0 <am_hal_interrupt_master_set>
   1089a:	9901      	ldr	r1, [sp, #4]
   1089c:	4608      	mov	r0, r1
   1089e:	e000      	b.n	108a2 <am_hal_uart_power_control+0x8e>
   108a0:	2006      	movs	r0, #6
   108a2:	b005      	add	sp, #20
   108a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   108a6:	2002      	movs	r0, #2
   108a8:	b005      	add	sp, #20
   108aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   108ac:	f7ff fd04 	bl	102b8 <am_hal_interrupt_master_disable>
   108b0:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   108b4:	351c      	adds	r5, #28
   108b6:	032d      	lsls	r5, r5, #12
   108b8:	9003      	str	r0, [sp, #12]
   108ba:	6a2b      	ldr	r3, [r5, #32]
   108bc:	60a3      	str	r3, [r4, #8]
   108be:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   108c0:	60e3      	str	r3, [r4, #12]
   108c2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   108c4:	6123      	str	r3, [r4, #16]
   108c6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   108c8:	6163      	str	r3, [r4, #20]
   108ca:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   108cc:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   108ce:	61a3      	str	r3, [r4, #24]
   108d0:	6bab      	ldr	r3, [r5, #56]	; 0x38
   108d2:	61e2      	str	r2, [r4, #28]
   108d4:	2201      	movs	r2, #1
   108d6:	6223      	str	r3, [r4, #32]
   108d8:	9803      	ldr	r0, [sp, #12]
   108da:	7122      	strb	r2, [r4, #4]
   108dc:	f7ff fcf0 	bl	102c0 <am_hal_interrupt_master_set>
   108e0:	6823      	ldr	r3, [r4, #0]
   108e2:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   108e6:	42b3      	cmp	r3, r6
   108e8:	d1ae      	bne.n	10848 <am_hal_uart_power_control+0x34>
   108ea:	6a65      	ldr	r5, [r4, #36]	; 0x24
   108ec:	e7a5      	b.n	1083a <am_hal_uart_power_control+0x26>
   108ee:	4638      	mov	r0, r7
   108f0:	9201      	str	r2, [sp, #4]
   108f2:	f7ff fd85 	bl	10400 <am_hal_pwrctrl_periph_enable>
   108f6:	9a01      	ldr	r2, [sp, #4]
   108f8:	4610      	mov	r0, r2
   108fa:	e7d2      	b.n	108a2 <am_hal_uart_power_control+0x8e>
   108fc:	2007      	movs	r0, #7
   108fe:	e7d0      	b.n	108a2 <am_hal_uart_power_control+0x8e>
   10900:	01ea9e06 	.word	0x01ea9e06

00010904 <am_hal_uart_configure>:
   10904:	6803      	ldr	r3, [r0, #0]
   10906:	4a78      	ldr	r2, [pc, #480]	; (10ae8 <am_hal_uart_configure+0x1e4>)
   10908:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   1090c:	4293      	cmp	r3, r2
   1090e:	d001      	beq.n	10914 <am_hal_uart_configure+0x10>
   10910:	2002      	movs	r0, #2
   10912:	4770      	bx	lr
   10914:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10918:	6a44      	ldr	r4, [r0, #36]	; 0x24
   1091a:	f504 2480 	add.w	r4, r4, #262144	; 0x40000
   1091e:	341c      	adds	r4, #28
   10920:	0324      	lsls	r4, r4, #12
   10922:	2700      	movs	r7, #0
   10924:	b084      	sub	sp, #16
   10926:	6327      	str	r7, [r4, #48]	; 0x30
   10928:	460e      	mov	r6, r1
   1092a:	4605      	mov	r5, r0
   1092c:	f7ff fcc4 	bl	102b8 <am_hal_interrupt_master_disable>
   10930:	9001      	str	r0, [sp, #4]
   10932:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   10934:	f043 0308 	orr.w	r3, r3, #8
   10938:	8623      	strh	r3, [r4, #48]	; 0x30
   1093a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   1093c:	2201      	movs	r2, #1
   1093e:	f362 1306 	bfi	r3, r2, #4, #3
   10942:	8623      	strh	r3, [r4, #48]	; 0x30
   10944:	9801      	ldr	r0, [sp, #4]
   10946:	f7ff fcbb 	bl	102c0 <am_hal_interrupt_master_set>
   1094a:	f7ff fcb5 	bl	102b8 <am_hal_interrupt_master_disable>
   1094e:	9002      	str	r0, [sp, #8]
   10950:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   10952:	f367 0300 	bfi	r3, r7, #0, #1
   10956:	8623      	strh	r3, [r4, #48]	; 0x30
   10958:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   1095a:	f367 2349 	bfi	r3, r7, #9, #1
   1095e:	8623      	strh	r3, [r4, #48]	; 0x30
   10960:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   10962:	f367 2308 	bfi	r3, r7, #8, #1
   10966:	8623      	strh	r3, [r4, #48]	; 0x30
   10968:	9802      	ldr	r0, [sp, #8]
   1096a:	f7ff fca9 	bl	102c0 <am_hal_interrupt_master_set>
   1096e:	4b5f      	ldr	r3, [pc, #380]	; (10aec <am_hal_uart_configure+0x1e8>)
   10970:	6832      	ldr	r2, [r6, #0]
   10972:	68db      	ldr	r3, [r3, #12]
   10974:	b2db      	uxtb	r3, r3
   10976:	2b12      	cmp	r3, #18
   10978:	d076      	beq.n	10a68 <am_hal_uart_configure+0x164>
   1097a:	4b5c      	ldr	r3, [pc, #368]	; (10aec <am_hal_uart_configure+0x1e8>)
   1097c:	68db      	ldr	r3, [r3, #12]
   1097e:	b2db      	uxtb	r3, r3
   10980:	2b20      	cmp	r3, #32
   10982:	d902      	bls.n	1098a <am_hal_uart_configure+0x86>
   10984:	4b5a      	ldr	r3, [pc, #360]	; (10af0 <am_hal_uart_configure+0x1ec>)
   10986:	429a      	cmp	r2, r3
   10988:	d871      	bhi.n	10a6e <am_hal_uart_configure+0x16a>
   1098a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1098c:	f3c3 1302 	ubfx	r3, r3, #4, #3
   10990:	3b01      	subs	r3, #1
   10992:	b2db      	uxtb	r3, r3
   10994:	2b03      	cmp	r3, #3
   10996:	d86c      	bhi.n	10a72 <am_hal_uart_configure+0x16e>
   10998:	4956      	ldr	r1, [pc, #344]	; (10af4 <am_hal_uart_configure+0x1f0>)
   1099a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
   1099e:	0112      	lsls	r2, r2, #4
   109a0:	4291      	cmp	r1, r2
   109a2:	ea4f 1381 	mov.w	r3, r1, lsl #6
   109a6:	fbb1 f0f2 	udiv	r0, r1, r2
   109aa:	fbb3 f3f2 	udiv	r3, r3, r2
   109ae:	eba3 1380 	sub.w	r3, r3, r0, lsl #6
   109b2:	d364      	bcc.n	10a7e <am_hal_uart_configure+0x17a>
   109b4:	6260      	str	r0, [r4, #36]	; 0x24
   109b6:	6260      	str	r0, [r4, #36]	; 0x24
   109b8:	62a3      	str	r3, [r4, #40]	; 0x28
   109ba:	089b      	lsrs	r3, r3, #2
   109bc:	eb03 1300 	add.w	r3, r3, r0, lsl #4
   109c0:	fbb1 f3f3 	udiv	r3, r1, r3
   109c4:	662b      	str	r3, [r5, #96]	; 0x60
   109c6:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   109c8:	f36f 338e 	bfc	r3, #14, #1
   109cc:	8623      	strh	r3, [r4, #48]	; 0x30
   109ce:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   109d0:	f36f 33cf 	bfc	r3, #15, #1
   109d4:	8623      	strh	r3, [r4, #48]	; 0x30
   109d6:	6933      	ldr	r3, [r6, #16]
   109d8:	6b22      	ldr	r2, [r4, #48]	; 0x30
   109da:	6971      	ldr	r1, [r6, #20]
   109dc:	431a      	orrs	r2, r3
   109de:	6873      	ldr	r3, [r6, #4]
   109e0:	6322      	str	r2, [r4, #48]	; 0x30
   109e2:	68f2      	ldr	r2, [r6, #12]
   109e4:	6361      	str	r1, [r4, #52]	; 0x34
   109e6:	4313      	orrs	r3, r2
   109e8:	68b2      	ldr	r2, [r6, #8]
   109ea:	4313      	orrs	r3, r2
   109ec:	f043 0310 	orr.w	r3, r3, #16
   109f0:	62e3      	str	r3, [r4, #44]	; 0x2c
   109f2:	f7ff fc61 	bl	102b8 <am_hal_interrupt_master_disable>
   109f6:	9003      	str	r0, [sp, #12]
   109f8:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   109fa:	f043 0301 	orr.w	r3, r3, #1
   109fe:	8623      	strh	r3, [r4, #48]	; 0x30
   10a00:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   10a02:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   10a06:	8623      	strh	r3, [r4, #48]	; 0x30
   10a08:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   10a0a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10a0e:	8623      	strh	r3, [r4, #48]	; 0x30
   10a10:	9803      	ldr	r0, [sp, #12]
   10a12:	f7ff fc55 	bl	102c0 <am_hal_interrupt_master_set>
   10a16:	682a      	ldr	r2, [r5, #0]
   10a18:	4b33      	ldr	r3, [pc, #204]	; (10ae8 <am_hal_uart_configure+0x1e4>)
   10a1a:	f022 487e 	bic.w	r8, r2, #4261412864	; 0xfe000000
   10a1e:	4598      	cmp	r8, r3
   10a20:	d11e      	bne.n	10a60 <am_hal_uart_configure+0x15c>
   10a22:	69b1      	ldr	r1, [r6, #24]
   10a24:	e9d6 4708 	ldrd	r4, r7, [r6, #32]
   10a28:	b109      	cbz	r1, 10a2e <am_hal_uart_configure+0x12a>
   10a2a:	69f3      	ldr	r3, [r6, #28]
   10a2c:	bb5b      	cbnz	r3, 10a86 <am_hal_uart_configure+0x182>
   10a2e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   10a30:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   10a34:	331c      	adds	r3, #28
   10a36:	031b      	lsls	r3, r3, #12
   10a38:	2200      	movs	r2, #0
   10a3a:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
   10a3e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10a40:	f022 0220 	bic.w	r2, r2, #32
   10a44:	639a      	str	r2, [r3, #56]	; 0x38
   10a46:	b10c      	cbz	r4, 10a4c <am_hal_uart_configure+0x148>
   10a48:	2f00      	cmp	r7, #0
   10a4a:	d132      	bne.n	10ab2 <am_hal_uart_configure+0x1ae>
   10a4c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10a4e:	2000      	movs	r0, #0
   10a50:	f022 0250 	bic.w	r2, r2, #80	; 0x50
   10a54:	f885 0044 	strb.w	r0, [r5, #68]	; 0x44
   10a58:	639a      	str	r2, [r3, #56]	; 0x38
   10a5a:	b004      	add	sp, #16
   10a5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10a60:	2000      	movs	r0, #0
   10a62:	b004      	add	sp, #16
   10a64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10a68:	f5b2 2f61 	cmp.w	r2, #921600	; 0xe1000
   10a6c:	d985      	bls.n	1097a <am_hal_uart_configure+0x76>
   10a6e:	4822      	ldr	r0, [pc, #136]	; (10af8 <am_hal_uart_configure+0x1f4>)
   10a70:	e7f3      	b.n	10a5a <am_hal_uart_configure+0x156>
   10a72:	4822      	ldr	r0, [pc, #136]	; (10afc <am_hal_uart_configure+0x1f8>)
   10a74:	2300      	movs	r3, #0
   10a76:	662b      	str	r3, [r5, #96]	; 0x60
   10a78:	b004      	add	sp, #16
   10a7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10a7e:	2300      	movs	r3, #0
   10a80:	481d      	ldr	r0, [pc, #116]	; (10af8 <am_hal_uart_configure+0x1f4>)
   10a82:	662b      	str	r3, [r5, #96]	; 0x60
   10a84:	e7e9      	b.n	10a5a <am_hal_uart_configure+0x156>
   10a86:	2201      	movs	r2, #1
   10a88:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
   10a8c:	f105 002c 	add.w	r0, r5, #44	; 0x2c
   10a90:	f000 fa5e 	bl	10f50 <am_hal_queue_init>
   10a94:	682b      	ldr	r3, [r5, #0]
   10a96:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   10a9a:	4543      	cmp	r3, r8
   10a9c:	d1e0      	bne.n	10a60 <am_hal_uart_configure+0x15c>
   10a9e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   10aa0:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   10aa4:	331c      	adds	r3, #28
   10aa6:	031b      	lsls	r3, r3, #12
   10aa8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10aaa:	f042 0220 	orr.w	r2, r2, #32
   10aae:	639a      	str	r2, [r3, #56]	; 0x38
   10ab0:	e7c9      	b.n	10a46 <am_hal_uart_configure+0x142>
   10ab2:	2201      	movs	r2, #1
   10ab4:	f885 2044 	strb.w	r2, [r5, #68]	; 0x44
   10ab8:	463b      	mov	r3, r7
   10aba:	4621      	mov	r1, r4
   10abc:	f105 0048 	add.w	r0, r5, #72	; 0x48
   10ac0:	f000 fa46 	bl	10f50 <am_hal_queue_init>
   10ac4:	682b      	ldr	r3, [r5, #0]
   10ac6:	4a08      	ldr	r2, [pc, #32]	; (10ae8 <am_hal_uart_configure+0x1e4>)
   10ac8:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   10acc:	4293      	cmp	r3, r2
   10ace:	d1c7      	bne.n	10a60 <am_hal_uart_configure+0x15c>
   10ad0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   10ad2:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   10ad6:	331c      	adds	r3, #28
   10ad8:	031b      	lsls	r3, r3, #12
   10ada:	2000      	movs	r0, #0
   10adc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   10ade:	f042 0250 	orr.w	r2, r2, #80	; 0x50
   10ae2:	639a      	str	r2, [r3, #56]	; 0x38
   10ae4:	e7b9      	b.n	10a5a <am_hal_uart_configure+0x156>
   10ae6:	bf00      	nop
   10ae8:	01ea9e06 	.word	0x01ea9e06
   10aec:	40020000 	.word	0x40020000
   10af0:	0016e360 	.word	0x0016e360
   10af4:	00011b20 	.word	0x00011b20
   10af8:	08000003 	.word	0x08000003
   10afc:	08000002 	.word	0x08000002

00010b00 <am_hal_uart_transfer>:
   10b00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10b04:	ed2d 8b02 	vpush	{d8}
   10b08:	680d      	ldr	r5, [r1, #0]
   10b0a:	b091      	sub	sp, #68	; 0x44
   10b0c:	4604      	mov	r4, r0
   10b0e:	b14d      	cbz	r5, 10b24 <am_hal_uart_transfer+0x24>
   10b10:	2d01      	cmp	r5, #1
   10b12:	f000 808f 	beq.w	10c34 <am_hal_uart_transfer+0x134>
   10b16:	2507      	movs	r5, #7
   10b18:	4628      	mov	r0, r5
   10b1a:	b011      	add	sp, #68	; 0x44
   10b1c:	ecbd 8b02 	vpop	{d8}
   10b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10b24:	e9d1 b802 	ldrd	fp, r8, [r1, #8]
   10b28:	684b      	ldr	r3, [r1, #4]
   10b2a:	690a      	ldr	r2, [r1, #16]
   10b2c:	9202      	str	r2, [sp, #8]
   10b2e:	4618      	mov	r0, r3
   10b30:	f1b8 0f00 	cmp.w	r8, #0
   10b34:	f000 8111 	beq.w	10d5a <am_hal_uart_transfer+0x25a>
   10b38:	f1bb 0f00 	cmp.w	fp, #0
   10b3c:	f000 8172 	beq.w	10e24 <am_hal_uart_transfer+0x324>
   10b40:	2c00      	cmp	r4, #0
   10b42:	f000 8165 	beq.w	10e10 <am_hal_uart_transfer+0x310>
   10b46:	46a9      	mov	r9, r5
   10b48:	462f      	mov	r7, r5
   10b4a:	9501      	str	r5, [sp, #4]
   10b4c:	4625      	mov	r5, r4
   10b4e:	4619      	mov	r1, r3
   10b50:	682a      	ldr	r2, [r5, #0]
   10b52:	461c      	mov	r4, r3
   10b54:	4bad      	ldr	r3, [pc, #692]	; (10e0c <am_hal_uart_transfer+0x30c>)
   10b56:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   10b5a:	429a      	cmp	r2, r3
   10b5c:	465e      	mov	r6, fp
   10b5e:	d12d      	bne.n	10bbc <am_hal_uart_transfer+0xbc>
   10b60:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   10b64:	bb7a      	cbnz	r2, 10bc6 <am_hal_uart_transfer+0xc6>
   10b66:	1e48      	subs	r0, r1, #1
   10b68:	6a69      	ldr	r1, [r5, #36]	; 0x24
   10b6a:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   10b6e:	311c      	adds	r1, #28
   10b70:	0309      	lsls	r1, r1, #12
   10b72:	698b      	ldr	r3, [r1, #24]
   10b74:	069b      	lsls	r3, r3, #26
   10b76:	d405      	bmi.n	10b84 <am_hal_uart_transfer+0x84>
   10b78:	3201      	adds	r2, #1
   10b7a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   10b7e:	600b      	str	r3, [r1, #0]
   10b80:	4296      	cmp	r6, r2
   10b82:	d8f6      	bhi.n	10b72 <am_hal_uart_transfer+0x72>
   10b84:	4417      	add	r7, r2
   10b86:	1ab6      	subs	r6, r6, r2
   10b88:	b936      	cbnz	r6, 10b98 <am_hal_uart_transfer+0x98>
   10b8a:	9d01      	ldr	r5, [sp, #4]
   10b8c:	9b02      	ldr	r3, [sp, #8]
   10b8e:	2b00      	cmp	r3, #0
   10b90:	f000 808c 	beq.w	10cac <am_hal_uart_transfer+0x1ac>
   10b94:	601f      	str	r7, [r3, #0]
   10b96:	e7bf      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10b98:	2010      	movs	r0, #16
   10b9a:	f7ff f9c3 	bl	ff24 <am_hal_flash_delay>
   10b9e:	f1b8 3fff 	cmp.w	r8, #4294967295
   10ba2:	bf18      	it	ne
   10ba4:	f109 0901 	addne.w	r9, r9, #1
   10ba8:	45c8      	cmp	r8, r9
   10baa:	d9ee      	bls.n	10b8a <am_hal_uart_transfer+0x8a>
   10bac:	682a      	ldr	r2, [r5, #0]
   10bae:	4b97      	ldr	r3, [pc, #604]	; (10e0c <am_hal_uart_transfer+0x30c>)
   10bb0:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   10bb4:	429a      	cmp	r2, r3
   10bb6:	eb04 0107 	add.w	r1, r4, r7
   10bba:	d0d1      	beq.n	10b60 <am_hal_uart_transfer+0x60>
   10bbc:	9b02      	ldr	r3, [sp, #8]
   10bbe:	b103      	cbz	r3, 10bc2 <am_hal_uart_transfer+0xc2>
   10bc0:	601f      	str	r7, [r3, #0]
   10bc2:	2502      	movs	r5, #2
   10bc4:	e7a8      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10bc6:	e9d5 020d 	ldrd	r0, r2, [r5, #52]	; 0x34
   10bca:	1a12      	subs	r2, r2, r0
   10bcc:	42b2      	cmp	r2, r6
   10bce:	4613      	mov	r3, r2
   10bd0:	f105 0b2c 	add.w	fp, r5, #44	; 0x2c
   10bd4:	bf28      	it	cs
   10bd6:	4633      	movcs	r3, r6
   10bd8:	461a      	mov	r2, r3
   10bda:	4658      	mov	r0, fp
   10bdc:	9303      	str	r3, [sp, #12]
   10bde:	f000 f9c3 	bl	10f68 <am_hal_queue_item_add>
   10be2:	f8d5 a024 	ldr.w	sl, [r5, #36]	; 0x24
   10be6:	f7ff fb67 	bl	102b8 <am_hal_interrupt_master_disable>
   10bea:	f50a 2a80 	add.w	sl, sl, #262144	; 0x40000
   10bee:	f10a 0a1c 	add.w	sl, sl, #28
   10bf2:	9008      	str	r0, [sp, #32]
   10bf4:	ea4f 3a0a 	mov.w	sl, sl, lsl #12
   10bf8:	e00d      	b.n	10c16 <am_hal_uart_transfer+0x116>
   10bfa:	f000 f9f3 	bl	10fe4 <am_hal_queue_item_get>
   10bfe:	b190      	cbz	r0, 10c26 <am_hal_uart_transfer+0x126>
   10c00:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   10c02:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   10c06:	321c      	adds	r2, #28
   10c08:	0312      	lsls	r2, r2, #12
   10c0a:	6993      	ldr	r3, [r2, #24]
   10c0c:	0699      	lsls	r1, r3, #26
   10c0e:	bf5c      	itt	pl
   10c10:	f89d 301c 	ldrbpl.w	r3, [sp, #28]
   10c14:	6013      	strpl	r3, [r2, #0]
   10c16:	f8da 3018 	ldr.w	r3, [sl, #24]
   10c1a:	069b      	lsls	r3, r3, #26
   10c1c:	f04f 0201 	mov.w	r2, #1
   10c20:	a907      	add	r1, sp, #28
   10c22:	4658      	mov	r0, fp
   10c24:	d5e9      	bpl.n	10bfa <am_hal_uart_transfer+0xfa>
   10c26:	9b03      	ldr	r3, [sp, #12]
   10c28:	9808      	ldr	r0, [sp, #32]
   10c2a:	441f      	add	r7, r3
   10c2c:	1af6      	subs	r6, r6, r3
   10c2e:	f7ff fb47 	bl	102c0 <am_hal_interrupt_master_set>
   10c32:	e7a9      	b.n	10b88 <am_hal_uart_transfer+0x88>
   10c34:	68cd      	ldr	r5, [r1, #12]
   10c36:	690b      	ldr	r3, [r1, #16]
   10c38:	9301      	str	r3, [sp, #4]
   10c3a:	e9d1 b701 	ldrd	fp, r7, [r1, #4]
   10c3e:	2d00      	cmp	r5, #0
   10c40:	f000 80b5 	beq.w	10dae <am_hal_uart_transfer+0x2ae>
   10c44:	2f00      	cmp	r7, #0
   10c46:	f000 811e 	beq.w	10e86 <am_hal_uart_transfer+0x386>
   10c4a:	2800      	cmp	r0, #0
   10c4c:	f000 80e7 	beq.w	10e1e <am_hal_uart_transfer+0x31e>
   10c50:	6822      	ldr	r2, [r4, #0]
   10c52:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 10e0c <am_hal_uart_transfer+0x30c>
   10c56:	f100 0348 	add.w	r3, r0, #72	; 0x48
   10c5a:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   10c5e:	ee08 3a10 	vmov	s16, r3
   10c62:	f04f 0900 	mov.w	r9, #0
   10c66:	462b      	mov	r3, r5
   10c68:	4552      	cmp	r2, sl
   10c6a:	46c8      	mov	r8, r9
   10c6c:	465d      	mov	r5, fp
   10c6e:	461e      	mov	r6, r3
   10c70:	d133      	bne.n	10cda <am_hal_uart_transfer+0x1da>
   10c72:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   10c76:	2a00      	cmp	r2, #0
   10c78:	d137      	bne.n	10cea <am_hal_uart_transfer+0x1ea>
   10c7a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   10c7c:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   10c80:	311c      	adds	r1, #28
   10c82:	1e68      	subs	r0, r5, #1
   10c84:	0309      	lsls	r1, r1, #12
   10c86:	698b      	ldr	r3, [r1, #24]
   10c88:	06dd      	lsls	r5, r3, #27
   10c8a:	d408      	bmi.n	10c9e <am_hal_uart_transfer+0x19e>
   10c8c:	680b      	ldr	r3, [r1, #0]
   10c8e:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   10c92:	d15e      	bne.n	10d52 <am_hal_uart_transfer+0x252>
   10c94:	3201      	adds	r2, #1
   10c96:	4297      	cmp	r7, r2
   10c98:	f800 3f01 	strb.w	r3, [r0, #1]!
   10c9c:	d8f3      	bhi.n	10c86 <am_hal_uart_transfer+0x186>
   10c9e:	4490      	add	r8, r2
   10ca0:	1abf      	subs	r7, r7, r2
   10ca2:	b957      	cbnz	r7, 10cba <am_hal_uart_transfer+0x1ba>
   10ca4:	9b01      	ldr	r3, [sp, #4]
   10ca6:	b10b      	cbz	r3, 10cac <am_hal_uart_transfer+0x1ac>
   10ca8:	f8c3 8000 	str.w	r8, [r3]
   10cac:	2500      	movs	r5, #0
   10cae:	4628      	mov	r0, r5
   10cb0:	b011      	add	sp, #68	; 0x44
   10cb2:	ecbd 8b02 	vpop	{d8}
   10cb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10cba:	2010      	movs	r0, #16
   10cbc:	f7ff f932 	bl	ff24 <am_hal_flash_delay>
   10cc0:	1c73      	adds	r3, r6, #1
   10cc2:	bf18      	it	ne
   10cc4:	f109 0901 	addne.w	r9, r9, #1
   10cc8:	454e      	cmp	r6, r9
   10cca:	d9eb      	bls.n	10ca4 <am_hal_uart_transfer+0x1a4>
   10ccc:	6822      	ldr	r2, [r4, #0]
   10cce:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   10cd2:	4552      	cmp	r2, sl
   10cd4:	eb0b 0508 	add.w	r5, fp, r8
   10cd8:	d0cb      	beq.n	10c72 <am_hal_uart_transfer+0x172>
   10cda:	2502      	movs	r5, #2
   10cdc:	9b01      	ldr	r3, [sp, #4]
   10cde:	2b00      	cmp	r3, #0
   10ce0:	f43f af1a 	beq.w	10b18 <am_hal_uart_transfer+0x18>
   10ce4:	f8c3 8000 	str.w	r8, [r3]
   10ce8:	e716      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10cea:	f7ff fae5 	bl	102b8 <am_hal_interrupt_master_disable>
   10cee:	9007      	str	r0, [sp, #28]
   10cf0:	6a60      	ldr	r0, [r4, #36]	; 0x24
   10cf2:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
   10cf6:	301c      	adds	r0, #28
   10cf8:	0300      	lsls	r0, r0, #12
   10cfa:	f10d 0c20 	add.w	ip, sp, #32
   10cfe:	2200      	movs	r2, #0
   10d00:	6983      	ldr	r3, [r0, #24]
   10d02:	06db      	lsls	r3, r3, #27
   10d04:	d409      	bmi.n	10d1a <am_hal_uart_transfer+0x21a>
   10d06:	6803      	ldr	r3, [r0, #0]
   10d08:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   10d0c:	f102 0201 	add.w	r2, r2, #1
   10d10:	d119      	bne.n	10d46 <am_hal_uart_transfer+0x246>
   10d12:	2a20      	cmp	r2, #32
   10d14:	f80c 3b01 	strb.w	r3, [ip], #1
   10d18:	d1f2      	bne.n	10d00 <am_hal_uart_transfer+0x200>
   10d1a:	ee18 0a10 	vmov	r0, s16
   10d1e:	a908      	add	r1, sp, #32
   10d20:	f000 f922 	bl	10f68 <am_hal_queue_item_add>
   10d24:	2800      	cmp	r0, #0
   10d26:	d075      	beq.n	10e14 <am_hal_uart_transfer+0x314>
   10d28:	9807      	ldr	r0, [sp, #28]
   10d2a:	f7ff fac9 	bl	102c0 <am_hal_interrupt_master_set>
   10d2e:	6d22      	ldr	r2, [r4, #80]	; 0x50
   10d30:	42ba      	cmp	r2, r7
   10d32:	bf28      	it	cs
   10d34:	463a      	movcs	r2, r7
   10d36:	ee18 0a10 	vmov	r0, s16
   10d3a:	4629      	mov	r1, r5
   10d3c:	4490      	add	r8, r2
   10d3e:	1abf      	subs	r7, r7, r2
   10d40:	f000 f950 	bl	10fe4 <am_hal_queue_item_get>
   10d44:	e7ad      	b.n	10ca2 <am_hal_uart_transfer+0x1a2>
   10d46:	9807      	ldr	r0, [sp, #28]
   10d48:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   10d4c:	f7ff fab8 	bl	102c0 <am_hal_interrupt_master_set>
   10d50:	e7c4      	b.n	10cdc <am_hal_uart_transfer+0x1dc>
   10d52:	4490      	add	r8, r2
   10d54:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   10d58:	e7c0      	b.n	10cdc <am_hal_uart_transfer+0x1dc>
   10d5a:	2c00      	cmp	r4, #0
   10d5c:	f43f af31 	beq.w	10bc2 <am_hal_uart_transfer+0xc2>
   10d60:	6822      	ldr	r2, [r4, #0]
   10d62:	492a      	ldr	r1, [pc, #168]	; (10e0c <am_hal_uart_transfer+0x30c>)
   10d64:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   10d68:	428a      	cmp	r2, r1
   10d6a:	f47f af2a 	bne.w	10bc2 <am_hal_uart_transfer+0xc2>
   10d6e:	9b02      	ldr	r3, [sp, #8]
   10d70:	b10b      	cbz	r3, 10d76 <am_hal_uart_transfer+0x276>
   10d72:	f8c3 8000 	str.w	r8, [r3]
   10d76:	f1bb 0f00 	cmp.w	fp, #0
   10d7a:	d097      	beq.n	10cac <am_hal_uart_transfer+0x1ac>
   10d7c:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
   10d80:	2d00      	cmp	r5, #0
   10d82:	d151      	bne.n	10e28 <am_hal_uart_transfer+0x328>
   10d84:	6a61      	ldr	r1, [r4, #36]	; 0x24
   10d86:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   10d8a:	311c      	adds	r1, #28
   10d8c:	1e42      	subs	r2, r0, #1
   10d8e:	0309      	lsls	r1, r1, #12
   10d90:	698b      	ldr	r3, [r1, #24]
   10d92:	0698      	lsls	r0, r3, #26
   10d94:	d405      	bmi.n	10da2 <am_hal_uart_transfer+0x2a2>
   10d96:	3501      	adds	r5, #1
   10d98:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   10d9c:	600b      	str	r3, [r1, #0]
   10d9e:	45ab      	cmp	fp, r5
   10da0:	d1f6      	bne.n	10d90 <am_hal_uart_transfer+0x290>
   10da2:	9b02      	ldr	r3, [sp, #8]
   10da4:	2b00      	cmp	r3, #0
   10da6:	d081      	beq.n	10cac <am_hal_uart_transfer+0x1ac>
   10da8:	601d      	str	r5, [r3, #0]
   10daa:	2500      	movs	r5, #0
   10dac:	e6b4      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10dae:	2800      	cmp	r0, #0
   10db0:	f43f af07 	beq.w	10bc2 <am_hal_uart_transfer+0xc2>
   10db4:	6802      	ldr	r2, [r0, #0]
   10db6:	4915      	ldr	r1, [pc, #84]	; (10e0c <am_hal_uart_transfer+0x30c>)
   10db8:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   10dbc:	428a      	cmp	r2, r1
   10dbe:	f47f af00 	bne.w	10bc2 <am_hal_uart_transfer+0xc2>
   10dc2:	b103      	cbz	r3, 10dc6 <am_hal_uart_transfer+0x2c6>
   10dc4:	601d      	str	r5, [r3, #0]
   10dc6:	2f00      	cmp	r7, #0
   10dc8:	f43f af70 	beq.w	10cac <am_hal_uart_transfer+0x1ac>
   10dcc:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   10dd0:	2a00      	cmp	r2, #0
   10dd2:	d15a      	bne.n	10e8a <am_hal_uart_transfer+0x38a>
   10dd4:	6a61      	ldr	r1, [r4, #36]	; 0x24
   10dd6:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   10dda:	311c      	adds	r1, #28
   10ddc:	f10b 33ff 	add.w	r3, fp, #4294967295
   10de0:	0309      	lsls	r1, r1, #12
   10de2:	4614      	mov	r4, r2
   10de4:	698a      	ldr	r2, [r1, #24]
   10de6:	06d2      	lsls	r2, r2, #27
   10de8:	d409      	bmi.n	10dfe <am_hal_uart_transfer+0x2fe>
   10dea:	680a      	ldr	r2, [r1, #0]
   10dec:	f412 6070 	ands.w	r0, r2, #3840	; 0xf00
   10df0:	d176      	bne.n	10ee0 <am_hal_uart_transfer+0x3e0>
   10df2:	3401      	adds	r4, #1
   10df4:	42a7      	cmp	r7, r4
   10df6:	f803 2f01 	strb.w	r2, [r3, #1]!
   10dfa:	d1f3      	bne.n	10de4 <am_hal_uart_transfer+0x2e4>
   10dfc:	4605      	mov	r5, r0
   10dfe:	9b01      	ldr	r3, [sp, #4]
   10e00:	2b00      	cmp	r3, #0
   10e02:	f43f ae89 	beq.w	10b18 <am_hal_uart_transfer+0x18>
   10e06:	601c      	str	r4, [r3, #0]
   10e08:	e686      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10e0a:	bf00      	nop
   10e0c:	01ea9e06 	.word	0x01ea9e06
   10e10:	4627      	mov	r7, r4
   10e12:	e6d3      	b.n	10bbc <am_hal_uart_transfer+0xbc>
   10e14:	9807      	ldr	r0, [sp, #28]
   10e16:	4d39      	ldr	r5, [pc, #228]	; (10efc <am_hal_uart_transfer+0x3fc>)
   10e18:	f7ff fa52 	bl	102c0 <am_hal_interrupt_master_set>
   10e1c:	e75e      	b.n	10cdc <am_hal_uart_transfer+0x1dc>
   10e1e:	2502      	movs	r5, #2
   10e20:	4680      	mov	r8, r0
   10e22:	e75b      	b.n	10cdc <am_hal_uart_transfer+0x1dc>
   10e24:	462f      	mov	r7, r5
   10e26:	e6b1      	b.n	10b8c <am_hal_uart_transfer+0x8c>
   10e28:	6b65      	ldr	r5, [r4, #52]	; 0x34
   10e2a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   10e2c:	1b52      	subs	r2, r2, r5
   10e2e:	455a      	cmp	r2, fp
   10e30:	f104 072c 	add.w	r7, r4, #44	; 0x2c
   10e34:	4601      	mov	r1, r0
   10e36:	bf28      	it	cs
   10e38:	465a      	movcs	r2, fp
   10e3a:	4638      	mov	r0, r7
   10e3c:	4615      	mov	r5, r2
   10e3e:	f000 f893 	bl	10f68 <am_hal_queue_item_add>
   10e42:	6a66      	ldr	r6, [r4, #36]	; 0x24
   10e44:	f7ff fa38 	bl	102b8 <am_hal_interrupt_master_disable>
   10e48:	f506 2680 	add.w	r6, r6, #262144	; 0x40000
   10e4c:	361c      	adds	r6, #28
   10e4e:	9005      	str	r0, [sp, #20]
   10e50:	0336      	lsls	r6, r6, #12
   10e52:	e00f      	b.n	10e74 <am_hal_uart_transfer+0x374>
   10e54:	a908      	add	r1, sp, #32
   10e56:	4638      	mov	r0, r7
   10e58:	f000 f8c4 	bl	10fe4 <am_hal_queue_item_get>
   10e5c:	b178      	cbz	r0, 10e7e <am_hal_uart_transfer+0x37e>
   10e5e:	6a62      	ldr	r2, [r4, #36]	; 0x24
   10e60:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
   10e64:	321c      	adds	r2, #28
   10e66:	0312      	lsls	r2, r2, #12
   10e68:	6993      	ldr	r3, [r2, #24]
   10e6a:	0699      	lsls	r1, r3, #26
   10e6c:	bf5c      	itt	pl
   10e6e:	f89d 3020 	ldrbpl.w	r3, [sp, #32]
   10e72:	6013      	strpl	r3, [r2, #0]
   10e74:	69b3      	ldr	r3, [r6, #24]
   10e76:	069b      	lsls	r3, r3, #26
   10e78:	f04f 0201 	mov.w	r2, #1
   10e7c:	d5ea      	bpl.n	10e54 <am_hal_uart_transfer+0x354>
   10e7e:	9805      	ldr	r0, [sp, #20]
   10e80:	f7ff fa1e 	bl	102c0 <am_hal_interrupt_master_set>
   10e84:	e78d      	b.n	10da2 <am_hal_uart_transfer+0x2a2>
   10e86:	46b8      	mov	r8, r7
   10e88:	e70c      	b.n	10ca4 <am_hal_uart_transfer+0x1a4>
   10e8a:	f7ff fa15 	bl	102b8 <am_hal_interrupt_master_disable>
   10e8e:	6a61      	ldr	r1, [r4, #36]	; 0x24
   10e90:	9006      	str	r0, [sp, #24]
   10e92:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
   10e96:	311c      	adds	r1, #28
   10e98:	0309      	lsls	r1, r1, #12
   10e9a:	ae08      	add	r6, sp, #32
   10e9c:	2200      	movs	r2, #0
   10e9e:	698b      	ldr	r3, [r1, #24]
   10ea0:	06d8      	lsls	r0, r3, #27
   10ea2:	d409      	bmi.n	10eb8 <am_hal_uart_transfer+0x3b8>
   10ea4:	680b      	ldr	r3, [r1, #0]
   10ea6:	f413 6f70 	tst.w	r3, #3840	; 0xf00
   10eaa:	f102 0201 	add.w	r2, r2, #1
   10eae:	d11a      	bne.n	10ee6 <am_hal_uart_transfer+0x3e6>
   10eb0:	2a20      	cmp	r2, #32
   10eb2:	f806 3b01 	strb.w	r3, [r6], #1
   10eb6:	d1f2      	bne.n	10e9e <am_hal_uart_transfer+0x39e>
   10eb8:	f104 0648 	add.w	r6, r4, #72	; 0x48
   10ebc:	a908      	add	r1, sp, #32
   10ebe:	4630      	mov	r0, r6
   10ec0:	f000 f852 	bl	10f68 <am_hal_queue_item_add>
   10ec4:	b1a8      	cbz	r0, 10ef2 <am_hal_uart_transfer+0x3f2>
   10ec6:	9806      	ldr	r0, [sp, #24]
   10ec8:	f7ff f9fa 	bl	102c0 <am_hal_interrupt_master_set>
   10ecc:	6d24      	ldr	r4, [r4, #80]	; 0x50
   10ece:	42bc      	cmp	r4, r7
   10ed0:	bf28      	it	cs
   10ed2:	463c      	movcs	r4, r7
   10ed4:	4659      	mov	r1, fp
   10ed6:	4630      	mov	r0, r6
   10ed8:	4622      	mov	r2, r4
   10eda:	f000 f883 	bl	10fe4 <am_hal_queue_item_get>
   10ede:	e78e      	b.n	10dfe <am_hal_uart_transfer+0x2fe>
   10ee0:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   10ee4:	e78b      	b.n	10dfe <am_hal_uart_transfer+0x2fe>
   10ee6:	9806      	ldr	r0, [sp, #24]
   10ee8:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   10eec:	f7ff f9e8 	bl	102c0 <am_hal_interrupt_master_set>
   10ef0:	e612      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10ef2:	9806      	ldr	r0, [sp, #24]
   10ef4:	4d01      	ldr	r5, [pc, #4]	; (10efc <am_hal_uart_transfer+0x3fc>)
   10ef6:	f7ff f9e3 	bl	102c0 <am_hal_interrupt_master_set>
   10efa:	e60d      	b.n	10b18 <am_hal_uart_transfer+0x18>
   10efc:	08000001 	.word	0x08000001

00010f00 <am_hal_uart_tx_flush>:
   10f00:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
   10f04:	b570      	push	{r4, r5, r6, lr}
   10f06:	6a45      	ldr	r5, [r0, #36]	; 0x24
   10f08:	4604      	mov	r4, r0
   10f0a:	b15b      	cbz	r3, 10f24 <am_hal_uart_tx_flush+0x24>
   10f0c:	6b43      	ldr	r3, [r0, #52]	; 0x34
   10f0e:	b14b      	cbz	r3, 10f24 <am_hal_uart_tx_flush+0x24>
   10f10:	4e0e      	ldr	r6, [pc, #56]	; (10f4c <am_hal_uart_tx_flush+0x4c>)
   10f12:	6e20      	ldr	r0, [r4, #96]	; 0x60
   10f14:	fbb6 f0f0 	udiv	r0, r6, r0
   10f18:	0100      	lsls	r0, r0, #4
   10f1a:	f7ff f803 	bl	ff24 <am_hal_flash_delay>
   10f1e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   10f20:	2b00      	cmp	r3, #0
   10f22:	d1f6      	bne.n	10f12 <am_hal_uart_tx_flush+0x12>
   10f24:	f505 2580 	add.w	r5, r5, #262144	; 0x40000
   10f28:	351c      	adds	r5, #28
   10f2a:	032d      	lsls	r5, r5, #12
   10f2c:	69ab      	ldr	r3, [r5, #24]
   10f2e:	071a      	lsls	r2, r3, #28
   10f30:	d509      	bpl.n	10f46 <am_hal_uart_tx_flush+0x46>
   10f32:	4e06      	ldr	r6, [pc, #24]	; (10f4c <am_hal_uart_tx_flush+0x4c>)
   10f34:	6e23      	ldr	r3, [r4, #96]	; 0x60
   10f36:	fbb6 f3f3 	udiv	r3, r6, r3
   10f3a:	0118      	lsls	r0, r3, #4
   10f3c:	f7fe fff2 	bl	ff24 <am_hal_flash_delay>
   10f40:	69ab      	ldr	r3, [r5, #24]
   10f42:	071b      	lsls	r3, r3, #28
   10f44:	d4f6      	bmi.n	10f34 <am_hal_uart_tx_flush+0x34>
   10f46:	2000      	movs	r0, #0
   10f48:	bd70      	pop	{r4, r5, r6, pc}
   10f4a:	bf00      	nop
   10f4c:	00b71b00 	.word	0x00b71b00

00010f50 <am_hal_queue_init>:
   10f50:	b410      	push	{r4}
   10f52:	2400      	movs	r4, #0
   10f54:	e9c0 4400 	strd	r4, r4, [r0]
   10f58:	e9c0 4302 	strd	r4, r3, [r0, #8]
   10f5c:	e9c0 2104 	strd	r2, r1, [r0, #16]
   10f60:	f85d 4b04 	ldr.w	r4, [sp], #4
   10f64:	4770      	bx	lr
   10f66:	bf00      	nop

00010f68 <am_hal_queue_item_add>:
   10f68:	b570      	push	{r4, r5, r6, lr}
   10f6a:	6905      	ldr	r5, [r0, #16]
   10f6c:	b082      	sub	sp, #8
   10f6e:	4604      	mov	r4, r0
   10f70:	fb02 f505 	mul.w	r5, r2, r5
   10f74:	460e      	mov	r6, r1
   10f76:	f7ff f99f 	bl	102b8 <am_hal_interrupt_master_disable>
   10f7a:	68e2      	ldr	r2, [r4, #12]
   10f7c:	9001      	str	r0, [sp, #4]
   10f7e:	68a0      	ldr	r0, [r4, #8]
   10f80:	1a13      	subs	r3, r2, r0
   10f82:	42ab      	cmp	r3, r5
   10f84:	d31c      	bcc.n	10fc0 <am_hal_queue_item_add+0x58>
   10f86:	b195      	cbz	r5, 10fae <am_hal_queue_item_add+0x46>
   10f88:	6823      	ldr	r3, [r4, #0]
   10f8a:	b306      	cbz	r6, 10fce <am_hal_queue_item_add+0x66>
   10f8c:	1e71      	subs	r1, r6, #1
   10f8e:	194e      	adds	r6, r1, r5
   10f90:	6962      	ldr	r2, [r4, #20]
   10f92:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   10f96:	54d0      	strb	r0, [r2, r3]
   10f98:	6823      	ldr	r3, [r4, #0]
   10f9a:	68e0      	ldr	r0, [r4, #12]
   10f9c:	3301      	adds	r3, #1
   10f9e:	428e      	cmp	r6, r1
   10fa0:	fbb3 f2f0 	udiv	r2, r3, r0
   10fa4:	fb00 3312 	mls	r3, r0, r2, r3
   10fa8:	6023      	str	r3, [r4, #0]
   10faa:	d1f1      	bne.n	10f90 <am_hal_queue_item_add+0x28>
   10fac:	68a0      	ldr	r0, [r4, #8]
   10fae:	4405      	add	r5, r0
   10fb0:	60a5      	str	r5, [r4, #8]
   10fb2:	9801      	ldr	r0, [sp, #4]
   10fb4:	f7ff f984 	bl	102c0 <am_hal_interrupt_master_set>
   10fb8:	2401      	movs	r4, #1
   10fba:	4620      	mov	r0, r4
   10fbc:	b002      	add	sp, #8
   10fbe:	bd70      	pop	{r4, r5, r6, pc}
   10fc0:	9801      	ldr	r0, [sp, #4]
   10fc2:	f7ff f97d 	bl	102c0 <am_hal_interrupt_master_set>
   10fc6:	2400      	movs	r4, #0
   10fc8:	4620      	mov	r0, r4
   10fca:	b002      	add	sp, #8
   10fcc:	bd70      	pop	{r4, r5, r6, pc}
   10fce:	4631      	mov	r1, r6
   10fd0:	3101      	adds	r1, #1
   10fd2:	3301      	adds	r3, #1
   10fd4:	428d      	cmp	r5, r1
   10fd6:	fbb3 f6f2 	udiv	r6, r3, r2
   10fda:	fb02 3316 	mls	r3, r2, r6, r3
   10fde:	d1f7      	bne.n	10fd0 <am_hal_queue_item_add+0x68>
   10fe0:	6023      	str	r3, [r4, #0]
   10fe2:	e7e4      	b.n	10fae <am_hal_queue_item_add+0x46>

00010fe4 <am_hal_queue_item_get>:
   10fe4:	b570      	push	{r4, r5, r6, lr}
   10fe6:	6905      	ldr	r5, [r0, #16]
   10fe8:	4604      	mov	r4, r0
   10fea:	b082      	sub	sp, #8
   10fec:	fb02 f505 	mul.w	r5, r2, r5
   10ff0:	460e      	mov	r6, r1
   10ff2:	f7ff f961 	bl	102b8 <am_hal_interrupt_master_disable>
   10ff6:	68a2      	ldr	r2, [r4, #8]
   10ff8:	9001      	str	r0, [sp, #4]
   10ffa:	42aa      	cmp	r2, r5
   10ffc:	d31c      	bcc.n	11038 <am_hal_queue_item_get+0x54>
   10ffe:	b195      	cbz	r5, 11026 <am_hal_queue_item_get+0x42>
   11000:	6863      	ldr	r3, [r4, #4]
   11002:	b306      	cbz	r6, 11046 <am_hal_queue_item_get+0x62>
   11004:	1e71      	subs	r1, r6, #1
   11006:	194e      	adds	r6, r1, r5
   11008:	6962      	ldr	r2, [r4, #20]
   1100a:	5cd3      	ldrb	r3, [r2, r3]
   1100c:	f801 3f01 	strb.w	r3, [r1, #1]!
   11010:	6863      	ldr	r3, [r4, #4]
   11012:	68e0      	ldr	r0, [r4, #12]
   11014:	3301      	adds	r3, #1
   11016:	428e      	cmp	r6, r1
   11018:	fbb3 f2f0 	udiv	r2, r3, r0
   1101c:	fb00 3312 	mls	r3, r0, r2, r3
   11020:	6063      	str	r3, [r4, #4]
   11022:	d1f1      	bne.n	11008 <am_hal_queue_item_get+0x24>
   11024:	68a2      	ldr	r2, [r4, #8]
   11026:	9801      	ldr	r0, [sp, #4]
   11028:	1b52      	subs	r2, r2, r5
   1102a:	60a2      	str	r2, [r4, #8]
   1102c:	f7ff f948 	bl	102c0 <am_hal_interrupt_master_set>
   11030:	2401      	movs	r4, #1
   11032:	4620      	mov	r0, r4
   11034:	b002      	add	sp, #8
   11036:	bd70      	pop	{r4, r5, r6, pc}
   11038:	9801      	ldr	r0, [sp, #4]
   1103a:	f7ff f941 	bl	102c0 <am_hal_interrupt_master_set>
   1103e:	2400      	movs	r4, #0
   11040:	4620      	mov	r0, r4
   11042:	b002      	add	sp, #8
   11044:	bd70      	pop	{r4, r5, r6, pc}
   11046:	68e0      	ldr	r0, [r4, #12]
   11048:	4631      	mov	r1, r6
   1104a:	3101      	adds	r1, #1
   1104c:	3301      	adds	r3, #1
   1104e:	42a9      	cmp	r1, r5
   11050:	fbb3 f6f0 	udiv	r6, r3, r0
   11054:	fb00 3316 	mls	r3, r0, r6, r3
   11058:	d1f7      	bne.n	1104a <am_hal_queue_item_get+0x66>
   1105a:	6063      	str	r3, [r4, #4]
   1105c:	e7e3      	b.n	11026 <am_hal_queue_item_get+0x42>
   1105e:	bf00      	nop
   11060:	00000104 	.word	0x00000104
   11064:	70206b36 	.word	0x70206b36
   11068:	6f667265 	.word	0x6f667265
   1106c:	6e616d72 	.word	0x6e616d72
   11070:	72206563 	.word	0x72206563
   11074:	70206e75 	.word	0x70206e75
   11078:	6d617261 	.word	0x6d617261
   1107c:	72657465 	.word	0x72657465
   11080:	6f662073 	.word	0x6f662073
   11084:	6f632072 	.word	0x6f632072
   11088:	616d6572 	.word	0x616d6572
   1108c:	0a2e6b72 	.word	0x0a2e6b72
   11090:	00000000 	.word	0x00000000
   11094:	76206b36 	.word	0x76206b36
   11098:	64696c61 	.word	0x64696c61
   1109c:	6f697461 	.word	0x6f697461
   110a0:	7572206e 	.word	0x7572206e
   110a4:	6170206e 	.word	0x6170206e
   110a8:	656d6172 	.word	0x656d6172
   110ac:	73726574 	.word	0x73726574
   110b0:	726f6620 	.word	0x726f6620
   110b4:	726f6320 	.word	0x726f6320
   110b8:	72616d65 	.word	0x72616d65
   110bc:	000a2e6b 	.word	0x000a2e6b
   110c0:	666f7250 	.word	0x666f7250
   110c4:	20656c69 	.word	0x20656c69
   110c8:	656e6567 	.word	0x656e6567
   110cc:	69746172 	.word	0x69746172
   110d0:	72206e6f 	.word	0x72206e6f
   110d4:	70206e75 	.word	0x70206e75
   110d8:	6d617261 	.word	0x6d617261
   110dc:	72657465 	.word	0x72657465
   110e0:	6f662073 	.word	0x6f662073
   110e4:	6f632072 	.word	0x6f632072
   110e8:	616d6572 	.word	0x616d6572
   110ec:	0a2e6b72 	.word	0x0a2e6b72
   110f0:	00000000 	.word	0x00000000
   110f4:	70204b32 	.word	0x70204b32
   110f8:	6f667265 	.word	0x6f667265
   110fc:	6e616d72 	.word	0x6e616d72
   11100:	72206563 	.word	0x72206563
   11104:	70206e75 	.word	0x70206e75
   11108:	6d617261 	.word	0x6d617261
   1110c:	72657465 	.word	0x72657465
   11110:	6f662073 	.word	0x6f662073
   11114:	6f632072 	.word	0x6f632072
   11118:	616d6572 	.word	0x616d6572
   1111c:	0a2e6b72 	.word	0x0a2e6b72
   11120:	00000000 	.word	0x00000000
   11124:	76204b32 	.word	0x76204b32
   11128:	64696c61 	.word	0x64696c61
   1112c:	6f697461 	.word	0x6f697461
   11130:	7572206e 	.word	0x7572206e
   11134:	6170206e 	.word	0x6170206e
   11138:	656d6172 	.word	0x656d6172
   1113c:	73726574 	.word	0x73726574
   11140:	726f6620 	.word	0x726f6620
   11144:	726f6320 	.word	0x726f6320
   11148:	72616d65 	.word	0x72616d65
   1114c:	000a2e6b 	.word	0x000a2e6b
   11150:	5d75255b 	.word	0x5d75255b
   11154:	4f525245 	.word	0x4f525245
   11158:	6c202152 	.word	0x6c202152
   1115c:	20747369 	.word	0x20747369
   11160:	20637263 	.word	0x20637263
   11164:	30257830 	.word	0x30257830
   11168:	2d207834 	.word	0x2d207834
   1116c:	6f687320 	.word	0x6f687320
   11170:	20646c75 	.word	0x20646c75
   11174:	30206562 	.word	0x30206562
   11178:	34302578 	.word	0x34302578
   1117c:	00000a78 	.word	0x00000a78
   11180:	5d75255b 	.word	0x5d75255b
   11184:	4f525245 	.word	0x4f525245
   11188:	6d202152 	.word	0x6d202152
   1118c:	69727461 	.word	0x69727461
   11190:	72632078 	.word	0x72632078
   11194:	78302063 	.word	0x78302063
   11198:	78343025 	.word	0x78343025
   1119c:	73202d20 	.word	0x73202d20
   111a0:	6c756f68 	.word	0x6c756f68
   111a4:	65622064 	.word	0x65622064
   111a8:	25783020 	.word	0x25783020
   111ac:	0a783430 	.word	0x0a783430
   111b0:	00000000 	.word	0x00000000
   111b4:	5d75255b 	.word	0x5d75255b
   111b8:	4f525245 	.word	0x4f525245
   111bc:	73202152 	.word	0x73202152
   111c0:	65746174 	.word	0x65746174
   111c4:	63726320 	.word	0x63726320
   111c8:	25783020 	.word	0x25783020
   111cc:	20783430 	.word	0x20783430
   111d0:	6873202d 	.word	0x6873202d
   111d4:	646c756f 	.word	0x646c756f
   111d8:	20656220 	.word	0x20656220
   111dc:	30257830 	.word	0x30257830
   111e0:	000a7834 	.word	0x000a7834
   111e4:	65726f43 	.word	0x65726f43
   111e8:	6b72614d 	.word	0x6b72614d
   111ec:	7a695320 	.word	0x7a695320
   111f0:	20202065 	.word	0x20202065
   111f4:	25203a20 	.word	0x25203a20
   111f8:	000a756c 	.word	0x000a756c
   111fc:	61746f54 	.word	0x61746f54
   11200:	6974206c 	.word	0x6974206c
   11204:	20736b63 	.word	0x20736b63
   11208:	20202020 	.word	0x20202020
   1120c:	25203a20 	.word	0x25203a20
   11210:	0a756c6c 	.word	0x0a756c6c
   11214:	00000000 	.word	0x00000000
   11218:	61746f54 	.word	0x61746f54
   1121c:	6974206c 	.word	0x6974206c
   11220:	2820656d 	.word	0x2820656d
   11224:	73636573 	.word	0x73636573
   11228:	25203a29 	.word	0x25203a29
   1122c:	00000a66 	.word	0x00000a66
   11230:	72657449 	.word	0x72657449
   11234:	6f697461 	.word	0x6f697461
   11238:	532f736e 	.word	0x532f736e
   1123c:	20206365 	.word	0x20206365
   11240:	25203a20 	.word	0x25203a20
   11244:	00000a66 	.word	0x00000a66
   11248:	4f525245 	.word	0x4f525245
   1124c:	4d202152 	.word	0x4d202152
   11250:	20747375 	.word	0x20747375
   11254:	63657865 	.word	0x63657865
   11258:	20657475 	.word	0x20657475
   1125c:	20726f66 	.word	0x20726f66
   11260:	6c207461 	.word	0x6c207461
   11264:	74736165 	.word	0x74736165
   11268:	20303120 	.word	0x20303120
   1126c:	73636573 	.word	0x73636573
   11270:	726f6620 	.word	0x726f6620
   11274:	76206120 	.word	0x76206120
   11278:	64696c61 	.word	0x64696c61
   1127c:	73657220 	.word	0x73657220
   11280:	21746c75 	.word	0x21746c75
   11284:	0000000a 	.word	0x0000000a
   11288:	72657449 	.word	0x72657449
   1128c:	6f697461 	.word	0x6f697461
   11290:	2020736e 	.word	0x2020736e
   11294:	20202020 	.word	0x20202020
   11298:	25203a20 	.word	0x25203a20
   1129c:	000a756c 	.word	0x000a756c
   112a0:	20434347 	.word	0x20434347
   112a4:	332e3031 	.word	0x332e3031
   112a8:	3220312e 	.word	0x3220312e
   112ac:	30313230 	.word	0x30313230
   112b0:	20343238 	.word	0x20343238
   112b4:	6c657228 	.word	0x6c657228
   112b8:	65736165 	.word	0x65736165
   112bc:	00000029 	.word	0x00000029
   112c0:	706d6f43 	.word	0x706d6f43
   112c4:	72656c69 	.word	0x72656c69
   112c8:	72657620 	.word	0x72657620
   112cc:	6e6f6973 	.word	0x6e6f6973
   112d0:	25203a20 	.word	0x25203a20
   112d4:	00000a73 	.word	0x00000a73
   112d8:	43415453 	.word	0x43415453
   112dc:	0000004b 	.word	0x0000004b
   112e0:	6f6d654d 	.word	0x6f6d654d
   112e4:	6c207972 	.word	0x6c207972
   112e8:	7461636f 	.word	0x7461636f
   112ec:	206e6f69 	.word	0x206e6f69
   112f0:	25203a20 	.word	0x25203a20
   112f4:	00000a73 	.word	0x00000a73
   112f8:	64656573 	.word	0x64656573
   112fc:	20637263 	.word	0x20637263
   11300:	20202020 	.word	0x20202020
   11304:	20202020 	.word	0x20202020
   11308:	30203a20 	.word	0x30203a20
   1130c:	34302578 	.word	0x34302578
   11310:	00000a78 	.word	0x00000a78
   11314:	5d64255b 	.word	0x5d64255b
   11318:	6c637263 	.word	0x6c637263
   1131c:	20747369 	.word	0x20747369
   11320:	20202020 	.word	0x20202020
   11324:	203a2020 	.word	0x203a2020
   11328:	30257830 	.word	0x30257830
   1132c:	000a7834 	.word	0x000a7834
   11330:	5d64255b 	.word	0x5d64255b
   11334:	6d637263 	.word	0x6d637263
   11338:	69727461 	.word	0x69727461
   1133c:	20202078 	.word	0x20202078
   11340:	203a2020 	.word	0x203a2020
   11344:	30257830 	.word	0x30257830
   11348:	000a7834 	.word	0x000a7834
   1134c:	5d64255b 	.word	0x5d64255b
   11350:	73637263 	.word	0x73637263
   11354:	65746174 	.word	0x65746174
   11358:	20202020 	.word	0x20202020
   1135c:	203a2020 	.word	0x203a2020
   11360:	30257830 	.word	0x30257830
   11364:	000a7834 	.word	0x000a7834
   11368:	5d64255b 	.word	0x5d64255b
   1136c:	66637263 	.word	0x66637263
   11370:	6c616e69 	.word	0x6c616e69
   11374:	20202020 	.word	0x20202020
   11378:	203a2020 	.word	0x203a2020
   1137c:	30257830 	.word	0x30257830
   11380:	000a7834 	.word	0x000a7834
   11384:	72726f43 	.word	0x72726f43
   11388:	20746365 	.word	0x20746365
   1138c:	7265706f 	.word	0x7265706f
   11390:	6f697461 	.word	0x6f697461
   11394:	6176206e 	.word	0x6176206e
   11398:	6164696c 	.word	0x6164696c
   1139c:	2e646574 	.word	0x2e646574
   113a0:	65655320 	.word	0x65655320
   113a4:	61657220 	.word	0x61657220
   113a8:	2e656d64 	.word	0x2e656d64
   113ac:	20747874 	.word	0x20747874
   113b0:	20726f66 	.word	0x20726f66
   113b4:	206e7572 	.word	0x206e7572
   113b8:	20646e61 	.word	0x20646e61
   113bc:	6f706572 	.word	0x6f706572
   113c0:	6e697472 	.word	0x6e697472
   113c4:	75722067 	.word	0x75722067
   113c8:	2e73656c 	.word	0x2e73656c
   113cc:	0000000a 	.word	0x0000000a
   113d0:	65726f43 	.word	0x65726f43
   113d4:	6b72614d 	.word	0x6b72614d
   113d8:	302e3120 	.word	0x302e3120
   113dc:	25203a20 	.word	0x25203a20
   113e0:	202f2066 	.word	0x202f2066
   113e4:	25207325 	.word	0x25207325
   113e8:	00000073 	.word	0x00000073
   113ec:	67616c66 	.word	0x67616c66
   113f0:	2d203a73 	.word	0x2d203a73
   113f4:	0000336f 	.word	0x0000336f
   113f8:	25202f20 	.word	0x25202f20
   113fc:	00000073 	.word	0x00000073
   11400:	6f727245 	.word	0x6f727245
   11404:	64207372 	.word	0x64207372
   11408:	63657465 	.word	0x63657465
   1140c:	0a646574 	.word	0x0a646574
   11410:	00000000 	.word	0x00000000
   11414:	6e6e6143 	.word	0x6e6e6143
   11418:	7620746f 	.word	0x7620746f
   1141c:	64696c61 	.word	0x64696c61
   11420:	20657461 	.word	0x20657461
   11424:	7265706f 	.word	0x7265706f
   11428:	6f697461 	.word	0x6f697461
   1142c:	6f66206e 	.word	0x6f66206e
   11430:	68742072 	.word	0x68742072
   11434:	20657365 	.word	0x20657365
   11438:	64656573 	.word	0x64656573
   1143c:	6c617620 	.word	0x6c617620
   11440:	2c736575 	.word	0x2c736575
   11444:	656c7020 	.word	0x656c7020
   11448:	20657361 	.word	0x20657361
   1144c:	706d6f63 	.word	0x706d6f63
   11450:	20657261 	.word	0x20657261
   11454:	68746977 	.word	0x68746977
   11458:	73657220 	.word	0x73657220
   1145c:	73746c75 	.word	0x73746c75
   11460:	206e6f20 	.word	0x206e6f20
   11464:	6e6b2061 	.word	0x6e6b2061
   11468:	206e776f 	.word	0x206e776f
   1146c:	74616c70 	.word	0x74616c70
   11470:	6d726f66 	.word	0x6d726f66
   11474:	00000a2e 	.word	0x00000a2e
   11478:	4d2f4d43 	.word	0x4d2f4d43
   1147c:	253d7a48 	.word	0x253d7a48
   11480:	2e66332e 	.word	0x2e66332e
   11484:	0000000a 	.word	0x0000000a
   11488:	6c696146 	.word	0x6c696146
   1148c:	74206465 	.word	0x74206465
   11490:	6573206f 	.word	0x6573206f
   11494:	61632074 	.word	0x61632074
   11498:	20656863 	.word	0x20656863
   1149c:	6f746e69 	.word	0x6f746e69
   114a0:	4d504c20 	.word	0x4d504c20
   114a4:	45444f4d 	.word	0x45444f4d
   114a8:	4747415f 	.word	0x4747415f
   114ac:	53534552 	.word	0x53534552
   114b0:	2e455649 	.word	0x2e455649
   114b4:	0000000a 	.word	0x0000000a
   114b8:	6c696146 	.word	0x6c696146
   114bc:	74206465 	.word	0x74206465
   114c0:	6572206f 	.word	0x6572206f
   114c4:	666e6f63 	.word	0x666e6f63
   114c8:	72756769 	.word	0x72756769
   114cc:	6c462065 	.word	0x6c462065
   114d0:	20687361 	.word	0x20687361
   114d4:	20726f66 	.word	0x20726f66
   114d8:	696e696d 	.word	0x696e696d
   114dc:	2e6d756d 	.word	0x2e6d756d
   114e0:	0000000a 	.word	0x0000000a
   114e4:	6c696146 	.word	0x6c696146
   114e8:	74206465 	.word	0x74206465
   114ec:	6572206f 	.word	0x6572206f
   114f0:	666e6f63 	.word	0x666e6f63
   114f4:	72756769 	.word	0x72756769
   114f8:	52532065 	.word	0x52532065
   114fc:	0a2e4d41 	.word	0x0a2e4d41
   11500:	00000000 	.word	0x00000000
   11504:	69626d41 	.word	0x69626d41
   11508:	694d2071 	.word	0x694d2071
   1150c:	206f7263 	.word	0x206f7263
   11510:	65726f43 	.word	0x65726f43
   11514:	6b72616d 	.word	0x6b72616d
   11518:	73657420 	.word	0x73657420
   1151c:	2e2e2e74 	.word	0x2e2e2e74
   11520:	00000a0a 	.word	0x00000a0a
   11524:	6c696146 	.word	0x6c696146
   11528:	74206465 	.word	0x74206465
   1152c:	6572206f 	.word	0x6572206f
   11530:	616e652d 	.word	0x616e652d
   11534:	20656c62 	.word	0x20656c62
   11538:	206c6c61 	.word	0x206c6c61
   1153c:	6f6d656d 	.word	0x6f6d656d
   11540:	000a7972 	.word	0x000a7972
   11544:	626d410a 	.word	0x626d410a
   11548:	4d207169 	.word	0x4d207169
   1154c:	6f726369 	.word	0x6f726369
   11550:	726f4320 	.word	0x726f4320
   11554:	72616d65 	.word	0x72616d65
   11558:	7572206b 	.word	0x7572206b
   1155c:	6966206e 	.word	0x6966206e
   11560:	6873696e 	.word	0x6873696e
   11564:	0a216465 	.word	0x0a216465
   11568:	0000000a 	.word	0x0000000a
   1156c:	46465542 	.word	0x46465542
   11570:	4f205245 	.word	0x4f205245
   11574:	46524556 	.word	0x46524556
   11578:	45574f4c 	.word	0x45574f4c
   1157c:	49202144 	.word	0x49202144
   11580:	6572636e 	.word	0x6572636e
   11584:	20657361 	.word	0x20657361
   11588:	42545250 	.word	0x42545250
   1158c:	49534655 	.word	0x49534655
   11590:	000a455a 	.word	0x000a455a
   11594:	332e3054 	.word	0x332e3054
   11598:	46312d65 	.word	0x46312d65
   1159c:	00000000 	.word	0x00000000
   115a0:	542e542d 	.word	0x542e542d
   115a4:	71542b2b 	.word	0x71542b2b
   115a8:	00000000 	.word	0x00000000
   115ac:	2e335431 	.word	0x2e335431
   115b0:	7a346534 	.word	0x7a346534
   115b4:	00000000 	.word	0x00000000
   115b8:	302e3433 	.word	0x302e3433
   115bc:	5e542d65 	.word	0x5e542d65
   115c0:	00000000 	.word	0x00000000
   115c4:	30352e35 	.word	0x30352e35
   115c8:	332b6530 	.word	0x332b6530
   115cc:	00000000 	.word	0x00000000
   115d0:	32312e2d 	.word	0x32312e2d
   115d4:	322d6533 	.word	0x322d6533
   115d8:	00000000 	.word	0x00000000
   115dc:	6537382d 	.word	0x6537382d
   115e0:	3233382b 	.word	0x3233382b
   115e4:	00000000 	.word	0x00000000
   115e8:	362e302b 	.word	0x362e302b
   115ec:	32312d65 	.word	0x32312d65
   115f0:	00000000 	.word	0x00000000
   115f4:	352e3533 	.word	0x352e3533
   115f8:	30303434 	.word	0x30303434
   115fc:	00000000 	.word	0x00000000
   11600:	3332312e 	.word	0x3332312e
   11604:	30303534 	.word	0x30303534
   11608:	00000000 	.word	0x00000000
   1160c:	3031312d 	.word	0x3031312d
   11610:	3030372e 	.word	0x3030372e
   11614:	00000000 	.word	0x00000000
   11618:	362e302b 	.word	0x362e302b
   1161c:	30303434 	.word	0x30303434
   11620:	00000000 	.word	0x00000000
   11624:	32313035 	.word	0x32313035
   11628:	00000000 	.word	0x00000000
   1162c:	34333231 	.word	0x34333231
   11630:	00000000 	.word	0x00000000
   11634:	3437382d 	.word	0x3437382d
   11638:	00000000 	.word	0x00000000
   1163c:	3232312b 	.word	0x3232312b
   11640:	00000000 	.word	0x00000000

00011644 <errpat>:
   11644:	00011594 000115a0 000115ac 000115b8     ................

00011654 <floatpat>:
   11654:	000115f4 00011600 0001160c 00011618     ................

00011664 <intpat>:
   11664:	00011624 0001162c 00011634 0001163c     $...,...4...<...

00011674 <scipat>:
   11674:	000115c4 000115d0 000115dc 000115e8     ................
   11684:	0a0a0a0a 0a0a0a0a 0a0a0a0a 0a0a0a0a     ................
   11694:	00000a0a                                ....

00011698 <g_sBspUartConfig>:
   11698:	0001c200 00000060 00000000 00000000     ....`...........
   116a8:	00000000 00000012 00000000 00000000     ................
	...

000116c0 <g_AM_BSP_GPIO_COM_UART_RX>:
   116c0:	00000000                                ....

000116c4 <g_AM_BSP_GPIO_COM_UART_TX>:
   116c4:	00000000                                ....

000116c8 <am_hal_cachectrl_defaults>:
   116c8:	00000308                                ....

000116cc <g_AM_HAL_GPIO_DISABLE>:
   116cc:	00000003                                ....

000116d0 <g_AM_HAL_GPIO_OUTPUT>:
   116d0:	00000403                                ....

000116d4 <g_AM_HAL_GPIO_TRISTATE>:
   116d4:	00000c03                                ....

000116d8 <g_ui8Bit76Capabilities>:
   116d8:	02800101 80010180 80800101 80808080     ................
   116e8:	80808080 80808008 01800180 80808080     ................
   116f8:	80808080 01800402 01010401 80808080     ................
   11708:	00000101                                ....

0001170c <g_ui8Inpen>:
   1170c:	62272323 108703a1 e1005303 55418151     ##'b.....S..Q.AU
   1171c:	4080c405 4140b101 31a03114 1180f100     ...@..@A.1.1....
   1172c:	11c12191 304511e5 31300037 40007100     .!....E07.01.q.@
   1173c:	00003130                                01..

00011740 <g_ui8NCEtable>:
   11740:	13524232 60221202 21534333 20504030     2BR..."`3CS!0@P 
   11750:	11514131 ffffffff ffffffff 60514131     1AQ.........1AQ`
   11760:	00504030 23534333 60524232 30201000     0@P.3CS#2BR`.. 0
   11770:	61504030 01514131 42221202 60231303     0@Pa1AQ..."B..#`
   11780:	50201000 41211101 32221202 60331303     .. P..!A.."2..3`
   11790:	21514131 22524232 03534333 40201000     1AQ!2BR"3CS... @
   117a0:	51211101 02524232 13534333 10504030     ..!Q2BR.3CS.0@P.
   117b0:	60514131 12524232 03534333 40201000     1AQ`2BR.3CS... @
   117c0:	61211101 52221202 33231303 30201000     ..!a.."R..#3.. 0
   117d0:	61514131 02524232 53331303 ffffffff     1AQa2BR...3S....
   117e0:	ffffffff 61211101 50201000 61211101     ......!a.. P..!a
   117f0:	52221202 13534333 61504030 31211101     .."R3CS.0@Pa..!1
   11800:	32221202 43231303                       .."2..#C

00011808 <g_ui8nCEpins>:
   11808:	02070707 00080802 01020202 01010101     ................
   11818:	01010101 01010101 01010101 01010101     ................
   11828:	01010101 08010101 01010008 01010101     ................
   11838:	00000101                                ....

0001183c <g_am_hal_mcuctrl_flash_size>:
   1183c:	00004000 00008000 00010000 00020000     .@..............
   1184c:	00040000 00080000 00100000 00200000     .............. .
   1185c:	00180000 00000000 00000000 00000000     ................
	...

0001187c <g_am_hal_mcuctrl_sram_size>:
   1187c:	00004000 00008000 00010000 00020000     .@..............
   1188c:	00040000 00080000 00100000 00060000     ................
   1189c:	000c0000 00000000 00000000 00000000     ................
	...

000118bc <am_hal_pwrctrl_memory_control>:
	...
   118d4:	00000001 00000001 00000001 00001fff     ................
   118e4:	00001fff 00000001 00000003 00000003     ................
   118f4:	00000003 00001fff 00001fff 00000003     ................
   11904:	00000007 00000007 00000007 00001fff     ................
   11914:	00001fff 00000007 0000000f 0000000f     ................
   11924:	0000000f 00001fff 00001fff 0000000f     ................
   11934:	0000001f 0000001f 0000001f 00001fff     ................
   11944:	00001fff 0000001f 0000003f 0000003f     ........?...?...
   11954:	0000003f 00001fff 00001fff 0000003f     ?...........?...
   11964:	0000007f 0000007f 0000007f 00001fff     ................
   11974:	00001fff 0000007f 000000ff 000000ff     ................
   11984:	000000ff 00001fff 00001fff 000000ff     ................
   11994:	000001ff 000001ff 000001ff 00001fff     ................
   119a4:	00001fff 000001ff 000003ff 000003ff     ................
   119b4:	000003ff 00001fff 00001fff 000003ff     ................
   119c4:	000007ff 000007ff 000007ff 00001fff     ................
   119d4:	00001fff 000007ff 00000fff 00000fff     ................
   119e4:	00000fff 00001fff 00001fff 00000fff     ................
   119f4:	00001fff 00001fff 00001fff 00001fff     ................
   11a04:	00001fff 00001fff 00002000 00002000     ......... ... ..
   11a14:	00002000 00006000 00006000 00002000     . ...`...`... ..
   11a24:	00006000 00006000 00006000 00006000     .`...`...`...`..
   11a34:	00006000 00006000 c0000000 00000000     .`...`..........
   11a44:	c0000000 c0000000 00000000 80000000     ................
   11a54:	c0007fff 00007fff c0007fff c0007fff     ................
   11a64:	00007fff 80007fff                       ........

00011a6c <am_hal_pwrctrl_peripheral_control>:
	...
   11a78:	00000001 00000004 00000004 00000002     ................
   11a88:	00000008 00000008 00000004 00000008     ................
   11a98:	00000008 00000008 00000008 00000008     ................
   11aa8:	00000010 00000010 00000010 00000020     ............ ...
   11ab8:	00000010 00000010 00000040 00000010     ........@.......
   11ac8:	00000010 00000080 00000004 00000004     ................
   11ad8:	00000100 00000004 00000004 00000200     ................
   11ae8:	00000020 00000020 00000400 00000004      ... ...........
   11af8:	00000004 00000800 00000040 00000040     ........@...@...
   11b08:	00001000 00000080 00000080 00002000     ............. ..
   11b18:	00000100 00000100                       ........

00011b20 <CSWTCH.20>:
   11b20:	016e3600 00b71b00 005b8d80 002dc6c0     .6n.......[...-.
